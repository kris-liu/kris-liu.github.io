<!DOCTYPE html><html lang="zh-CN"><head><meta name="google-site-verification" content="DVfrDhwMEodDoWVy6nv0PCpolWhBlGBSaO9hiU2r61E"><meta name="google-site-verification" content="40TgWkMJTOetJQqAMZwk5nD5rtVQRjk5i2pe6FGka5g"><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content="佑祺's Blog"><title>JUC - AbstractQueuedSynchronizer(AQS) 源码分析 | 佑祺's Blog</title><link rel="stylesheet" type="text/css" href="/css/style.css?v=0.0.0"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/normalize/8.0.0/normalize.min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/1.0.0/pure-min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/1.0.0/grids-responsive-min.css"><link rel="stylesheet" href="//cdn.bootcss.com/font-awesome/4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="//cdn.bootcss.com/jquery/3.3.1/jquery.min.js"></script><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"><script>(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','https://www.google-analytics.com/analytics.js','ga');
ga('create','UA-91282031-1','auto');ga('send','pageview');
</script></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">JUC - AbstractQueuedSynchronizer(AQS) 源码分析</h1><a id="logo" href="/.">佑祺's Blog</a><p class="description">Whatever you do, you have to keep moving forward!</p></div><div id="nav-menu"><a class="current" href="/."><i class="fa fa-home"> 首页</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a><a href="/about/"><i class="fa fa-user"> 关于</i></a><a href="/atom.xml"><i class="fa fa-rss"> 订阅</i></a></div></div><div class="pure-g" id="layout"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">JUC - AbstractQueuedSynchronizer(AQS) 源码分析</h1><div class="post-meta">Sep 28, 2016<span> | </span><span class="category"><a href="/categories/Concurrent/">Concurrent</a></span></div><div class="post-content"><p>AbstractQueuedSynchronizer，同步器，以下简称AQS。本文从源码分析AQS的核心方法和实现原理。</p>
<p>AQS内部有两组重要的成员变量：</p>
<ol>
<li><p>int类型的status变量，通过CAS操作（详见：<a href="http://blog.csdn.net/hsuxu/article/details/9467651" target="_blank" rel="external">CAS深度分析</a>）改变status值来控制当前线程能否访问资源以及并发数量。</p>
</li>
<li><p>Node类型的head和tail两个变量，两个变量维护了一个FIFO的同步队列，将获取访问权限失败的线程构造成Node节点加入队列中，释放资源时再来唤醒队列中阻塞的线程。（Node类型主要包涵节点的状态，当前线程的引用，以及前驱节点和后置节点的引用）</p>
</li>
</ol>
<a id="more"></a>
<h1 id="使用方式"><a href="#使用方式" class="headerlink" title="使用方式"></a>使用方式</h1><p>AQS在使用时一般是作为自定义同步工具的内部类，实现AQS中可重写的方法，来自定义获取以及释放锁的方式，在自定义同步工具类中，调用AQS中提供给使用者的模版方法，来控制锁的获取和释放。</p>
<h2 id="提供给使用者调用的模版方法："><a href="#提供给使用者调用的模版方法：" class="headerlink" title="提供给使用者调用的模版方法："></a>提供给使用者调用的模版方法：</h2><p>独占式</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">acquire</span><span class="params">(<span class="keyword">int</span> arg)</span></span></div><div class="line">以独占模式获取对象，忽略中断。</div><div class="line"></div><div class="line"><span class="keyword">void</span> <span class="title">acquireInterruptibly</span><span class="params">(<span class="keyword">int</span> arg)</span> <span class="keyword">throws</span> InterruptedException</div><div class="line">以独占模式获取对象，如果被中断则中止，抛出InterruptedException。</div><div class="line"></div><div class="line"><span class="keyword">boolean</span> <span class="title">tryAcquireNanos</span><span class="params">(<span class="keyword">int</span> arg,<span class="keyword">long</span> nanosTimeout)</span> <span class="keyword">throws</span> InterruptedException</div><div class="line">试图以独占模式获取对象，如果被中断则中止，抛出InterruptedException，如果到了给定超时时间，则会返回失败。</div><div class="line"></div><div class="line"><span class="keyword">boolean</span> <span class="title">release</span><span class="params">(<span class="keyword">int</span> arg)</span></div><div class="line">以独占模式释放对象。</div></pre></td></tr></table></figure>
<p>共享式</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">acquireShared</span><span class="params">(<span class="keyword">int</span> arg)</span></span></div><div class="line">以共享模式获取对象，忽略中断。</div><div class="line"></div><div class="line"><span class="keyword">void</span> <span class="title">acquireSharedInterruptibly</span><span class="params">(<span class="keyword">int</span> arg)</span> <span class="keyword">throws</span> InterruptedException</div><div class="line">以共享模式获取对象，如果被中断则中止，抛出InterruptedException。</div><div class="line"></div><div class="line"><span class="keyword">boolean</span> <span class="title">tryAcquireSharedNanos</span><span class="params">(<span class="keyword">int</span> arg,<span class="keyword">long</span> nanosTimeout)</span> <span class="keyword">throws</span> InterruptedException</div><div class="line">试图以共享模式获取对象，如果被中断则中止，抛出InterruptedException，如果到了给定超时时间，则会返回失败。</div><div class="line"></div><div class="line"><span class="keyword">boolean</span> <span class="title">releaseShared</span><span class="params">(<span class="keyword">int</span> arg)</span></div><div class="line">以共享模式释放对象。</div></pre></td></tr></table></figure>
<h2 id="同步器可重写的方法："><a href="#同步器可重写的方法：" class="headerlink" title="同步器可重写的方法："></a>同步器可重写的方法：</h2><p>独占式</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">(<span class="keyword">int</span> arg)</span>	</span></div><div class="line">独占的获取这个状态。这个方法的实现需要查询当前状态是否允许获取，然后再进行获取（使用compareAndSetState来做）状态。</div><div class="line"></div><div class="line"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">tryRelease</span><span class="params">(<span class="keyword">int</span> arg)</span> 	</div><div class="line">释放状态。</div></pre></td></tr></table></figure>
<p>共享式</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">int</span> <span class="title">tryAcquireShared</span><span class="params">(<span class="keyword">int</span> arg)</span>	</span></div><div class="line">共享的模式下获取状态。</div><div class="line"></div><div class="line"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">tryReleaseShared</span><span class="params">(<span class="keyword">int</span> arg)</span>	</div><div class="line">共享的模式下释放状态。</div></pre></td></tr></table></figure>
<h1 id="核心方法及源码分析"><a href="#核心方法及源码分析" class="headerlink" title="核心方法及源码分析"></a>核心方法及源码分析</h1><h2 id="独占模式的获取和释放"><a href="#独占模式的获取和释放" class="headerlink" title="独占模式的获取和释放"></a>独占模式的获取和释放</h2><h3 id="void-acquire-int-arg"><a href="#void-acquire-int-arg" class="headerlink" title="* void acquire(int arg)"></a>* void acquire(int arg)</h3><p>以独占模式获取对象，忽略中断。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">acquire</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</div><div class="line">       <span class="keyword">if</span> (!tryAcquire(arg) <span class="comment">//通过CAS更新status尝试获取</span></div><div class="line">        &amp;&amp; acquireQueued(addWaiter(Node.EXCLUSIVE) <span class="comment">//获取锁失败后添加到同步队列</span></div><div class="line">        , arg)) <span class="comment">//在队列中自旋直至成功获取锁才返回，线程可能被反复park、unpark，直到获取锁，返回值代表是否被中断过</span></div><div class="line">           selfInterrupt(); <span class="comment">//之前被中断过则还原中断状态</span></div><div class="line">   &#125;</div></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> Node <span class="title">addWaiter</span><span class="params">(Node mode)</span> </span>&#123; <span class="comment">//添加到同步队列</span></div><div class="line">       Node node = <span class="keyword">new</span> Node(Thread.currentThread(), mode); <span class="comment">//把当前线程构造成Node节点</span></div><div class="line">       Node pred = tail; <span class="comment">//获取当前的tail节点</span></div><div class="line">       <span class="keyword">if</span> (pred != <span class="keyword">null</span>) &#123;</div><div class="line">           node.prev = pred; <span class="comment">//当前节点前驱节点设置为当前的tail节点</span></div><div class="line">           <span class="keyword">if</span> (compareAndSetTail(pred, node)) &#123; <span class="comment">//CAS操作，如果内存中当前tail节点的值是pred，则将tail节点指向当前新节点node，返回true代表新节点成功进入队列</span></div><div class="line">               pred.next = node; <span class="comment">//将前驱节点的next设置为node节点，这个节点无法和tail节点一起通过CAS操作设置，next节点仅仅是为了优化，当next为空时，始终可以通过tail节点的pred字段从后向前遍历所有节点。</span></div><div class="line">               <span class="keyword">return</span> node;</div><div class="line">           &#125;</div><div class="line">       &#125;</div><div class="line">       enq(node); <span class="comment">//失败时通过无线循环直至成功添加节点</span></div><div class="line">       <span class="keyword">return</span> node;</div><div class="line">   &#125;</div><div class="line">   </div><div class="line"><span class="function"><span class="keyword">private</span> Node <span class="title">enq</span><span class="params">(<span class="keyword">final</span> Node node)</span> </span>&#123;</div><div class="line">       <span class="keyword">for</span> (;;) &#123;</div><div class="line">           Node t = tail;</div><div class="line">           <span class="keyword">if</span> (t == <span class="keyword">null</span>) &#123; <span class="comment">//当前没有初始化过队列则创建初始化新节点，再通过循环添加当前线程节点</span></div><div class="line">               <span class="keyword">if</span> (compareAndSetHead(<span class="keyword">new</span> Node())) <span class="comment">//原子地设置头结点</span></div><div class="line">                   tail = head;</div><div class="line">           &#125; <span class="keyword">else</span> &#123;</div><div class="line">               node.prev = t;</div><div class="line">               <span class="keyword">if</span> (compareAndSetTail(t, node)) &#123;</div><div class="line">                   t.next = node;</div><div class="line">                   <span class="keyword">return</span> t;</div><div class="line">               &#125;</div><div class="line">           &#125;</div><div class="line">       &#125;</div><div class="line">   &#125;</div></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">acquireQueued</span><span class="params">(<span class="keyword">final</span> Node node, <span class="keyword">int</span> arg)</span> </span>&#123; <span class="comment">//使节点阻塞自旋，直至获取到锁，才返回。</span></div><div class="line">       <span class="keyword">boolean</span> failed = <span class="keyword">true</span>; <span class="comment">//当前获取是否失败</span></div><div class="line">       <span class="keyword">try</span> &#123;</div><div class="line">           <span class="keyword">boolean</span> interrupted = <span class="keyword">false</span>; <span class="comment">//当前获取是否被中断</span></div><div class="line">           <span class="keyword">for</span> (;;) &#123;</div><div class="line">               <span class="keyword">final</span> Node p = node.predecessor(); <span class="comment">//获取有效的前驱节点，前驱节点一定不为null</span></div><div class="line">               <span class="keyword">if</span> (p == head <span class="comment">//head节点要么是初始化的节点，要么代表当前成功获取到锁的线程，所以前驱节点是head的时候，当前节点才应该尝试去获取锁 </span></div><div class="line">                   &amp;&amp; tryAcquire(arg) ) &#123; <span class="comment">//尝试获取锁</span></div><div class="line">                   setHead(node); <span class="comment">//设置当前节点为head</span></div><div class="line">                   p.next = <span class="keyword">null</span>; <span class="comment">//之前老的head节点next引用置空 help GC </span></div><div class="line">                   failed = <span class="keyword">false</span>;</div><div class="line">                   <span class="keyword">return</span> interrupted;</div><div class="line">               &#125;</div><div class="line">               <span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) <span class="comment">//查看当前节点是否应该被park </span></div><div class="line">                   &amp;&amp; parkAndCheckInterrupt()) <span class="comment">//park当前线程，直到被其他线程unpark，如果被中断唤醒，则返回true，由于acquire忽略中断所以重新尝试获取锁，获取失败失败重新park。</span></div><div class="line">                   interrupted = <span class="keyword">true</span>; <span class="comment">//线程被中断过</span></div><div class="line">           &#125;</div><div class="line">       &#125; <span class="keyword">finally</span> &#123;</div><div class="line">           <span class="keyword">if</span> (failed)</div><div class="line">               cancelAcquire(node); <span class="comment">//取消当前线程</span></div><div class="line">       &#125;</div><div class="line">   &#125;</div><div class="line">   </div><div class="line">   <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">shouldParkAfterFailedAcquire</span><span class="params">(Node pred, Node node)</span> </span>&#123; <span class="comment">//查看当前节点是否应该被park </span></div><div class="line">       <span class="keyword">int</span> ws = pred.waitStatus;</div><div class="line">       <span class="keyword">if</span> (ws == Node.SIGNAL) <span class="comment">//前驱节点是signal状态, park当前线程</span></div><div class="line">           <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">       <span class="keyword">if</span> (ws &gt; <span class="number">0</span>) &#123; <span class="comment">//前驱结点已取消</span></div><div class="line">           <span class="keyword">do</span> &#123;</div><div class="line">               node.prev = pred = pred.prev;</div><div class="line">           &#125; <span class="keyword">while</span> (pred.waitStatus &gt; <span class="number">0</span>); <span class="comment">//前驱结点已取消，向前遍历直到找到一个非取消结点，同时将取消节点的前后节点相连</span></div><div class="line">           pred.next = node;</div><div class="line">       &#125; <span class="keyword">else</span> &#123;</div><div class="line">           compareAndSetWaitStatus(pred, ws, Node.SIGNAL); <span class="comment">//将当前节点设置为signal状态，表明后继节点需要unpark</span></div><div class="line">       &#125;</div><div class="line">       <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">   &#125;</div><div class="line">   </div><div class="line">   <span class="function"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">parkAndCheckInterrupt</span><span class="params">()</span> </span>&#123; <span class="comment">//park当前线程，并返回当前中断状态</span></div><div class="line">       LockSupport.park(<span class="keyword">this</span>); <span class="comment">//挂起当前线程，当中断或者被其他线程unpark这个线程则返回，不区分park和unpark的先后</span></div><div class="line">       <span class="keyword">return</span> Thread.interrupted(); <span class="comment">//清空并返回中断状态，保证后续仍然可以park，返回的值将决定完成获取后是否需要恢复中断状态</span></div><div class="line">   &#125;</div></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">cancelAcquire</span><span class="params">(Node node)</span> </span>&#123; <span class="comment">//取消当前节点</span></div><div class="line">    <span class="keyword">if</span> (node == <span class="keyword">null</span>)</div><div class="line">        <span class="keyword">return</span>;</div><div class="line">    node.thread = <span class="keyword">null</span>;</div><div class="line">    Node pred = node.prev;</div><div class="line">    <span class="keyword">while</span> (pred.waitStatus &gt; <span class="number">0</span>) <span class="comment">//跳过已经取消的前驱节点</span></div><div class="line">        node.prev = pred = pred.prev;</div><div class="line">        </div><div class="line">    Node predNext = pred.next; <span class="comment">//predNext是需要移除的结点</span></div><div class="line">    node.waitStatus = Node.CANCELLED; <span class="comment">//无条件设置节点状态为取消</span></div><div class="line">    <span class="keyword">if</span> (node == tail &amp;&amp; compareAndSetTail(node, pred)) &#123; <span class="comment">//如果处于链尾，直接移除，再修复前驱的连接关系</span></div><div class="line">        compareAndSetNext(pred, predNext, <span class="keyword">null</span>);</div><div class="line">    &#125; <span class="keyword">else</span> &#123;<span class="comment">//node有后继。用前驱的next指针指向他，这样他会得到正确的signal信号，否则唤醒他来传播信号。</span></div><div class="line">        <span class="keyword">int</span> ws;</div><div class="line">        <span class="keyword">if</span> (pred != head &amp;&amp;</div><div class="line">            ((ws = pred.waitStatus) == Node.SIGNAL ||</div><div class="line">             (ws &lt;= <span class="number">0</span> &amp;&amp; compareAndSetWaitStatus(pred, ws, Node.SIGNAL))) &amp;&amp;</div><div class="line">            pred.thread != <span class="keyword">null</span>) &#123; <span class="comment">//如果true，说明node有一个需要signal的前驱，让这个前驱指向node的后继，完整节点的链接关系</span></div><div class="line">            Node next = node.next;</div><div class="line">            <span class="keyword">if</span> (next != <span class="keyword">null</span> &amp;&amp; next.waitStatus &lt;= <span class="number">0</span>) <span class="comment">//node有后继</span></div><div class="line">                compareAndSetNext(pred, predNext, next);</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            unparkSuccessor(node); <span class="comment">//在执行到上面一句将waitStatus置CANCELLED之前，锁被释放，该node线程被唤醒，则释放锁线程的unparkSuccessor不能起到预期作用，所以这里需要调用unparkSuccessor.即使此时持有锁的线程没有释放锁也不会有严重后果，被unpark的线程在获取锁失败后会继续park</span></div><div class="line">        &#125;</div><div class="line">        node.next = node; <span class="comment">// help GC</span></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="void-acquireInterruptibly-int-arg-throws-InterruptedException"><a href="#void-acquireInterruptibly-int-arg-throws-InterruptedException" class="headerlink" title="* void acquireInterruptibly(int arg) throws InterruptedException"></a>* void acquireInterruptibly(int arg) throws InterruptedException</h3><p>以独占模式获取对象，如果被中断则中止，抛出InterruptedException。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">acquireInterruptibly</span><span class="params">(<span class="keyword">int</span> arg)</span></span></div><div class="line">           <span class="keyword">throws</span> InterruptedException &#123;</div><div class="line">       <span class="keyword">if</span> (Thread.interrupted()) <span class="comment">//被中断则清空中断状态并抛出异常</span></div><div class="line">           <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();</div><div class="line">       <span class="keyword">if</span> (!tryAcquire(arg))</div><div class="line">           doAcquireInterruptibly(arg);</div><div class="line">   &#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doAcquireInterruptibly</span><span class="params">(<span class="keyword">int</span> arg)</span></span></div><div class="line">       <span class="keyword">throws</span> InterruptedException &#123; <span class="comment">//和acquireQueued的区别就是被中断则不再重新获取，直接结束</span></div><div class="line">       <span class="keyword">final</span> Node node = addWaiter(Node.EXCLUSIVE); <span class="comment">//将节点添加进同步队列</span></div><div class="line">       <span class="keyword">boolean</span> failed = <span class="keyword">true</span>;</div><div class="line">       <span class="keyword">try</span> &#123;</div><div class="line">           <span class="keyword">for</span> (;;) &#123;</div><div class="line">               <span class="keyword">final</span> Node p = node.predecessor();</div><div class="line">               <span class="keyword">if</span> (p == head &amp;&amp; tryAcquire(arg)) &#123;</div><div class="line">                   setHead(node);</div><div class="line">                   p.next = <span class="keyword">null</span>; <span class="comment">// help GC</span></div><div class="line">                   failed = <span class="keyword">false</span>;</div><div class="line">                   <span class="keyword">return</span>;</div><div class="line">               &#125;</div><div class="line">               <span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</div><div class="line">                   parkAndCheckInterrupt()) <span class="comment">//park当前线程，直到被其他线程unpark，如果被中断唤醒，则返回true</span></div><div class="line">                   <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();</div><div class="line">           &#125;</div><div class="line">       &#125; <span class="keyword">finally</span> &#123;</div><div class="line">           <span class="keyword">if</span> (failed)</div><div class="line">               cancelAcquire(node);</div><div class="line">       &#125;</div><div class="line">   &#125;</div></pre></td></tr></table></figure>
<h3 id="boolean-tryAcquireNanos-int-arg-long-nanosTimeout-throws-InterruptedException"><a href="#boolean-tryAcquireNanos-int-arg-long-nanosTimeout-throws-InterruptedException" class="headerlink" title="* boolean tryAcquireNanos(int arg,long nanosTimeout) throws InterruptedException"></a>* boolean tryAcquireNanos(int arg,long nanosTimeout) throws InterruptedException</h3><p>试图以独占模式获取对象，如果被中断则中止，抛出InterruptedException，如果到了给定超时时间，则会返回失败。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryAcquireNanos</span><span class="params">(<span class="keyword">int</span> arg, <span class="keyword">long</span> nanosTimeout)</span></span></div><div class="line">           <span class="keyword">throws</span> InterruptedException &#123;</div><div class="line">       <span class="keyword">if</span> (Thread.interrupted()) <span class="comment">//被中断则清空中断状态并抛出异常</span></div><div class="line">           <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();</div><div class="line">       <span class="keyword">return</span> tryAcquire(arg) ||</div><div class="line">           doAcquireNanos(arg, nanosTimeout);</div><div class="line">   &#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">doAcquireNanos</span><span class="params">(<span class="keyword">int</span> arg, <span class="keyword">long</span> nanosTimeout)</span> <span class="comment">//doAcquireInterruptibly</span></span></div><div class="line">       <span class="keyword">throws</span> InterruptedException &#123;</div><div class="line">       <span class="keyword">long</span> lastTime = System.nanoTime(); <span class="comment">//获取当前时间</span></div><div class="line">       <span class="keyword">final</span> Node node = addWaiter(Node.EXCLUSIVE); <span class="comment">//将节点添加进同步队列</span></div><div class="line">       <span class="keyword">boolean</span> failed = <span class="keyword">true</span>;</div><div class="line">       <span class="keyword">try</span> &#123;</div><div class="line">           <span class="keyword">for</span> (;;) &#123;</div><div class="line">               <span class="keyword">final</span> Node p = node.predecessor();</div><div class="line">               <span class="keyword">if</span> (p == head &amp;&amp; tryAcquire(arg)) &#123;</div><div class="line">                   setHead(node);</div><div class="line">                   p.next = <span class="keyword">null</span>; <span class="comment">// help GC</span></div><div class="line">                   failed = <span class="keyword">false</span>;</div><div class="line">                   <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">               &#125;</div><div class="line">               <span class="keyword">if</span> (nanosTimeout &lt;= <span class="number">0</span>) <span class="comment">//如果没有获取到，且超时时间小于等于0则返回失败</span></div><div class="line">                   <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">               <span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</div><div class="line">                   nanosTimeout &gt; spinForTimeoutThreshold) <span class="comment">//spinForTimeoutThreshold为1000纳秒，当休眠时间小于等于1000纳秒时，由于非常短的超时等待无法做到十分精确，也会带来额外的线程上下文切换，所以这里直接进入快速的自旋。否则park线程</span></div><div class="line">                   LockSupport.parkNanos(<span class="keyword">this</span>, nanosTimeout);</div><div class="line">               <span class="keyword">long</span> now = System.nanoTime(); <span class="comment">//获取unpark后的时间</span></div><div class="line">               nanosTimeout -= now - lastTime; <span class="comment">//将超时时间减去获取锁以及线程park的时间，得到之后还需要park的时间。</span></div><div class="line">               lastTime = now;</div><div class="line">               <span class="keyword">if</span> (Thread.interrupted()) <span class="comment">//被中断则清空中断状态并抛出异常</span></div><div class="line">                   <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();</div><div class="line">           &#125;</div><div class="line">       &#125; <span class="keyword">finally</span> &#123;</div><div class="line">           <span class="keyword">if</span> (failed)</div><div class="line">               cancelAcquire(node);</div><div class="line">       &#125;</div><div class="line">   &#125;</div></pre></td></tr></table></figure>
<h3 id="boolean-release-int-arg"><a href="#boolean-release-int-arg" class="headerlink" title="* boolean release(int arg)"></a>* boolean release(int arg)</h3><p>以独占模式释放对象。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">release</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</div><div class="line">       <span class="keyword">if</span> (tryRelease(arg)) &#123; <span class="comment">//如果修改status状态释放锁成功</span></div><div class="line">           Node h = head; <span class="comment">//head是初始化的节点或代表当前占有锁的线程，所以要unparkhead的有效后继节点</span></div><div class="line">           <span class="keyword">if</span> (h != <span class="keyword">null</span> &amp;&amp; h.waitStatus != <span class="number">0</span>)</div><div class="line">               unparkSuccessor(h); <span class="comment">//unparkhead节点的有效后继节点</span></div><div class="line">           <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">       &#125;</div><div class="line">       <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">   &#125;</div><div class="line">   </div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">unparkSuccessor</span><span class="params">(Node node)</span> </span>&#123;</div><div class="line">       <span class="keyword">int</span> ws = node.waitStatus;</div><div class="line">       <span class="keyword">if</span> (ws &lt; <span class="number">0</span>) <span class="comment">//重置头节点的状态为0</span></div><div class="line">           compareAndSetWaitStatus(node, ws, <span class="number">0</span>);</div><div class="line">           </div><div class="line">       Node s = node.next;</div><div class="line">       <span class="keyword">if</span> (s == <span class="keyword">null</span> || s.waitStatus &gt; <span class="number">0</span>) &#123; <span class="comment">//后继节点是null或者已取消</span></div><div class="line">           s = <span class="keyword">null</span>;</div><div class="line">           <span class="keyword">for</span> (Node t = tail; t != <span class="keyword">null</span> &amp;&amp; t != node; t = t.prev) <span class="comment">//节点的next字段用于优化，当next链接没有时，仍然需要从tail节点向前遍历检查，获取队列最前面的有效节点作为需要unpark的节点</span></div><div class="line">               <span class="keyword">if</span> (t.waitStatus &lt;= <span class="number">0</span>)</div><div class="line">                   s = t;</div><div class="line">       &#125;</div><div class="line">       <span class="keyword">if</span> (s != <span class="keyword">null</span>)</div><div class="line">           LockSupport.unpark(s.thread);<span class="comment">//unpark同步队列最前面的有效节点</span></div><div class="line">   &#125;</div></pre></td></tr></table></figure>
<h2 id="共享模式的获取和释放"><a href="#共享模式的获取和释放" class="headerlink" title="共享模式的获取和释放"></a>共享模式的获取和释放</h2><h3 id="void-acquireShared-int-arg"><a href="#void-acquireShared-int-arg" class="headerlink" title="* void acquireShared(int arg)"></a>* void acquireShared(int arg)</h3><p>以共享模式获取对象，忽略中断。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">acquireShared</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</div><div class="line">       <span class="keyword">if</span> (tryAcquireShared(arg) &lt; <span class="number">0</span>) <span class="comment">//tryAcquireShared大于等于0则共享锁获取成功</span></div><div class="line">           doAcquireShared(arg);</div><div class="line">   &#125;</div><div class="line">   </div><div class="line">   <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doAcquireShared</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123; <span class="comment">//和独占式的acquireQueued方法区别就是获取成功的节点会继续unpark后继节点，将共享状态向后传播</span></div><div class="line">       <span class="keyword">final</span> Node node = addWaiter(Node.SHARED); <span class="comment">//添加到同步队列</span></div><div class="line">       <span class="keyword">boolean</span> failed = <span class="keyword">true</span>;</div><div class="line">       <span class="keyword">try</span> &#123;</div><div class="line">           <span class="keyword">boolean</span> interrupted = <span class="keyword">false</span>;</div><div class="line">           <span class="keyword">for</span> (;;) &#123;</div><div class="line">               <span class="keyword">final</span> Node p = node.predecessor();</div><div class="line">               <span class="keyword">if</span> (p == head) &#123; <span class="comment">//节点的前驱是head</span></div><div class="line">                   <span class="keyword">int</span> r = tryAcquireShared(arg);</div><div class="line">                   <span class="keyword">if</span> (r &gt;= <span class="number">0</span>) &#123; <span class="comment">//获取锁成功</span></div><div class="line">                       setHeadAndPropagate(node, r); <span class="comment">//设置头节点并unpark后继节点，传播共享状态</span></div><div class="line">                       p.next = <span class="keyword">null</span>; <span class="comment">// help GC</span></div><div class="line">                       <span class="keyword">if</span> (interrupted)</div><div class="line">                           selfInterrupt();</div><div class="line">                       failed = <span class="keyword">false</span>;</div><div class="line">                       <span class="keyword">return</span>;</div><div class="line">                   &#125;</div><div class="line">               &#125;</div><div class="line">               <span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</div><div class="line">                   parkAndCheckInterrupt())</div><div class="line">                   interrupted = <span class="keyword">true</span>;</div><div class="line">           &#125;</div><div class="line">       &#125; <span class="keyword">finally</span> &#123;</div><div class="line">           <span class="keyword">if</span> (failed)</div><div class="line">               cancelAcquire(node);</div><div class="line">       &#125;</div><div class="line">   &#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">setHeadAndPropagate</span><span class="params">(Node node, <span class="keyword">int</span> propagate)</span> </span>&#123; <span class="comment">//设置头节点并unpark后继节点，传播共享状态。参数propagate代表当前还有可以获取的锁数量</span></div><div class="line">       Node h = head; </div><div class="line">       setHead(node); <span class="comment">//设置当前节点为head节点</span></div><div class="line">       <span class="keyword">if</span> (propagate &gt; <span class="number">0</span> || h == <span class="keyword">null</span> || h.waitStatus &lt; <span class="number">0</span>) &#123;<span class="comment">//当前有资源可以获取，或当前节点可以唤醒后继节点 </span></div><div class="line">           Node s = node.next;</div><div class="line">           <span class="keyword">if</span> (s == <span class="keyword">null</span> || s.isShared()) <span class="comment">//后继节点是共享的则unpark后继节点</span></div><div class="line">               doReleaseShared(); <span class="comment">//unpark后继节点</span></div><div class="line">       &#125;</div><div class="line">   &#125;</div></pre></td></tr></table></figure>
<h3 id="void-acquireSharedInterruptibly-int-arg-throws-InterruptedException"><a href="#void-acquireSharedInterruptibly-int-arg-throws-InterruptedException" class="headerlink" title="* void acquireSharedInterruptibly(int arg) throws InterruptedException"></a>* void acquireSharedInterruptibly(int arg) throws InterruptedException</h3><p>以共享模式获取对象，如果被中断则中止，抛出InterruptedException。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">acquireSharedInterruptibly</span><span class="params">(<span class="keyword">int</span> arg)</span></span></div><div class="line">           <span class="keyword">throws</span> InterruptedException &#123;</div><div class="line">       <span class="keyword">if</span> (Thread.interrupted())</div><div class="line">           <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();</div><div class="line">       <span class="keyword">if</span> (tryAcquireShared(arg) &lt; <span class="number">0</span>)</div><div class="line">           doAcquireSharedInterruptibly(arg);</div><div class="line">   &#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doAcquireSharedInterruptibly</span><span class="params">(<span class="keyword">int</span> arg)</span></span></div><div class="line">       <span class="keyword">throws</span> InterruptedException &#123;</div><div class="line">       <span class="keyword">final</span> Node node = addWaiter(Node.SHARED);</div><div class="line">       <span class="keyword">boolean</span> failed = <span class="keyword">true</span>;</div><div class="line">       <span class="keyword">try</span> &#123;</div><div class="line">           <span class="keyword">for</span> (;;) &#123;</div><div class="line">               <span class="keyword">final</span> Node p = node.predecessor();</div><div class="line">               <span class="keyword">if</span> (p == head) &#123;</div><div class="line">                   <span class="keyword">int</span> r = tryAcquireShared(arg);</div><div class="line">                   <span class="keyword">if</span> (r &gt;= <span class="number">0</span>) &#123;</div><div class="line">                       setHeadAndPropagate(node, r);</div><div class="line">                       p.next = <span class="keyword">null</span>; <span class="comment">// help GC</span></div><div class="line">                       failed = <span class="keyword">false</span>;</div><div class="line">                       <span class="keyword">return</span>;</div><div class="line">                   &#125;</div><div class="line">               &#125;</div><div class="line">               <span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</div><div class="line">                   parkAndCheckInterrupt())</div><div class="line">                   <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();</div><div class="line">           &#125;</div><div class="line">       &#125; <span class="keyword">finally</span> &#123;</div><div class="line">           <span class="keyword">if</span> (failed)</div><div class="line">               cancelAcquire(node);</div><div class="line">       &#125;</div><div class="line">   &#125;</div></pre></td></tr></table></figure>
<h3 id="boolean-tryAcquireSharedNanos-int-arg-long-nanosTimeout-throws-InterruptedException"><a href="#boolean-tryAcquireSharedNanos-int-arg-long-nanosTimeout-throws-InterruptedException" class="headerlink" title="* boolean tryAcquireSharedNanos(int arg,long nanosTimeout) throws InterruptedException"></a>* boolean tryAcquireSharedNanos(int arg,long nanosTimeout) throws InterruptedException</h3><p>试图以共享模式获取对象，如果被中断则中止，抛出InterruptedException，如果到了给定超时时间，则会返回失败。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryAcquireSharedNanos</span><span class="params">(<span class="keyword">int</span> arg, <span class="keyword">long</span> nanosTimeout)</span></span></div><div class="line">           <span class="keyword">throws</span> InterruptedException &#123;</div><div class="line">       <span class="keyword">if</span> (Thread.interrupted())</div><div class="line">           <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();</div><div class="line">       <span class="keyword">return</span> tryAcquireShared(arg) &gt;= <span class="number">0</span> ||</div><div class="line">           doAcquireSharedNanos(arg, nanosTimeout);</div><div class="line">   &#125;</div><div class="line">   </div><div class="line">   <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">doAcquireSharedNanos</span><span class="params">(<span class="keyword">int</span> arg, <span class="keyword">long</span> nanosTimeout)</span></span></div><div class="line">       <span class="keyword">throws</span> InterruptedException &#123;</div><div class="line"></div><div class="line">       <span class="keyword">long</span> lastTime = System.nanoTime();</div><div class="line">       <span class="keyword">final</span> Node node = addWaiter(Node.SHARED);</div><div class="line">       <span class="keyword">boolean</span> failed = <span class="keyword">true</span>;</div><div class="line">       <span class="keyword">try</span> &#123;</div><div class="line">           <span class="keyword">for</span> (;;) &#123;</div><div class="line">               <span class="keyword">final</span> Node p = node.predecessor();</div><div class="line">               <span class="keyword">if</span> (p == head) &#123;</div><div class="line">                   <span class="keyword">int</span> r = tryAcquireShared(arg);</div><div class="line">                   <span class="keyword">if</span> (r &gt;= <span class="number">0</span>) &#123;</div><div class="line">                       setHeadAndPropagate(node, r);</div><div class="line">                       p.next = <span class="keyword">null</span>; <span class="comment">// help GC</span></div><div class="line">                       failed = <span class="keyword">false</span>;</div><div class="line">                       <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">                   &#125;</div><div class="line">               &#125;</div><div class="line">               <span class="keyword">if</span> (nanosTimeout &lt;= <span class="number">0</span>)</div><div class="line">                   <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">               <span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</div><div class="line">                   nanosTimeout &gt; spinForTimeoutThreshold)</div><div class="line">                   LockSupport.parkNanos(<span class="keyword">this</span>, nanosTimeout);</div><div class="line">               <span class="keyword">long</span> now = System.nanoTime();</div><div class="line">               nanosTimeout -= now - lastTime;</div><div class="line">               lastTime = now;</div><div class="line">               <span class="keyword">if</span> (Thread.interrupted())</div><div class="line">                   <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();</div><div class="line">           &#125;</div><div class="line">       &#125; <span class="keyword">finally</span> &#123;</div><div class="line">           <span class="keyword">if</span> (failed)</div><div class="line">               cancelAcquire(node);</div><div class="line">       &#125;</div><div class="line">   &#125;</div></pre></td></tr></table></figure>
<h3 id="boolean-releaseShared-int-arg"><a href="#boolean-releaseShared-int-arg" class="headerlink" title="* boolean releaseShared(int arg)"></a>* boolean releaseShared(int arg)</h3><p>以共享模式释放对象。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">releaseShared</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</div><div class="line">       <span class="keyword">if</span> (tryReleaseShared(arg)) &#123;</div><div class="line">           doReleaseShared(); <span class="comment">//unpark后继节点，传播共享状态</span></div><div class="line">           <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">       &#125;</div><div class="line">       <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">   &#125;</div><div class="line">   </div><div class="line">   <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doReleaseShared</span><span class="params">()</span> </span>&#123; <span class="comment">//unpark后继节点，传播共享状态</span></div><div class="line">       <span class="keyword">for</span> (;;) &#123;</div><div class="line">           Node h = head;</div><div class="line">           <span class="keyword">if</span> (h != <span class="keyword">null</span> &amp;&amp; h != tail) &#123; <span class="comment">//如果队列中有节点</span></div><div class="line">               <span class="keyword">int</span> ws = h.waitStatus;</div><div class="line">               <span class="keyword">if</span> (ws == Node.SIGNAL) &#123; <span class="comment">//头节点状态是signal，则重置状态为0，并unpark后继节点</span></div><div class="line">                   <span class="keyword">if</span> (!compareAndSetWaitStatus(h, Node.SIGNAL, <span class="number">0</span>))</div><div class="line">                       <span class="keyword">continue</span>;            <span class="comment">// loop to recheck cases</span></div><div class="line">                   unparkSuccessor(h);</div><div class="line">               &#125;</div><div class="line">               <span class="keyword">else</span> <span class="keyword">if</span> (ws == <span class="number">0</span> &amp;&amp;</div><div class="line">                        !compareAndSetWaitStatus(h, <span class="number">0</span>, Node.PROPAGATE)) ／／如果状态为<span class="number">0</span>，则将<span class="number">0</span>设置为PROPAGATE状态</div><div class="line">                   <span class="keyword">continue</span>;                <span class="comment">// loop on failed CAS</span></div><div class="line">           &#125;</div><div class="line">           <span class="keyword">if</span> (h == head)                   <span class="comment">// loop if head changed</span></div><div class="line">               <span class="keyword">break</span>;</div><div class="line">       &#125;</div><div class="line">   &#125;</div></pre></td></tr></table></figure>
</div><script type="text/javascript" src="/js/share.js?v=0.0.0" async></script><a class="article-share-link" data-url="http://blogxin.cn/2016/09/28/JUC-AbstractQueuedSynchronizer-AQS-源码分析/" data-id="ckav7rntx00190cr0h1sitku6" data-qrcode="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAN4AAADeCAAAAAB3DOFrAAACrUlEQVR42u3awW7rMAwEwP7/T+cB7y5nSYpJC4xPgdMqGh8keqmfn/h6/b9Od54/n77NxznduXbh4eHhtaZ+uk4Tfb6fTOt5zPzBneaMh4eHt817ntbzENXFPd9I8g3meB8PDw/vq7y8Xu09prysx8PDw/u7vOdJ5w8FDw8P7y/ykjCiWub2ItpkI1nJWvDw8PBi3mRR/tbnxf4eHh4e3qCrPokYqtFwbz5vZouHh4e3wOtFCdVjAT1S9bhV4Y0BDw8Pb4FXXawnj+lW+HscAQ8PD2+BV1hkg7+ZbAbJL1bLdDw8PLwN3iSS2DhGkGwAhRIcDw8Pb4GXbAb5/YRR3bWqY5b3Ojw8PLyYN6/Bewt675GVwwg8PDy8ZV7e+E/C3GbAerXxhoeHh7fByxtLpynm31b/q3fUAA8PD++TvHxR7m0V1UMGt7YQPDw8vA1eNUJ9ta7JL/biYDw8PLwNXlSSFsvuSUmdP4ioBMfDw8Nb5hVe71uHq+Zlffn4Ah4eHt4Cr3pwKm8+TQ5Ozf8XDw8Pb5uXF6nV0rlXQOchSH4kCw8PD+8WrzrFyWaQkyaNMTw8PLxtXhIK5A2tanBwN87Aw8PD+yQvj1CrbbDJ45gEu82EGA8PD6/Fm2wV1TgjCUHmxxfw8PDw7vLmgWy5Zo9bXHkc/CZrwcPDw1vmVYvjZDOoRgy9jQcPDw/vM7x8Qe+FFL3PvRj3zaPEw8PDu8R7Fa+kgJ60vpKR88IaDw8Pb4PXW3Z7LbFeoHAr5MXDw8O7y8tf/icN/nyJzxtphUNXeHh4eAu8PL1IkFVMr9lWSFnw8PDwvsTLX/vz+n0yQhSa4OHh4f0CXn4g4NaWkIzwJozAw8PDW+DlYcS8VZaP3DvWgIeHh7fNm5zYSiLXeURbDXPLFx4eHl7K+wdysiIWEPuGUgAAAABJRU5ErkJggg==">分享</a><div class="tags"><a href="/tags/Java/">Java</a><a href="/tags/并发/">并发</a><a href="/tags/锁/">锁</a><a href="/tags/源码/">源码</a></div><div class="post-nav"><a class="pre" href="/2016/10/08/JUC-Semaphore-源码分析/">JUC - Semaphore 源码分析</a><a class="next" href="/2015/12/02/FullGC-frequently/">线上FullGC频繁问题的排查过程及解决方案</a></div><div id="container"></div><link rel="stylesheet" type="text/css" href="//unpkg.com/gitalk/dist/gitalk.css?v=0.0.0"><script type="text/javascript" src="//cdn.bootcss.com/blueimp-md5/2.10.0/js/md5.js?v=0.0.0"></script><script type="text/javascript" src="//unpkg.com/gitalk/dist/gitalk.min.js?v=0.0.0"></script><script>var gitalk = new Gitalk({
  clientID: '530c0141e83989b1dc02',
  clientSecret: '89e61ba0adc9b0c630bcc2641c791bfd7ef9faea',
  repo: 'kris-liu.github.io',
  owner: 'kris-liu',
  admin: ['kris-liu'],
  id: md5(location.pathname),
  distractionFreeMode: false
})
gitalk.render('container')
</script></div></div></div><div class="pure-u-1-4 hidden_mid_and_down"><div id="sidebar"><div class="widget"><form class="search-form" action="//www.google.com/search" method="get" accept-charset="utf-8" target="_blank"><input type="text" name="q" maxlength="20" placeholder="Search"/><input type="hidden" name="sitesearch" value="http://blogxin.cn"/></form></div><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"> 分类</i></div><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/Concurrent/">Concurrent</a><span class="category-list-count">8</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Git/">Git</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/IO-NIO/">IO&NIO</a><span class="category-list-count">6</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Java/">Java</a><span class="category-list-count">5</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/MQ/">MQ</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Netty/">Netty</a><span class="category-list-count">6</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Spring/">Spring</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Tomcat/">Tomcat</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Tools/">Tools</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/架构/">架构</a><span class="category-list-count">14</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/线上问题/">线上问题</a><span class="category-list-count">4</span></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-star-o"> 标签</i></div><div class="tagcloud"><a href="/tags/内存泄漏/" style="font-size: 15px;">内存泄漏</a> <a href="/tags/Spring/" style="font-size: 15px;">Spring</a> <a href="/tags/架构/" style="font-size: 15px;">架构</a> <a href="/tags/Transaction/" style="font-size: 15px;">Transaction</a> <a href="/tags/JVM/" style="font-size: 15px;">JVM</a> <a href="/tags/GC/" style="font-size: 15px;">GC</a> <a href="/tags/线上问题/" style="font-size: 15px;">线上问题</a> <a href="/tags/Git/" style="font-size: 15px;">Git</a> <a href="/tags/IO/" style="font-size: 15px;">IO</a> <a href="/tags/NIO/" style="font-size: 15px;">NIO</a> <a href="/tags/Java/" style="font-size: 15px;">Java</a> <a href="/tags/并发/" style="font-size: 15px;">并发</a> <a href="/tags/锁/" style="font-size: 15px;">锁</a> <a href="/tags/源码/" style="font-size: 15px;">源码</a> <a href="/tags/异步/" style="font-size: 15px;">异步</a> <a href="/tags/读写锁/" style="font-size: 15px;">读写锁</a> <a href="/tags/缓存/" style="font-size: 15px;">缓存</a> <a href="/tags/线程池/" style="font-size: 15px;">线程池</a> <a href="/tags/BIO/" style="font-size: 15px;">BIO</a> <a href="/tags/AIO/" style="font-size: 15px;">AIO</a> <a href="/tags/JMM/" style="font-size: 15px;">JMM</a> <a href="/tags/内存模型/" style="font-size: 15px;">内存模型</a> <a href="/tags/Netty/" style="font-size: 15px;">Netty</a> <a href="/tags/Tomcat/" style="font-size: 15px;">Tomcat</a> <a href="/tags/MQ/" style="font-size: 15px;">MQ</a> <a href="/tags/Tools/" style="font-size: 15px;">Tools</a> <a href="/tags/SpringBoot/" style="font-size: 15px;">SpringBoot</a> <a href="/tags/MyBatis/" style="font-size: 15px;">MyBatis</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-file-o"> 最近文章</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2020/05/31/Distributed-Transaction-9/">从零开始写一个分布式事务框架(九)-RoadMap</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/05/24/Distributed-Transaction-8/">从零开始写一个分布式事务框架(八)-使用教程</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/05/24/Distributed-Transaction-7/">从零开始写一个分布式事务框架(七)-SpringBootStarter</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/05/24/Distributed-Transaction-6/">从零开始写一个分布式事务框架(六)-事务协调器</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/05/16/Distributed-Transaction-5/">从零开始写一个分布式事务框架(五)-资源管理器</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/05/09/Distributed-Transaction-4/">从零开始写一个分布式事务框架(四)-事务管理器</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/05/05/Distributed-Transaction-3/">从零开始写一个分布式事务框架(三)-事务记录</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/05/04/Distributed-Transaction-2/">从零开始写一个分布式事务框架(二)-架构</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/02/16/Distributed-Transaction-1/">从零开始写一个分布式事务框架(一)</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/06/01/sharding-db/">基于Spring+MyBatis实现一个分库分表、读写分离功能的工具库</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-external-link"> 友情链接</i></div><ul></ul><a href="http://blog.csdn.net/xx_ytm" title="我的CSDN博客" target="_blank">我的CSDN博客</a></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">Copyright © 2020 <a href="/." rel="nofollow">佑祺's Blog.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/tufu9441/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/pagecho"> Cho.</a></div></div></div><a class="show" id="rocket" href="#top"></a><script type="text/javascript" src="/js/totop.js?v=0.0.0" async></script><script type="text/javascript" src="//cdn.bootcss.com/fancybox/3.3.5/jquery.fancybox.min.js" async></script><script type="text/javascript" src="/js/fancybox.js?v=0.0.0" async></script><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/fancybox/3.3.5/jquery.fancybox.min.css"><script type="text/javascript" src="/js/codeblock-resizer.js?v=0.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=0.0.0"></script></div></body></html>