<!DOCTYPE html><html lang="zh-CN"><head><meta name="google-site-verification" content="DVfrDhwMEodDoWVy6nv0PCpolWhBlGBSaO9hiU2r61E"><meta name="google-site-verification" content="40TgWkMJTOetJQqAMZwk5nD5rtVQRjk5i2pe6FGka5g"><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content="Liu Xin's Blog"><title>JUC - ThreadPoolExecutor 源码分析 | Liu Xin's Blog</title><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/normalize/5.0.0/normalize.min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/0.6.0/pure-min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/0.6.0/grids-responsive-min.css"><link rel="stylesheet" type="text/css" href="/css/style.css?v=0.0.1"><link rel="stylesheet" href="//cdn.bootcss.com/font-awesome/4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="//cdn.bootcss.com/jquery/3.1.1/jquery.min.js"></script><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">JUC - ThreadPoolExecutor 源码分析</h1><a id="logo" href="/.">Liu Xin's Blog</a><p class="description">Whatever you do, you have to keep moving forward!</p></div><div id="nav-menu"><a href="/." class="current"><i class="fa fa-home"> 首页</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a><a href="/about/"><i class="fa fa-user"> 关于</i></a><a href="/atom.xml"><i class="fa fa-rss"> 订阅</i></a></div></div><div id="layout" class="pure-g"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">JUC - ThreadPoolExecutor 源码分析</h1><div class="post-meta">Nov 27, 2016<span> | </span><span class="category"><a href="/categories/Concurrent/">Concurrent</a></span><script src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js" async></script><span id="busuanzi_container_page_pv"> | <span id="busuanzi_value_page_pv"></span><span> Hits</span></span></div><a data-thread-key="2016/11/27/JUC-ThreadPoolExecutor-源码分析/" href="/2016/11/27/JUC-ThreadPoolExecutor-源码分析/#comments" class="ds-thread-count"></a><div class="clear"><div id="toc" class="toc-article"><div class="toc-title">文章目录</div><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#线程池"><span class="toc-number">1.</span> <span class="toc-text">线程池</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#初始化参数"><span class="toc-number">1.1.</span> <span class="toc-text">初始化参数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#线程池执行任务流程"><span class="toc-number">1.2.</span> <span class="toc-text">线程池执行任务流程</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#源码分析"><span class="toc-number">2.</span> <span class="toc-text">源码分析</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#ThreadPoolExecutor类继承关系"><span class="toc-number">2.1.</span> <span class="toc-text">ThreadPoolExecutor类继承关系</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ThreadPoolExecutor核心属性"><span class="toc-number">2.2.</span> <span class="toc-text">ThreadPoolExecutor核心属性</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ThreadPoolExecutor的工作线程Worker"><span class="toc-number">2.3.</span> <span class="toc-text">ThreadPoolExecutor的工作线程Worker</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ThreadPoolExecutor核心方法execute-方法源码分析"><span class="toc-number">2.4.</span> <span class="toc-text">ThreadPoolExecutor核心方法execute()方法源码分析</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#public-void-execute-Runnable-command"><span class="toc-number">2.4.1.</span> <span class="toc-text">public void    execute(Runnable command)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#public-lt-T-gt-List-lt-Future-lt-T-gt-gt-invokeAll-Collection-lt-extends-Callable-lt-T-gt-gt-tasks-long-timeout-TimeUnit-unit-throws-InterruptedException"><span class="toc-number">2.4.2.</span> <span class="toc-text">public <T> List<Future<T>> invokeAll(Collection<? extends Callable<T>> tasks, long timeout, TimeUnit unit) throws InterruptedException</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ThreadPoolExecutor关闭"><span class="toc-number">2.5.</span> <span class="toc-text">ThreadPoolExecutor关闭</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#public-void-shutdown"><span class="toc-number">2.5.1.</span> <span class="toc-text">public void shutdown()</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#public-List-lt-Runnable-gt-shutdownNow"><span class="toc-number">2.5.2.</span> <span class="toc-text">public List<Runnable> shutdownNow()</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ThreadPoolExecutor扩展点"><span class="toc-number">2.6.</span> <span class="toc-text">ThreadPoolExecutor扩展点</span></a></li></ol></li></ol></div></div><div class="post-content"><p>ThreadPoolExecutor，Java线程池。使用线程池可以降低资源消耗，通过重复利用已创建的线程降低线程创建和销毁造成的消耗；可以提高响应速度，当任务到达时，任务可以不需要的等到线程创建就能立即执行；可以提高线程的可管理性，防止无限制的创建线程，消耗系统资源。</p>
<p>下面首先通过初始化参数介绍一下线程池：</p>
<a id="more"></a>
<h1 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h1><h2 id="初始化参数"><a href="#初始化参数" class="headerlink" title="初始化参数"></a>初始化参数</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="title">ThreadPoolExecutor</span><span class="params">(<span class="keyword">int</span> corePoolSize,</span></span></div><div class="line">                          <span class="keyword">int</span> maximumPoolSize,</div><div class="line">                          <span class="keyword">long</span> keepAliveTime,</div><div class="line">                          TimeUnit unit,</div><div class="line">                          BlockingQueue&lt;Runnable&gt; workQueue,</div><div class="line">                          ThreadFactory threadFactory,</div><div class="line">                          RejectedExecutionHandler handler) &#123;</div><div class="line">    <span class="keyword">if</span> (corePoolSize &lt; <span class="number">0</span> ||</div><div class="line">        maximumPoolSize &lt;= <span class="number">0</span> ||</div><div class="line">        maximumPoolSize &lt; corePoolSize ||</div><div class="line">        keepAliveTime &lt; <span class="number">0</span>)</div><div class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</div><div class="line">    <span class="keyword">if</span> (workQueue == <span class="keyword">null</span> || threadFactory == <span class="keyword">null</span> || handler == <span class="keyword">null</span>)</div><div class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</div><div class="line">    <span class="keyword">this</span>.corePoolSize = corePoolSize;</div><div class="line">    <span class="keyword">this</span>.maximumPoolSize = maximumPoolSize;</div><div class="line">    <span class="keyword">this</span>.workQueue = workQueue;</div><div class="line">    <span class="keyword">this</span>.keepAliveTime = unit.toNanos(keepAliveTime);</div><div class="line">    <span class="keyword">this</span>.threadFactory = threadFactory;</div><div class="line">    <span class="keyword">this</span>.handler = handler;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li><p>corePoolSize：线程池的基本大小，核心线程数，当提交一个任务到线程池时，如果线程数小于核心线程数时，即使现有的线程空闲，线程池也会优先创建新线程来处理任务，而不是直接交给现有的线程处理，等到需要执行的任务数大于线程池基本大小时就不再创建。如果调用了线程池的prestartAllCoreThreads方法，线程池会提前创建并启动所有基本线程。核心线程会一直存活，即使没有任务需要处理，除非调用了allowCoreThreadTimeOut方法则允许核心线程超时终止。</p>
</li>
<li><p>maximumPoolSize：线程池最大大小，当线程数大于或等于核心线程，当任务队列已满，且已创建的线程数小于最大线程数，线程池会创建新的工作线程，直到线程数量达到maxPoolSize。如果线程数已等于maxPoolSize，且任务队列已满，则已超出线程池的处理能力，线程池会拒绝处理任务而抛出异常。</p>
</li>
<li><p>workQueue：任务队列，用于保存等待执行的任务的阻塞队列，当达到corePoolSize的时候，就向该等待队列放入线程信息 。可以选择以下几个阻塞队列。</p>
<ul>
<li><p>ArrayBlockingQueue：是一个基于数组结构的有界阻塞队列，此队列按 FIFO（先进先出）原则对元素进行排序。</p>
</li>
<li><p>LinkedBlockingQueue：一个基于链表结构的阻塞队列，此队列按FIFO （先进先出） 排序元素，吞吐量通常要高于ArrayBlockingQueue。静态工厂方法Executors.newFixedThreadPool()使用了这个队列。</p>
</li>
<li><p>SynchronousQueue：一个不存储元素的阻塞队列。每个插入操作必须等到另一个线程调用移除操作，否则插入操作一直处于阻塞状态，吞吐量通常要高于LinkedBlockingQueue，静态工厂方法Executors.newCachedThreadPool使用了这个队列。</p>
</li>
<li><p>PriorityBlockingQueue：一个具有优先级得无限阻塞队列。</p>
</li>
</ul>
</li>
<li><p>keepAliveTime：线程活动保持时间，线程池的工作线程空闲后，保持存活的时间。所以如果任务很多，并且每个任务执行的时间比较短，可以调大这个时间，提高线程的利用率。</p>
</li>
<li><p>unit：线程活动保持时间keepAliveTime的单位，可选的单位有天（DAYS），小时（HOURS），分钟（MINUTES），毫秒(MILLISECONDS)，微秒(MICROSECONDS, 千分之一毫秒)和毫微秒(NANOSECONDS, 千分之一微秒)。</p>
</li>
<li><p>threadFactory：用于设置创建线程的工厂，可以通过线程工厂给每个创建出来的线程设置更有意义的名字，Debug和定位问题时非常又帮助。</p>
</li>
<li><p>handler：饱和策略，当队列和线程池都满了，说明线程池处于饱和状态，那么必须采取一种策略处理提交的新任务。以下是JDK提供的策略。</p>
<ul>
<li><p>AbortPolicy：表示无法处理新任务时抛出异常</p>
</li>
<li><p>CallerRunsPolicy：使用调用者所在线程来运行任务。</p>
</li>
<li><p>DiscardOldestPolicy：丢弃队列里当前第一个任务，并重新提交当前任务。</p>
</li>
<li><p>DiscardPolicy：不处理。</p>
</li>
</ul>
<p>当然也可以根据应用场景需要来实现RejectedExecutionHandler接口自定义策略。如监控，记录日志或持久化不能处理的任务。</p>
</li>
</ul>
<h2 id="线程池执行任务流程"><a href="#线程池执行任务流程" class="headerlink" title="线程池执行任务流程"></a>线程池执行任务流程</h2><p>线程池按以下行为执行任务：</p>
<ol>
<li><p>当线程数小于核心线程数时，创建线程并执行任务。</p>
</li>
<li><p>当线程数大于等于核心线程数，且任务队列未满时，将任务放入任务队列。</p>
</li>
<li><p>当线程数大于等于核心线程数，且任务队列已满。若线程数小于最大线程数，创建线程并执行任务；若线程数到达最大线程数，则抛出异常，拒绝任务。</p>
</li>
</ol>
<h1 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h1><h2 id="ThreadPoolExecutor类继承关系"><a href="#ThreadPoolExecutor类继承关系" class="headerlink" title="ThreadPoolExecutor类继承关系"></a>ThreadPoolExecutor类继承关系</h2><p>ThreadPoolExecutor类继承自AbstractExecutorService抽象类，AbstractExecutorService抽象类实现了ExecutorService接口，ExecutorService接口继承自Executor接口。核心执行方法是Executor接口的execute()方法，ExecutorService扩展了submit()，invokeAll()，invokeAny()方法，并在AbstractExecutorService中做了具体实现，这三个方法最终都会调用Executor接口的execute()方法，execute()方法在ThreadPoolExecutor中做了具体实现。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Executor</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">execute</span><span class="params">(Runnable command)</span></span>;<span class="comment">//在将来某个时间执行给定任务。</span></div><div class="line">    </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ExecutorService</span> <span class="keyword">extends</span> <span class="title">Executor</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">shutdown</span><span class="params">()</span></span>;<span class="comment">//启动一次顺序关闭，执行以前提交的任务，但不接受新任务。</span></div><div class="line"></div><div class="line">    <span class="function">List&lt;Runnable&gt; <span class="title">shutdownNow</span><span class="params">()</span></span>;<span class="comment">//试图停止所有正在执行的活动任务，暂停处理正在等待的任务，并返回等待执行的任务列表。</span></div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isShutdown</span><span class="params">()</span></span>;<span class="comment">//如果此执行程序已关闭，则返回 true。</span></div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isTerminated</span><span class="params">()</span></span>;<span class="comment">//如果关闭后所有任务都已完成，则返回 true。</span></div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">awaitTermination</span><span class="params">(<span class="keyword">long</span> timeout, TimeUnit unit)</span> <span class="keyword">throws</span> InterruptedException</span>;<span class="comment">//请求关闭、发生超时或者当前线程中断，无论哪一个首先发生之后，都将导致阻塞，直到所有任务完成执行。</span></div><div class="line"></div><div class="line">    &lt;T&gt; <span class="function">Future&lt;T&gt; <span class="title">submit</span><span class="params">(Callable&lt;T&gt; task)</span></span>;<span class="comment">//提交一个返回值的任务用于执行，返回一个表示任务的未决结果的 Future。</span></div><div class="line"></div><div class="line">    &lt;T&gt; <span class="function">Future&lt;T&gt; <span class="title">submit</span><span class="params">(Runnable task, T result)</span></span>;<span class="comment">//提交一个 Runnable 任务用于执行，并返回一个表示该任务的 Future。</span></div><div class="line"></div><div class="line">    Future&lt;?&gt; submit(Runnable task);<span class="comment">//提交一个 Runnable 任务用于执行，并返回一个表示该任务的 Future。</span></div><div class="line"></div><div class="line">    &lt;T&gt; List&lt;Future&lt;T&gt;&gt; invokeAll(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks) <span class="keyword">throws</span> InterruptedException;<span class="comment">//执行给定的任务，当所有任务完成时，返回保持任务状态和结果的 Future 列表。</span></div><div class="line"></div><div class="line"></div><div class="line">    &lt;T&gt; List&lt;Future&lt;T&gt;&gt; invokeAll(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks, <span class="keyword">long</span> timeout, TimeUnit unit) <span class="keyword">throws</span> InterruptedException;<span class="comment">//执行给定的任务，当所有任务完成或超时期满时（无论哪个首先发生），返回保持任务状态和结果的 Future 列表。</span></div><div class="line"></div><div class="line">    &lt;T&gt; <span class="function">T <span class="title">invokeAny</span><span class="params">(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks)</span> <span class="keyword">throws</span> InterruptedException, ExecutionException</span>;<span class="comment">//执行给定的任务，如果某个任务已成功完成（也就是未抛出异常），则返回其结果。</span></div><div class="line"></div><div class="line">    &lt;T&gt; <span class="function">T <span class="title">invokeAny</span><span class="params">(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks, <span class="keyword">long</span> timeout, TimeUnit unit)</span> <span class="keyword">throws</span> InterruptedException, ExecutionException, TimeoutException</span>;<span class="comment">//执行给定的任务，如果在给定的超时期满前某个任务已成功完成（也就是未抛出异常），则返回其结果。</span></div><div class="line">    </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="ThreadPoolExecutor核心属性"><a href="#ThreadPoolExecutor核心属性" class="headerlink" title="ThreadPoolExecutor核心属性"></a>ThreadPoolExecutor核心属性</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div></pre></td><td class="code"><pre><div class="line">   <span class="keyword">private</span> <span class="keyword">final</span> AtomicInteger ctl = <span class="keyword">new</span> AtomicInteger(ctlOf(RUNNING, <span class="number">0</span>));<span class="comment">//原子的int类型计数器，高三位代表线程池状态，低29位代表线程数量</span></div><div class="line">   <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> COUNT_BITS = Integer.SIZE - <span class="number">3</span>;<span class="comment">//代表线程数量，29位</span></div><div class="line">   <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> CAPACITY   = (<span class="number">1</span> &lt;&lt; COUNT_BITS) - <span class="number">1</span>;<span class="comment">//允许的最大线程数</span></div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line">    * 线程池状态的转换</div><div class="line">    * RUNNING -&gt; SHUTDOWN：调用shutdown()，隐含在finalize()方法也会调用shutdown()</div><div class="line">    * (RUNNING or SHUTDOWN) -&gt; STOP：调用shutdownnow()</div><div class="line">    * SHUTDOWN -&gt; TIDYING：当队列和池都是空的</div><div class="line">    * STOP -&gt; TIDYING：当线程池是空的</div><div class="line">    * TIDYING -&gt; TERMINATED：当terminated()方法完成了</div><div class="line"> **/</div><div class="line"><span class="comment">//线程池状态</span></div><div class="line">   <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> RUNNING    = -<span class="number">1</span> &lt;&lt; COUNT_BITS;<span class="comment">//ctl高3位值是RUNNING的代表线程池状态是运行：接受新的任务和进程队列任务</span></div><div class="line">   <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> SHUTDOWN   =  <span class="number">0</span> &lt;&lt; COUNT_BITS;<span class="comment">//ctl高3位值是SHUTDOWN的代表线程池状态是关闭：不接受新的任务，但处理队列中的任务</span></div><div class="line">   <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> STOP       =  <span class="number">1</span> &lt;&lt; COUNT_BITS;<span class="comment">//ctl高3位值是STOP的代表线程池状态是停止：不接受新的任务，不处理队列中的任务，并中断正在进行的任务</span></div><div class="line">   <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TIDYING    =  <span class="number">2</span> &lt;&lt; COUNT_BITS;<span class="comment">//ctl高3位值是TIDYING的代表线程池状态是整理中：所有任务已经终止，工作线程数是零，过渡到状态为整理中将运行terminated()方法</span></div><div class="line">   <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TERMINATED =  <span class="number">3</span> &lt;&lt; COUNT_BITS;<span class="comment">//ctl高3位值是TERMINATED的代表线程池状态是终止：terminated()已完成</span></div><div class="line"></div><div class="line">   <span class="keyword">private</span> <span class="keyword">final</span> BlockingQueue&lt;Runnable&gt; workQueue;<span class="comment">//任务队列</span></div><div class="line"></div><div class="line">   <span class="keyword">private</span> <span class="keyword">final</span> ReentrantLock mainLock = <span class="keyword">new</span> ReentrantLock();<span class="comment">//线程池主锁，操作线程池工作线程集合，线程池状态等都需要先获得该锁</span></div><div class="line"></div><div class="line">   <span class="keyword">private</span> <span class="keyword">final</span> HashSet&lt;Worker&gt; workers = <span class="keyword">new</span> HashSet&lt;Worker&gt;();<span class="comment">//工作线程Worker集合，用于处理提交的任务或任务队列中的任务</span></div><div class="line"></div><div class="line">   <span class="keyword">private</span> <span class="keyword">int</span> largestPoolSize;<span class="comment">//记录线程池有过的最大线程数，操作时需要获取主锁，通过锁保证了可见性和原子性</span></div><div class="line"></div><div class="line">   <span class="keyword">private</span> <span class="keyword">long</span> completedTaskCount;<span class="comment">//记录线程池完成的任务数，工作线程退出时累加上去，操作时需要获取主锁，通过锁保证了可见性和原子性</span></div><div class="line"></div><div class="line">   <span class="keyword">private</span> <span class="keyword">volatile</span> ThreadFactory threadFactory;<span class="comment">//线程创建工厂，用来创建线程</span></div><div class="line"></div><div class="line">   <span class="keyword">private</span> <span class="keyword">volatile</span> RejectedExecutionHandler handler;<span class="comment">//饱和策略</span></div><div class="line"></div><div class="line">   <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">long</span> keepAliveTime;<span class="comment">//线程空闲时的存活时间，单位纳秒</span></div><div class="line"></div><div class="line">   <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">boolean</span> allowCoreThreadTimeOut;<span class="comment">//核心线程是否允许超时终止</span></div><div class="line"></div><div class="line">   <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">int</span> corePoolSize;<span class="comment">//核心线程数量上限</span></div><div class="line"></div><div class="line">   <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">int</span> maximumPoolSize;<span class="comment">//最大线程数量上限</span></div></pre></td></tr></table></figure>
<h2 id="ThreadPoolExecutor的工作线程Worker"><a href="#ThreadPoolExecutor的工作线程Worker" class="headerlink" title="ThreadPoolExecutor的工作线程Worker"></a>ThreadPoolExecutor的工作线程Worker</h2><p>Worker与其说是工作线程，其实是管理工作线程，每个Worker内部的线程在run方法中通过不断的从任务队列中获取任务来不断的处理任务，自身继承自AQS，所以每个Worker自身也是一个锁，保护获取到的任务的执行，在锁状态意味着该Worker正在执行任务。除了创建Worker时提交的任务，其他提交过来的任务都是放入任务队列交给Workers去消费的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div><div class="line">139</div><div class="line">140</div><div class="line">141</div><div class="line">142</div><div class="line">143</div><div class="line">144</div><div class="line">145</div><div class="line">146</div><div class="line">147</div><div class="line">148</div><div class="line">149</div><div class="line">150</div><div class="line">151</div><div class="line">152</div><div class="line">153</div><div class="line">154</div><div class="line">155</div><div class="line">156</div><div class="line">157</div><div class="line">158</div><div class="line">159</div><div class="line">160</div><div class="line">161</div><div class="line">162</div><div class="line">163</div><div class="line">164</div></pre></td><td class="code"><pre><div class="line">   <span class="keyword">private</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Worker</span></span></div><div class="line">       <span class="keyword">extends</span> <span class="title">AbstractQueuedSynchronizer</span></div><div class="line">       <span class="keyword">implements</span> <span class="title">Runnable</span></div><div class="line">   &#123;</div><div class="line">   </div><div class="line">       <span class="keyword">final</span> Thread thread;<span class="comment">//Work管理的线程，final保证构造函数内的操作在构造函数结束后都执行完成，而且对所有线程可见</span></div><div class="line"></div><div class="line">       Runnable firstTask;<span class="comment">//第一个任务</span></div><div class="line"></div><div class="line">       <span class="keyword">volatile</span> <span class="keyword">long</span> completedTasks;<span class="comment">//完成的任务计数</span></div><div class="line"></div><div class="line">       Worker(Runnable firstTask) &#123;</div><div class="line">           setState(-<span class="number">1</span>); <span class="comment">//初始化并防止中断该Worker</span></div><div class="line">           <span class="keyword">this</span>.firstTask = firstTask;<span class="comment">//创建时提交过来的第一个任务，启动线程后将执行</span></div><div class="line">           <span class="keyword">this</span>.thread = getThreadFactory().newThread(<span class="keyword">this</span>);<span class="comment">//通过线程工厂创建线程</span></div><div class="line">       &#125;</div><div class="line"></div><div class="line">       <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;<span class="comment">//运行方法</span></div><div class="line">           runWorker(<span class="keyword">this</span>);</div><div class="line">       &#125;</div><div class="line"></div><div class="line">       <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">isHeldExclusively</span><span class="params">()</span> </span>&#123;<span class="comment">//是否被锁，1代表锁已经被获取，0代表锁已经被释放</span></div><div class="line">           <span class="keyword">return</span> getState() != <span class="number">0</span>;</div><div class="line">       &#125;</div><div class="line"></div><div class="line">       <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">(<span class="keyword">int</span> unused)</span> </span>&#123;<span class="comment">//状态由0到1代表成功获取锁</span></div><div class="line">           <span class="keyword">if</span> (compareAndSetState(<span class="number">0</span>, <span class="number">1</span>)) &#123;</div><div class="line">               setExclusiveOwnerThread(Thread.currentThread());</div><div class="line">               <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">           &#125;</div><div class="line">           <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">       &#125;</div><div class="line"></div><div class="line">       <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">tryRelease</span><span class="params">(<span class="keyword">int</span> unused)</span> </span>&#123;<span class="comment">//状态设置为0代表释放锁</span></div><div class="line">           setExclusiveOwnerThread(<span class="keyword">null</span>);</div><div class="line">           setState(<span class="number">0</span>);</div><div class="line">           <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">       &#125;</div><div class="line"></div><div class="line">       <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span>        </span>&#123; acquire(<span class="number">1</span>); &#125;<span class="comment">//获取</span></div><div class="line">       <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">tryLock</span><span class="params">()</span>  </span>&#123; <span class="keyword">return</span> tryAcquire(<span class="number">1</span>); &#125;<span class="comment">//尝试获取锁</span></div><div class="line">       <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">unlock</span><span class="params">()</span>      </span>&#123; release(<span class="number">1</span>); &#125;<span class="comment">//释放</span></div><div class="line">       <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isLocked</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> isHeldExclusively(); &#125;<span class="comment">//是否被锁</span></div><div class="line"></div><div class="line">       <span class="function"><span class="keyword">void</span> <span class="title">interruptIfStarted</span><span class="params">()</span> </span>&#123;<span class="comment">//如果已经启动则中断该线程</span></div><div class="line">           Thread t;</div><div class="line">           <span class="keyword">if</span> (getState() &gt;= <span class="number">0</span> &amp;&amp; (t = thread) != <span class="keyword">null</span> &amp;&amp; !t.isInterrupted()) &#123;</div><div class="line">               <span class="keyword">try</span> &#123;</div><div class="line">                   t.interrupt();</div><div class="line">               &#125; <span class="keyword">catch</span> (SecurityException ignore) &#123;</div><div class="line">               &#125;</div><div class="line">           &#125;</div><div class="line">       &#125;</div><div class="line">   &#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">runWorker</span><span class="params">(Worker w)</span> </span>&#123;</div><div class="line">       Thread wt = Thread.currentThread();<span class="comment">//获取工作线程的Thread</span></div><div class="line">       Runnable task = w.firstTask;<span class="comment">//将task设置为Worker的第一个任务</span></div><div class="line">       w.firstTask = <span class="keyword">null</span>;<span class="comment">//将Worker中的第一个任务置为null</span></div><div class="line">       w.unlock(); <span class="comment">//无条件释放锁，其实是将锁的状态从初始化的-1设置为0，代表锁已经准备好，可以被获取</span></div><div class="line">       <span class="keyword">boolean</span> completedAbruptly = <span class="keyword">true</span>;<span class="comment">//代表runWorker停止的原因，当completedAbruptly为true时代表worker停止是因为worker执行的外部业务逻辑代码抛出异常引起的。当completedAbruptly为false时代表worker停止是线程池内部工作机制下的正常退出。</span></div><div class="line">       <span class="keyword">try</span> &#123;</div><div class="line">           <span class="keyword">while</span> (task != <span class="keyword">null</span> || (task = getTask()) != <span class="keyword">null</span>) &#123;<span class="comment">//Worker的第一个任务不为null，或者从任务队列中获取到任务，则执行，此处while循环调用getTask方法从任务队列中获取任务，直到超时获取不到，或者线程池终止</span></div><div class="line">               w.lock();<span class="comment">//Worker上锁，保证不被shutDown方法中断</span></div><div class="line"></div><div class="line">               <span class="keyword">if</span> ((runStateAtLeast(ctl.get(), STOP) ||<span class="comment">//线程池被终止或者</span></div><div class="line">                    (Thread.interrupted() &amp;&amp;</div><div class="line">                     runStateAtLeast(ctl.get(), STOP))) &amp;&amp;</div><div class="line">                   !wt.isInterrupted())<span class="comment">//如果线程池已停止且该工作线程还没有被中断则中断该线程；否则清除中断并重新检查是否停止，如果线程被中断过且重新检查时线程池变成了停止状态则重新中断该线程。确保线程池停止时，该工作线程一定被中断了，否则线程一定不能被中断，重新检查确保并发的停止线程池导致的中断被清除</span></div><div class="line">                   wt.interrupt();<span class="comment">//中断该工作线程</span></div><div class="line">               <span class="keyword">try</span> &#123;</div><div class="line">                   beforeExecute(wt, task);<span class="comment">//线程池的扩展点，用于执行每个任务之前执行。</span></div><div class="line">                   Throwable thrown = <span class="keyword">null</span>;</div><div class="line">                   <span class="keyword">try</span> &#123;</div><div class="line">                       task.run();<span class="comment">//调用任务的run方法，这里虽然是个Runnable但是并不需要创建线程来启动，而是直接用线程池中的工作线程调用Runnable的run方法来执行。</span></div><div class="line">                   &#125; <span class="keyword">catch</span> (RuntimeException x) &#123;<span class="comment">//若抛出异常则将异常向上抛出，终止该工作线程并从线程池中移除该Worker，因为此处并非调用方直接调用，所以这个异常会被线程池吃掉，无法跟踪记录该异常栈，我们可以通过扩展点afterExecute来获取抛出的异常，做相应的监控和记录，以便于排查问题。</span></div><div class="line">                       thrown = x; <span class="keyword">throw</span> x;</div><div class="line">                   &#125; <span class="keyword">catch</span> (Error x) &#123;</div><div class="line">                       thrown = x; <span class="keyword">throw</span> x;</div><div class="line">                   &#125; <span class="keyword">catch</span> (Throwable x) &#123;</div><div class="line">                       thrown = x; <span class="keyword">throw</span> <span class="keyword">new</span> Error(x);</div><div class="line">                   &#125; <span class="keyword">finally</span> &#123;</div><div class="line">                       afterExecute(task, thrown);<span class="comment">//线程池的扩展点，用于执行每个任务之后执行。</span></div><div class="line">                   &#125;</div><div class="line">               &#125; <span class="keyword">finally</span> &#123;</div><div class="line">                   task = <span class="keyword">null</span>;<span class="comment">//清空当前task</span></div><div class="line">                   w.completedTasks++;<span class="comment">//该工作线程Worker完成过的任务数量</span></div><div class="line">                   w.unlock();<span class="comment">//释放锁</span></div><div class="line">               &#125;</div><div class="line">           &#125;</div><div class="line">           completedAbruptly = <span class="keyword">false</span>;<span class="comment">//正常退出则设置completedAbruptly为false</span></div><div class="line">       &#125; <span class="keyword">finally</span> &#123;</div><div class="line">           processWorkerExit(w, completedAbruptly);<span class="comment">//处理Worker退出的逻辑</span></div><div class="line">       &#125;</div><div class="line">   &#125;</div><div class="line"></div><div class="line">   <span class="function"><span class="keyword">private</span> Runnable <span class="title">getTask</span><span class="params">()</span> </span>&#123;</div><div class="line">       <span class="keyword">boolean</span> timedOut = <span class="keyword">false</span>; <span class="comment">//代表当前getTask方法上次poll是否超时未能获取到task对象</span></div><div class="line"></div><div class="line">       retry:</div><div class="line">       <span class="keyword">for</span> (;;) &#123;</div><div class="line">           <span class="keyword">int</span> c = ctl.get();</div><div class="line">           <span class="keyword">int</span> rs = runStateOf(c);</div><div class="line"></div><div class="line">           <span class="keyword">if</span> (rs &gt;= SHUTDOWN &amp;&amp; (rs &gt;= STOP || workQueue.isEmpty())) &#123;<span class="comment">//如果线程池状态大于等于STOP，或者是SHUTDOWN且任务队列是空</span></div><div class="line">               decrementWorkerCount();<span class="comment">//减少线程数量</span></div><div class="line">               <span class="keyword">return</span> <span class="keyword">null</span>;<span class="comment">//返回null后，Worker正常退出</span></div><div class="line">           &#125;</div><div class="line"></div><div class="line">           <span class="keyword">boolean</span> timed;      <span class="comment">//是否允许超时退出标记</span></div><div class="line"></div><div class="line">           <span class="keyword">for</span> (;;) &#123;<span class="comment">//此处内层循环是为了设置是否允许超时方式获取任务，并且判断当前是否可以以超时的方式退出</span></div><div class="line">               <span class="keyword">int</span> wc = workerCountOf(c);</div><div class="line">               timed = allowCoreThreadTimeOut || wc &gt; corePoolSize;<span class="comment">//如果核心线程允许超时退出，或者线程数量大于核心线程数，则允许该次获取任务超时退出</span></div><div class="line"></div><div class="line">               <span class="keyword">if</span> (wc &lt;= maximumPoolSize &amp;&amp; ! (timedOut &amp;&amp; timed))</div><div class="line">                   <span class="keyword">break</span>;<span class="comment">//如果当前线程数量小于等于最大线程且并未超时或者当前线程池不允许超时退出，则跳出内层循环</span></div><div class="line">               <span class="keyword">if</span> (compareAndDecrementWorkerCount(c))<span class="comment">//如果当前线程数大于最大线程且当前已经超时为获取到且当前允许超时退出，则减少线程数量，成功后直接返回，失败后重试</span></div><div class="line">                   <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">               c = ctl.get();  <span class="comment">// Re-read ctl</span></div><div class="line">               <span class="keyword">if</span> (runStateOf(c) != rs)<span class="comment">//如果线程池运行状态变化则重新执行外层循环，外层循环会做状态判断，因为CAS失败可能是线程池数量发生变化，则继续内存循环重试</span></div><div class="line">                   <span class="keyword">continue</span> retry;</div><div class="line">           &#125;</div><div class="line"></div><div class="line">           <span class="keyword">try</span> &#123;</div><div class="line">               Runnable r = timed ?</div><div class="line">                   workQueue.poll(keepAliveTime, TimeUnit.NANOSECONDS) :</div><div class="line">                   workQueue.take();<span class="comment">//如果允许超时方式获取，则用poll，否则使用take方法，从任务队列中获取任务</span></div><div class="line">               <span class="keyword">if</span> (r != <span class="keyword">null</span>)<span class="comment">//获取到任务则直接返回该任务，否则设置timedOut标记为已经超时没获取到</span></div><div class="line">                   <span class="keyword">return</span> r;</div><div class="line">               timedOut = <span class="keyword">true</span>;<span class="comment">//设置timedOut标记为已经超时没获取到，然后重新执行外层和内存循环，判断状态和是否超时退出Worker</span></div><div class="line">           &#125; <span class="keyword">catch</span> (InterruptedException retry) &#123;</div><div class="line">               timedOut = <span class="keyword">false</span>;<span class="comment">//被中断不认为超时没获取到，有可能是线程池关闭，重新调用外层循环判断获取。</span></div><div class="line">           &#125;</div><div class="line">       &#125;</div><div class="line">   &#125;</div><div class="line"></div><div class="line">   <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">processWorkerExit</span><span class="params">(Worker w, <span class="keyword">boolean</span> completedAbruptly)</span> </span>&#123;<span class="comment">//completedAbruptly为true代表Worker因为业务异常退出，false代表正常退出</span></div><div class="line">       <span class="keyword">if</span> (completedAbruptly) <span class="comment">//如果Worker是异常退出，则需要在此处将线程池数量减一。正常退出则会在getTask方法减少线程数量</span></div><div class="line">           decrementWorkerCount();</div><div class="line"></div><div class="line">       <span class="keyword">final</span> ReentrantLock mainLock = <span class="keyword">this</span>.mainLock;</div><div class="line">       mainLock.lock();<span class="comment">//获取主锁</span></div><div class="line">       <span class="keyword">try</span> &#123;</div><div class="line">           completedTaskCount += w.completedTasks;<span class="comment">//将退出的线程完成过的任务计数加到线程池总完成任务计数上</span></div><div class="line">           workers.remove(w);<span class="comment">//从工作线程集合中移除该工作线程</span></div><div class="line">       &#125; <span class="keyword">finally</span> &#123;</div><div class="line">           mainLock.unlock();<span class="comment">//释放锁</span></div><div class="line">       &#125;</div><div class="line"></div><div class="line">       tryTerminate();<span class="comment">//尝试终止线程池，因为这个Worker可能是当前线程池中最后一个Worker，tryTerminate方法在所有可能终止当前线程的地方被调用</span></div><div class="line"></div><div class="line">       <span class="keyword">int</span> c = ctl.get();</div><div class="line">       <span class="keyword">if</span> (runStateLessThan(c, STOP)) &#123;<span class="comment">//如果线程池没有停止</span></div><div class="line">           <span class="keyword">if</span> (!completedAbruptly) &#123;<span class="comment">//如果Worker是正常退出</span></div><div class="line">               <span class="keyword">int</span> min = allowCoreThreadTimeOut ? <span class="number">0</span> : corePoolSize;<span class="comment">//如果允许核心线程超时退出，则线程池最小线程数可以为0，否则最小线程数为corePoolSize</span></div><div class="line">               <span class="keyword">if</span> (min == <span class="number">0</span> &amp;&amp; ! workQueue.isEmpty())<span class="comment">//如果最小线程为0且任务队列不为空，则至少保证池中有一个线程可以处理任务队列中的任务</span></div><div class="line">                   min = <span class="number">1</span>;</div><div class="line">               <span class="keyword">if</span> (workerCountOf(c) &gt;= min)<span class="comment">//如果线程池中的线程数大于等于最小线程，则什么都不做，否则创建工作线程。此处为了工作线程正常退出时，保证池中至少存有核心线程数量的线程</span></div><div class="line">                   <span class="keyword">return</span>;</div><div class="line">           &#125;</div><div class="line">           addWorker(<span class="keyword">null</span>, <span class="keyword">false</span>);<span class="comment">//创建一个工作线程。正常退出时是为了保证池中至少存有核心线程数量的线程；异常退出则直接重新补充一个工作线程。</span></div><div class="line">       &#125;</div><div class="line">   &#125;</div></pre></td></tr></table></figure>
<h2 id="ThreadPoolExecutor核心方法execute-方法源码分析"><a href="#ThreadPoolExecutor核心方法execute-方法源码分析" class="headerlink" title="ThreadPoolExecutor核心方法execute()方法源码分析"></a>ThreadPoolExecutor核心方法execute()方法源码分析</h2><h3 id="public-void-execute-Runnable-command"><a href="#public-void-execute-Runnable-command" class="headerlink" title="public void    execute(Runnable command)"></a>public void    execute(Runnable command)</h3><p>在将来某个时间执行给定任务。该方法直接返回不等待任务执行完成，异步处理任务。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(Runnable command)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (command == <span class="keyword">null</span>)</div><div class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</div><div class="line">    <span class="keyword">int</span> c = ctl.get();</div><div class="line">    <span class="keyword">if</span> (workerCountOf(c) &lt; corePoolSize) &#123;<span class="comment">//线程数量小于核心线程数量，则直接添加线程并处理任务</span></div><div class="line">        <span class="keyword">if</span> (addWorker(command, <span class="keyword">true</span>))<span class="comment">//添加工作线程并处理任务，添加成功直接返回。</span></div><div class="line">            <span class="keyword">return</span>;</div><div class="line">        c = ctl.get();<span class="comment">//添加失败重新获取线程池状态计数</span></div><div class="line">    &#125;</div><div class="line">    <span class="keyword">if</span> (isRunning(c) &amp;&amp; workQueue.offer(command)) &#123;<span class="comment">//如果线程池处于运行中状态，则添加任务到任务队列中等待工作线程处理</span></div><div class="line">        <span class="keyword">int</span> recheck = ctl.get();</div><div class="line">        <span class="keyword">if</span> (! isRunning(recheck) &amp;&amp; remove(command))<span class="comment">//添加成功重新校验状态，因为在添加到任务队列的时候线程池状态可能发生变化。如果不是运行中，则从任务队列中移除该任务</span></div><div class="line">            reject(command);<span class="comment">//移除成功则调用handler做线程池饱和的相应处理</span></div><div class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (workerCountOf(recheck) == <span class="number">0</span>)<span class="comment">//如果线程池线程数量是0，则添加一个空的非核心工作线程</span></div><div class="line">            addWorker(<span class="keyword">null</span>, <span class="keyword">false</span>);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (!addWorker(command, <span class="keyword">false</span>))<span class="comment">//如果添加队列失败或者不在运行中，说明任务队列已满，则添加非核心线程，添加失败则调用handler做线程池饱和的相应处理</span></div><div class="line">        reject(command);<span class="comment">//调用handler做线程池饱和的相应处理</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">addWorker</span><span class="params">(Runnable firstTask, <span class="keyword">boolean</span> core)</span> </span>&#123;</div><div class="line">    retry:</div><div class="line">    <span class="keyword">for</span> (;;) &#123;</div><div class="line">        <span class="keyword">int</span> c = ctl.get();</div><div class="line">        <span class="keyword">int</span> rs = runStateOf(c);</div><div class="line"></div><div class="line">        <span class="comment">// Check if queue empty only if necessary.</span></div><div class="line">        <span class="keyword">if</span> (rs &gt;= SHUTDOWN &amp;&amp;</div><div class="line">            ! (rs == SHUTDOWN &amp;&amp;</div><div class="line">               firstTask == <span class="keyword">null</span> &amp;&amp;</div><div class="line">               ! workQueue.isEmpty()))<span class="comment">//表示ctl状态为RUNNING状态或者为SHUTDOWN状态且此时任务队列仍有任务未执行完时，可以继续调用addWorker添加工作线程，但不能新建任务，即firstTask参数必须为null.否则这里将返回false,即新建工作线程失败。</span></div><div class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line"></div><div class="line">        <span class="keyword">for</span> (;;) &#123;</div><div class="line">            <span class="keyword">int</span> wc = workerCountOf(c);</div><div class="line">            <span class="keyword">if</span> (wc &gt;= CAPACITY ||</div><div class="line">                wc &gt;= (core ? corePoolSize : maximumPoolSize))<span class="comment">//如果当前线程数量超过最大容许CAPACITY，或者核心线程超出corePoolSize，或者非核心线程超出maximumPoolSize，都返回失败。</span></div><div class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">            <span class="keyword">if</span> (compareAndIncrementWorkerCount(c))<span class="comment">//原子自增一次计数器，自增成功代表线程数量增加，后续将创建线程。成功则直接跳出循环，否则重试直到返回</span></div><div class="line">                <span class="keyword">break</span> retry;<span class="comment">//自增成功则跳出循环</span></div><div class="line">            c = ctl.get();  <span class="comment">// Re-read ctl</span></div><div class="line">            <span class="keyword">if</span> (runStateOf(c) != rs)<span class="comment">//自增失败则重新读取线程状态，如果线程状态和进入时发生变化，则也跳出循环。</span></div><div class="line">                <span class="keyword">continue</span> retry;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">boolean</span> workerStarted = <span class="keyword">false</span>;<span class="comment">//工作线程是否启动</span></div><div class="line">    <span class="keyword">boolean</span> workerAdded = <span class="keyword">false</span>;<span class="comment">//工作线程是否成功添加</span></div><div class="line">    Worker w = <span class="keyword">null</span>;</div><div class="line">    <span class="keyword">try</span> &#123;</div><div class="line">        <span class="keyword">final</span> ReentrantLock mainLock = <span class="keyword">this</span>.mainLock;</div><div class="line">        w = <span class="keyword">new</span> Worker(firstTask);<span class="comment">//创建一个工作线程管理者Worker，里面会初始化一个线程，初始化的时候会附带第一个启动后将要执行的任务</span></div><div class="line">        <span class="keyword">final</span> Thread t = w.thread;<span class="comment">//获取Worker管理的线程</span></div><div class="line">        <span class="keyword">if</span> (t != <span class="keyword">null</span>) &#123;</div><div class="line">            mainLock.lock();<span class="comment">//首先获取主锁</span></div><div class="line">            <span class="keyword">try</span> &#123;</div><div class="line">                <span class="keyword">int</span> c = ctl.get();</div><div class="line">                <span class="keyword">int</span> rs = runStateOf(c);</div><div class="line"></div><div class="line">                <span class="keyword">if</span> (rs &lt; SHUTDOWN ||</div><div class="line">                    (rs == SHUTDOWN &amp;&amp; firstTask == <span class="keyword">null</span>)) &#123;<span class="comment">//校验线程池状态，运行中，或者SHUTDOWN且没有任务（这个时候还新建Worker是为了处理任务队列中可能还存在的任务）</span></div><div class="line">                    <span class="keyword">if</span> (t.isAlive()) <span class="comment">//校验任务没有被提前启动，已经提前启动则抛出异常</span></div><div class="line">                        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalThreadStateException();</div><div class="line">                    workers.add(w);<span class="comment">//添加Worker到工作线程集合</span></div><div class="line">                    <span class="keyword">int</span> s = workers.size();<span class="comment">//获取队列大小，用来记录线程池中出现过的最大线程数</span></div><div class="line">                    <span class="keyword">if</span> (s &gt; largestPoolSize)</div><div class="line">                        largestPoolSize = s;</div><div class="line">                    workerAdded = <span class="keyword">true</span>;<span class="comment">//设置标记为成功添加工作线程</span></div><div class="line">                &#125;</div><div class="line">            &#125; <span class="keyword">finally</span> &#123;</div><div class="line">                mainLock.unlock();<span class="comment">//释放主锁</span></div><div class="line">            &#125;</div><div class="line">            <span class="keyword">if</span> (workerAdded) &#123;<span class="comment">//如果成功添加工作线程则启动线程，并设置标记为启动工作线程成功</span></div><div class="line">                t.start();</div><div class="line">                workerStarted = <span class="keyword">true</span>;<span class="comment">//设置标记为启动工作线程成功，至此为止一个worker正式被添加进入workers数组并且正式开始运转</span></div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125; <span class="keyword">finally</span> &#123;</div><div class="line">        <span class="keyword">if</span> (! workerStarted)</div><div class="line">            addWorkerFailed(w);<span class="comment">//启动失败则移除该工作线程</span></div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> workerStarted;<span class="comment">//创建并添加，并启动工作线程成功才算完全成功。</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="public-lt-T-gt-List-lt-Future-lt-T-gt-gt-invokeAll-Collection-lt-extends-Callable-lt-T-gt-gt-tasks-long-timeout-TimeUnit-unit-throws-InterruptedException"><a href="#public-lt-T-gt-List-lt-Future-lt-T-gt-gt-invokeAll-Collection-lt-extends-Callable-lt-T-gt-gt-tasks-long-timeout-TimeUnit-unit-throws-InterruptedException" class="headerlink" title="public &lt;T&gt; List&lt;Future&lt;T&gt;&gt; invokeAll(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks, long timeout, TimeUnit unit) throws InterruptedException"></a>public &lt;T&gt; List&lt;Future&lt;T&gt;&gt; invokeAll(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks, long timeout, TimeUnit unit) throws InterruptedException</h3><p>执行给定的任务，当所有任务完成或超时期满时（无论哪个首先发生），返回保持任务状态和结果的 Future 列表。返回列表的所有元素的 Future.isDone() 为 true。一旦返回后，即取消尚未完成的任务。注意，可以正常地或通过抛出异常来终止已完成的任务。如果此操作正在进行时修改了给定的 collection，则此方法的结果是不确定的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> &lt;T&gt; List&lt;Future&lt;T&gt;&gt; invokeAll(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks, <span class="keyword">long</span> timeout, TimeUnit unit) <span class="keyword">throws</span> InterruptedException &#123;</div><div class="line">    <span class="keyword">if</span> (tasks == <span class="keyword">null</span> || unit == <span class="keyword">null</span>)</div><div class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</div><div class="line">    <span class="keyword">long</span> nanos = unit.toNanos(timeout);<span class="comment">//总超时时间</span></div><div class="line">    List&lt;Future&lt;T&gt;&gt; futures = <span class="keyword">new</span> ArrayList&lt;Future&lt;T&gt;&gt;(tasks.size());</div><div class="line">    <span class="keyword">boolean</span> done = <span class="keyword">false</span>;</div><div class="line">    <span class="keyword">try</span> &#123;</div><div class="line">        <span class="keyword">for</span> (Callable&lt;T&gt; t : tasks)</div><div class="line">            futures.add(newTaskFor(t));<span class="comment">//将所有任务包装成一个个Future，顺序和tasks中任务顺序一致</span></div><div class="line"></div><div class="line">        <span class="keyword">long</span> lastTime = System.nanoTime();</div><div class="line">        </div><div class="line">        Iterator&lt;Future&lt;T&gt;&gt; it = futures.iterator();</div><div class="line">        <span class="keyword">while</span> (it.hasNext()) &#123;<span class="comment">//执行所有任务</span></div><div class="line">            execute((Runnable)(it.next()));</div><div class="line">            <span class="keyword">long</span> now = System.nanoTime();</div><div class="line">            nanos -= now - lastTime;</div><div class="line">            lastTime = now;</div><div class="line">            <span class="keyword">if</span> (nanos &lt;= <span class="number">0</span>)</div><div class="line">                <span class="keyword">return</span> futures;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">for</span> (Future&lt;T&gt; f : futures) &#123;<span class="comment">//循环获取任务结果，是为了检测是否任务能在nanos纳秒内执行完成。如果有任务超时没有完成，则会在finally中取消所有能够取消的未完成任务</span></div><div class="line">            <span class="keyword">if</span> (!f.isDone()) &#123;</div><div class="line">                <span class="keyword">if</span> (nanos &lt;= <span class="number">0</span>)</div><div class="line">                    <span class="keyword">return</span> futures;</div><div class="line">                <span class="keyword">try</span> &#123;</div><div class="line">                    f.get(nanos, TimeUnit.NANOSECONDS);</div><div class="line">                &#125; <span class="keyword">catch</span> (CancellationException ignore) &#123;</div><div class="line">                &#125; <span class="keyword">catch</span> (ExecutionException ignore) &#123;</div><div class="line">                &#125; <span class="keyword">catch</span> (TimeoutException toe) &#123;</div><div class="line">                    <span class="keyword">return</span> futures;</div><div class="line">                &#125;</div><div class="line">                <span class="keyword">long</span> now = System.nanoTime();</div><div class="line">                nanos -= now - lastTime;</div><div class="line">                lastTime = now;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        done = <span class="keyword">true</span>;<span class="comment">//正常完成所有任务</span></div><div class="line">        <span class="keyword">return</span> futures;</div><div class="line">    &#125; <span class="keyword">finally</span> &#123;</div><div class="line">        <span class="keyword">if</span> (!done)<span class="comment">//如果没有完成则取消所有能够取消的未完成任务，已经完成的任务不会被取消。保证返回的futures集合都能够直接从Future.get()方法立即返回结果（正常或异常结果）。</span></div><div class="line">            <span class="keyword">for</span> (Future&lt;T&gt; f : futures)</div><div class="line">                f.cancel(<span class="keyword">true</span>);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="ThreadPoolExecutor关闭"><a href="#ThreadPoolExecutor关闭" class="headerlink" title="ThreadPoolExecutor关闭"></a>ThreadPoolExecutor关闭</h2><h3 id="public-void-shutdown"><a href="#public-void-shutdown" class="headerlink" title="public void shutdown()"></a>public void shutdown()</h3><p>关闭线程池，仍会处理任务队列中的任务，但是不接受新任务。如果已经关闭，则调用没有其他作用。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">shutdown</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">final</span> ReentrantLock mainLock = <span class="keyword">this</span>.mainLock;</div><div class="line">    mainLock.lock();</div><div class="line">    <span class="keyword">try</span> &#123;</div><div class="line">        checkShutdownAccess();<span class="comment">//校验是否有执行shutdown的权限</span></div><div class="line">        advanceRunState(SHUTDOWN);<span class="comment">//将ctl状态置为SHUTDOWN</span></div><div class="line">        interruptIdleWorkers();<span class="comment">//关闭尚未获得task对象的worker(即还未执行到getTask()方法或者还未得到getTask()返回的worker</span></div><div class="line">        onShutdown(); <span class="comment">//钩子方法，用户可以在这里处理自定义逻辑。</span></div><div class="line">    &#125; <span class="keyword">finally</span> &#123;</div><div class="line">        mainLock.unlock();</div><div class="line">    &#125;</div><div class="line">    tryTerminate();<span class="comment">//尝试终止线程池。</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">interruptIdleWorkers</span><span class="params">()</span> </span>&#123;<span class="comment">//中断空闲的Worker</span></div><div class="line">    interruptIdleWorkers(<span class="keyword">false</span>);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">interruptIdleWorkers</span><span class="params">(<span class="keyword">boolean</span> onlyOne)</span> </span>&#123;</div><div class="line">    <span class="keyword">final</span> ReentrantLock mainLock = <span class="keyword">this</span>.mainLock;</div><div class="line">    mainLock.lock();<span class="comment">//获取主锁</span></div><div class="line">    <span class="keyword">try</span> &#123;</div><div class="line">        <span class="keyword">for</span> (Worker w : workers) &#123;<span class="comment">//遍历所有workers</span></div><div class="line">            Thread t = w.thread;</div><div class="line">            <span class="keyword">if</span> (!t.isInterrupted() &amp;&amp; w.tryLock()) &#123;<span class="comment">//如果当前Worker线程没有被中断，且尝试获取锁成功（代表任务没有在线程执行中）</span></div><div class="line">                <span class="keyword">try</span> &#123;</div><div class="line">                    t.interrupt();<span class="comment">//中断该线程</span></div><div class="line">                &#125; <span class="keyword">catch</span> (SecurityException ignore) &#123;</div><div class="line">                &#125; <span class="keyword">finally</span> &#123;</div><div class="line">                    w.unlock();<span class="comment">//解锁Worker</span></div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">if</span> (onlyOne)<span class="comment">//true代表只中断第一个空闲的Worker</span></div><div class="line">                <span class="keyword">break</span>;</div><div class="line">        &#125;</div><div class="line">    &#125; <span class="keyword">finally</span> &#123;</div><div class="line">        mainLock.unlock();<span class="comment">//解锁主锁</span></div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">tryTerminate</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">for</span> (;;) &#123;</div><div class="line">        <span class="keyword">int</span> c = ctl.get();</div><div class="line">        <span class="keyword">if</span> (isRunning(c) ||</div><div class="line">            runStateAtLeast(c, TIDYING) ||</div><div class="line">            (runStateOf(c) == SHUTDOWN &amp;&amp; ! workQueue.isEmpty()))<span class="comment">//线程池运行中或者已经终止，或者SHUTDOWN且任务队列不为空，直接返回（SHUTDOWN且任务队列不为空时，会在Worker退出时调用tryTerminate方法终止线程池）</span></div><div class="line">            <span class="keyword">return</span>;</div><div class="line">        <span class="keyword">if</span> (workerCountOf(c) != <span class="number">0</span>) &#123; <span class="comment">//工作线程不为0则中断一个工作线程，直接返回。（STOP时，任务正在运行中，运行完成后，会在Worker退出时调用tryTerminate方法终止线程池）</span></div><div class="line">            interruptIdleWorkers(ONLY_ONE);</div><div class="line">            <span class="keyword">return</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="comment">//ctl状态为STOP,或者为SHUTDOWN且任务队列为空，并且工作线程为0，才继续执行</span></div><div class="line"></div><div class="line">        <span class="keyword">final</span> ReentrantLock mainLock = <span class="keyword">this</span>.mainLock;</div><div class="line">        mainLock.lock();<span class="comment">//获取主锁</span></div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            <span class="keyword">if</span> (ctl.compareAndSet(c, ctlOf(TIDYING, <span class="number">0</span>))) &#123;<span class="comment">//将状态设置为TIDYING，执行到这一步意味着工作线程为0，任务队列空，状态为STOP或SHUTDOWN。</span></div><div class="line">                <span class="keyword">try</span> &#123;</div><div class="line">                    terminated();<span class="comment">//线程池扩展点，终止线程池时执行</span></div><div class="line">                &#125; <span class="keyword">finally</span> &#123;</div><div class="line">                    ctl.set(ctlOf(TERMINATED, <span class="number">0</span>));<span class="comment">//执行完terminated后将状态设置为TERMINATED</span></div><div class="line">                    termination.signalAll();<span class="comment">//唤醒等待在awaitTermination方法上的线程，awaitTermination是等待线程池终止的方法，阻塞直到线程池终止或者超时，中断</span></div><div class="line">                &#125;</div><div class="line">                <span class="keyword">return</span>;<span class="comment">//退出，否则将会for循环重试</span></div><div class="line">            &#125;</div><div class="line">        &#125; <span class="keyword">finally</span> &#123;</div><div class="line">            mainLock.unlock();<span class="comment">//获取主锁</span></div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="public-List-lt-Runnable-gt-shutdownNow"><a href="#public-List-lt-Runnable-gt-shutdownNow" class="headerlink" title="public List&lt;Runnable&gt; shutdownNow()"></a>public List<code>&lt;Runnable&gt;</code> shutdownNow()</h3><p>尝试停止所有的活动执行任务、停止任务队列的处理，并返回等待执行的任务列表。并不保证能够停止正在处理的活动执行任务，但是会尽力尝试。 此实现通过 Thread.interrupt() 取消任务，所以无法响应中断的任何任务可能永远无法终止。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> List&lt;Runnable&gt; <span class="title">shutdownNow</span><span class="params">()</span> </span>&#123;</div><div class="line">    List&lt;Runnable&gt; tasks;</div><div class="line">    <span class="keyword">final</span> ReentrantLock mainLock = <span class="keyword">this</span>.mainLock;</div><div class="line">    mainLock.lock();</div><div class="line">    <span class="keyword">try</span> &#123;</div><div class="line">        interruptIdleWorkers();<span class="comment">//关闭尚未获得task对象的</span></div><div class="line"></div><div class="line">        checkShutdownAccess();<span class="comment">//校验是否有执行</span></div><div class="line">        advanceRunState(STOP);<span class="comment">//将ctl状态置为STOP</span></div><div class="line">        interruptWorkers();<span class="comment">//关闭所有启动了的的worker，中断所有worker的线程</span></div><div class="line">        tasks = drainQueue();<span class="comment">//清空任务队列并返回未执行的任务列表</span></div><div class="line">    &#125; <span class="keyword">finally</span> &#123;</div><div class="line">        mainLock.unlock();</div><div class="line">    &#125;</div><div class="line">    tryTerminate();</div><div class="line">    <span class="keyword">return</span> tasks;<span class="comment">//返回未执行的任务列表</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">private</span> List&lt;Runnable&gt; <span class="title">drainQueue</span><span class="params">()</span> </span>&#123;</div><div class="line">    BlockingQueue&lt;Runnable&gt; q = workQueue;</div><div class="line">    List&lt;Runnable&gt; taskList = <span class="keyword">new</span> ArrayList&lt;Runnable&gt;();</div><div class="line">    q.drainTo(taskList);<span class="comment">//将workQueue中的任务转移到taskList返回</span></div><div class="line">    <span class="keyword">if</span> (!q.isEmpty()) &#123;</div><div class="line">        <span class="keyword">for</span> (Runnable r : q.toArray(<span class="keyword">new</span> Runnable[<span class="number">0</span>])) &#123;</div><div class="line">            <span class="keyword">if</span> (q.remove(r))</div><div class="line">                taskList.add(r);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> taskList;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="ThreadPoolExecutor扩展点"><a href="#ThreadPoolExecutor扩展点" class="headerlink" title="ThreadPoolExecutor扩展点"></a>ThreadPoolExecutor扩展点</h2><p>ThreadPoolExecutor提供了几个protected的方法，在任务执行前，执行后，和线程池终止时执行。可以在自定义线程池中自由实现，用来记录和监控线程池的运行情况。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">beforeExecute</span><span class="params">(Thread t, Runnable r)</span> </span>&#123; &#125;<span class="comment">//在执行给定线程中的给定 Runnable 之前调用的方法。</span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">afterExecute</span><span class="params">(Runnable r, Throwable t)</span> </span>&#123; &#125;<span class="comment">//基于完成执行给定 Runnable 所调用的方法。</span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">terminated</span><span class="params">()</span> </span>&#123; &#125;<span class="comment">//当 Executor 已经终止时调用的方法。</span></div></pre></td></tr></table></figure></div><script type="text/javascript" src="/js/share.js?v=0.0.1" async></script><a data-url="http://blogxin.cn/2016/11/27/JUC-ThreadPoolExecutor-源码分析/" data-id="cj0tlv2dt000oz4s6vryc6wwh" class="article-share-link">分享到</a><div class="tags"><a href="/tags/Java/">Java</a><a href="/tags/并发/">并发</a><a href="/tags/源码/">源码</a><a href="/tags/线程池/">线程池</a></div><div class="post-nav"><a href="/2016/11/29/JUC-FutureTask-源码分析/" class="pre">JUC - FutureTask 源码分析</a><a href="/2016/11/18/ThreadLocal-源码分析/" class="next">ThreadLocal 源码分析</a></div><div data-thread-key="2016/11/27/JUC-ThreadPoolExecutor-源码分析/" data-title="JUC - ThreadPoolExecutor 源码分析" data-url="http://blogxin.cn/2016/11/27/JUC-ThreadPoolExecutor-源码分析/" class="ds-share flat"><div class="ds-share-inline"><ul class="ds-share-icons-16"><li data-toggle="ds-share-icons-more"><a href="javascript:void(0);" class="ds-more">分享到：</a></li><li><a href="javascript:void(0);" data-service="weibo" class="ds-weibo">微博</a></li><li><a href="javascript:void(0);" data-service="qzone" class="ds-qzone">QQ空间</a></li><li><a href="javascript:void(0);" data-service="qqt" class="ds-qqt">腾讯微博</a></li><li><a href="javascript:void(0);" data-service="wechat" class="ds-wechat">微信</a></li></ul><div class="ds-share-icons-more"></div></div></div><div data-thread-key="2016/11/27/JUC-ThreadPoolExecutor-源码分析/" data-title="JUC - ThreadPoolExecutor 源码分析" data-url="http://blogxin.cn/2016/11/27/JUC-ThreadPoolExecutor-源码分析/" data-author-key="1" class="ds-thread"></div></div></div></div><div class="pure-u-1 pure-u-md-1-4"><div id="sidebar"><div class="widget"><form action="//www.google.com/search" method="get" accept-charset="utf-8" target="_blank" class="search-form"><input type="text" name="q" maxlength="20" placeholder="Search"/><input type="hidden" name="sitesearch" value="http://blogxin.cn"/></form></div><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"> 分类</i></div><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/Concurrent/">Concurrent</a><span class="category-list-count">8</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Git/">Git</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/IO-NIO/">IO&NIO</a><span class="category-list-count">6</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/JVM/">JVM</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Java/">Java</a><span class="category-list-count">3</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Spring/">Spring</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Tomcat/">Tomcat</a><span class="category-list-count">1</span></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-star-o"> 标签</i></div><div class="tagcloud"><a href="/tags/缓存/" style="font-size: 15px;">缓存</a> <a href="/tags/Git/" style="font-size: 15px;">Git</a> <a href="/tags/NIO/" style="font-size: 15px;">NIO</a> <a href="/tags/Java/" style="font-size: 15px;">Java</a> <a href="/tags/并发/" style="font-size: 15px;">并发</a> <a href="/tags/锁/" style="font-size: 15px;">锁</a> <a href="/tags/源码/" style="font-size: 15px;">源码</a> <a href="/tags/异步/" style="font-size: 15px;">异步</a> <a href="/tags/读写锁/" style="font-size: 15px;">读写锁</a> <a href="/tags/IO/" style="font-size: 15px;">IO</a> <a href="/tags/线程池/" style="font-size: 15px;">线程池</a> <a href="/tags/BIO/" style="font-size: 15px;">BIO</a> <a href="/tags/AIO/" style="font-size: 15px;">AIO</a> <a href="/tags/JVM/" style="font-size: 15px;">JVM</a> <a href="/tags/JMM/" style="font-size: 15px;">JMM</a> <a href="/tags/内存模型/" style="font-size: 15px;">内存模型</a> <a href="/tags/Spring/" style="font-size: 15px;">Spring</a> <a href="/tags/Tomcat/" style="font-size: 15px;">Tomcat</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-file-o"> 最新文章</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2017/01/31/Java-NIO-文件IO-内存映射文件MappedByteBuffer与zerocopy技术/">Java NIO 文件IO-内存映射文件MappedByteBuffer与zerocopy技术</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/01/24/Java-NIO-Selector详解/">Java NIO Selector详解</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/01/18/Java-NIO-Channel详解/">Java NIO Channel详解</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/01/14/Java-NIO-Buffer详解/">Java NIO Buffer详解</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/12/24/I-O-多路复用之select、poll、epoll实现原理及对比总结/">I/O 多路复用之select、poll、epoll实现原理及对比总结</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/12/18/Java-IO模型/">Java IO模型</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/11/29/JUC-FutureTask-源码分析/">JUC - FutureTask 源码分析</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/11/27/JUC-ThreadPoolExecutor-源码分析/">JUC - ThreadPoolExecutor 源码分析</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/11/18/ThreadLocal-源码分析/">ThreadLocal 源码分析</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/11/17/Unsafe-源码分析/">Unsafe 源码分析</a></li></ul></div><div class="widget"><div class="comments-title"><i class="fa fa-comment-o"> 最近评论</i></div><div data-num-items="5" data-show-avatars="0" data-show-time="1" data-show-admin="0" data-excerpt-length="32" data-show-title="1" class="ds-recent-comments"></div></div><div class="widget"><div class="widget-title"><i class="fa fa-external-link"> 友情链接</i></div><ul></ul><a href="http://blog.csdn.net/xx_ytm" title="我的CSDN博客" target="_blank">我的CSDN博客</a></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">© <a href="/." rel="nofollow">Liu Xin's Blog.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/tufu9441/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/pagecho"> Cho.</a></div></div></div><a id="rocket" href="#top" class="show"></a><script type="text/javascript" src="/js/totop.js?v=0.0.1" async></script><script type="text/javascript" src="//cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.pack.js" async></script><script type="text/javascript" src="/js/fancybox.js?v=0.0.1" async></script><link rel="stylesheet" type="text/css" href="/css/jquery.fancybox.css?v=0.0.1"><script>var duoshuoQuery = {short_name:'blogxin'};
(function() {
    var ds = document.createElement('script');
    ds.type = 'text/javascript';ds.async = true;
    ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
    ds.charset = 'UTF-8';
    (document.getElementsByTagName('head')[0]
        || document.getElementsByTagName('body')[0]).appendChild(ds);
})();
</script><script>(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','https://www.google-analytics.com/analytics.js','ga');
ga('create','UA-91282031-1','auto');ga('send','pageview');
</script><script type="text/javascript" src="/js/codeblock-resizer.js?v=0.0.1"></script><script type="text/javascript" src="/js/smartresize.js?v=0.0.1"></script></div></body></html>