<!DOCTYPE html><html lang="zh-CN"><head><meta name="google-site-verification" content="DVfrDhwMEodDoWVy6nv0PCpolWhBlGBSaO9hiU2r61E"><meta name="google-site-verification" content="40TgWkMJTOetJQqAMZwk5nD5rtVQRjk5i2pe6FGka5g"><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content="佑祺's Blog"><title>Java IO模型 | 佑祺's Blog</title><link rel="stylesheet" type="text/css" href="/css/style.css?v=0.0.0"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/normalize/8.0.0/normalize.min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/1.0.0/pure-min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/1.0.0/grids-responsive-min.css"><link rel="stylesheet" href="//cdn.bootcss.com/font-awesome/4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="//cdn.bootcss.com/jquery/3.3.1/jquery.min.js"></script><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"><script>(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','https://www.google-analytics.com/analytics.js','ga');
ga('create','UA-91282031-1','auto');ga('send','pageview');
</script></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">Java IO模型</h1><a id="logo" href="/.">佑祺's Blog</a><p class="description">Whatever you do, you have to keep moving forward!</p></div><div id="nav-menu"><a class="current" href="/."><i class="fa fa-home"> 首页</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a><a href="/about/"><i class="fa fa-user"> 关于</i></a><a href="/atom.xml"><i class="fa fa-rss"> 订阅</i></a></div></div><div class="pure-g" id="layout"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">Java IO模型</h1><div class="post-meta">Dec 18, 2016<span> | </span><span class="category"><a href="/categories/IO-NIO/">IO&amp;NIO</a></span></div><div class="post-content"><p>目前常用的IO通信模型主要有以下四种：</p>
<ul>
<li>阻塞同步I/O（blocking IO）</li>
<li>非阻塞同步I/O（nonblocking IO）</li>
<li>多路复用I/O（IO multiplexing）</li>
<li>异步I/O（asynchronous IO）</li>
</ul>
<p>这些IO模型都是要靠底层操作系统进行支持，应用程序只是提供相应的实现，对操作系统进行调用。本文将介绍这四种IO模型及Java对这四种IO模型的支持。</p>
<a id="more"></a>
<p>对于一次IO访问（以read举例），数据会先被拷贝到操作系统内核的缓冲区中，然后才会从操作系统内核的缓冲区拷贝到应用程序的地址空间。所以说，当一个read操作发生时，它会经历两个阶段：</p>
<ol>
<li><p>等待内核数据就绪。网络I/O的情况就是等待远端数据陆续抵达；磁盘I/O的情况就是等待磁盘数据从磁盘上读取到内核态内存中。</p>
</li>
<li><p>数据从内核拷贝到进程。出于系统安全,用户态的程序没有权限直接读取内核态内存,因此内核负责把内核态内存中的数据拷贝一份到用户态内存中。</p>
</li>
</ol>
<h2 id="阻塞同步I-O（blocking-IO）"><a href="#阻塞同步I-O（blocking-IO）" class="headerlink" title="阻塞同步I/O（blocking IO）"></a>阻塞同步I/O（blocking IO）</h2><p><img src="/2016/12/18/Java-IO模型/blocking-IO.png" alt="blocking-IO"></p>
<p>默认情况下所有的socket都是blocking，一个典型的读操作流程大概是这样：当用户线程调用了recvfrom这个系统调用，kernel就开始了IO的第一个阶段：准备数据（对于网络IO来说，很多时候数据在一开始还没有到达。比如，还没有收到一个完整的UDP包。这个时候kernel就要等待足够的数据到来）。这个过程需要等待，也就是说数据被拷贝到操作系统内核的缓冲区中是需要一个过程的。而在用户线程这边，整个线程会被阻塞（当然，是线程自己选择的阻塞）。当kernel一直等到数据准备好了，它就会将数据从kernel中拷贝到用户内存，然后kernel返回结果，用户线程才解除block的状态，重新运行起来。这意味着应用程序在调用时会一直阻塞，直到系统调用完成为止（数据传输完成或发生错误）。调用应用程序处于一种不再消费 CPU 而只是简单等待响应的状态，因此从处理的角度来看，这是非常有效的。</p>
<p>blocking IO的特点就是在IO执行的两个阶段都被block了。</p>
<h3 id="阻塞同步IO-Java实现"><a href="#阻塞同步IO-Java实现" class="headerlink" title="阻塞同步IO Java实现"></a>阻塞同步IO Java实现</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div></pre></td><td class="code"><pre><div class="line">package com.kris.ioModel;</div><div class="line"></div><div class="line">import org.slf4j.Logger;</div><div class="line">import org.slf4j.LoggerFactory;</div><div class="line"></div><div class="line">import java.io.IOException;</div><div class="line">import java.io.InputStream;</div><div class="line">import java.io.OutputStream;</div><div class="line">import java.net.ServerSocket;</div><div class="line">import java.net.Socket;</div><div class="line"></div><div class="line">/**</div><div class="line"> * 阻塞同步IO Java实现</div><div class="line"> *</div><div class="line"> * @author xin.liu</div><div class="line"> */</div><div class="line">public class SocketServer1 &#123;</div><div class="line"></div><div class="line">    private static final Logger LOGGER = LoggerFactory.getLogger(SocketServer1.class);</div><div class="line"></div><div class="line">    public static void main(String[] args) throws IOException &#123;</div><div class="line">        ServerSocket serverSocket = null;</div><div class="line">        try &#123;</div><div class="line">            serverSocket = new ServerSocket(10001);</div><div class="line">            while (true) &#123;</div><div class="line">                //这里JAVA通过JNI请求操作系统，并一直等待操作系统返回结果（或者出错）</div><div class="line">                Socket socket = serverSocket.accept();</div><div class="line"></div><div class="line">                //下面我们收取信息（这里还是阻塞式的,一直等待，直到有数据可以接受）</div><div class="line">                InputStream in = socket.getInputStream();</div><div class="line">                OutputStream out = socket.getOutputStream();</div><div class="line">                Integer sourcePort = socket.getPort();</div><div class="line">                int maxLen = 2048;</div><div class="line">                byte[] contextBytes = new byte[maxLen];</div><div class="line">                int realLen;</div><div class="line">                StringBuilder message = new StringBuilder();</div><div class="line">                //read的时候，程序也会被阻塞，直到操作系统把网络传来的数据准备好。</div><div class="line">                while ((realLen = in.read(contextBytes, 0, maxLen)) != -1) &#123;</div><div class="line">                    message.append(new String(contextBytes, 0, realLen));</div><div class="line">                    /*</div><div class="line">                     * 我们假设读取到“over”关键字，</div><div class="line">                     * 表示客户端的所有信息在经过若干次传送后，完成</div><div class="line">                     * */</div><div class="line">                    if (message.indexOf(&quot;over&quot;) != -1) &#123;</div><div class="line">                        break;</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line">                //下面打印信息</div><div class="line">                LOGGER.info(&quot;服务器收到来自于端口：&quot; + sourcePort + &quot;的信息：&quot; + message);</div><div class="line"></div><div class="line">                //下面开始发送信息</div><div class="line">                out.write(&quot;回发响应信息！&quot;.getBytes());</div><div class="line"></div><div class="line">                //关闭</div><div class="line">                socket.close();</div><div class="line">            &#125;</div><div class="line">        &#125; catch (Exception e) &#123;</div><div class="line">            LOGGER.error(e.getMessage(), e);</div><div class="line">        &#125; finally &#123;</div><div class="line">            serverSocket.close();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="非阻塞同步I-O（nonblocking-IO）"><a href="#非阻塞同步I-O（nonblocking-IO）" class="headerlink" title="非阻塞同步I/O（nonblocking IO）"></a>非阻塞同步I/O（nonblocking IO）</h2><p><img src="/2016/12/18/Java-IO模型/nonblocking-IO.png" alt="nonblocking-IO"></p>
<p>可以通过设置socket使其变为non-blocking。当对一个non-blocking socket执行读操作时，流程是这个样子：当用户线程发出read操作时，如果kernel中的数据还没有准备好，那么它并不会block用户线程，而是立刻返回一个error。从用户线程角度讲 ，它发起一个read操作后，并不需要等待，而是马上就得到了一个结果。用户线程判断结果是一个error时，它就知道数据还没有准备好，于是它可以再次发送read操作。一旦kernel中的数据准备好了，并且又再次收到了用户线程的system call，那么它马上就将数据拷贝到了用户内存，然后返回。整个I/O请求的过程中，虽然用户线程每次发起I/O请求后可以立即返回，但是为了等到数据，仍需要不断地轮询、重复请求，消耗了大量的CPU资源。</p>
<p>nonblocking IO的特点是用户线程需要不断的主动询问kernel数据好了没有。</p>
<h3 id="非阻塞同步IO-Java实现"><a href="#非阻塞同步IO-Java实现" class="headerlink" title="非阻塞同步IO Java实现"></a>非阻塞同步IO Java实现</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div></pre></td><td class="code"><pre><div class="line">package com.kris.ioModel;</div><div class="line"></div><div class="line">import org.slf4j.Logger;</div><div class="line">import org.slf4j.LoggerFactory;</div><div class="line"></div><div class="line">import java.io.IOException;</div><div class="line">import java.io.InputStream;</div><div class="line">import java.io.OutputStream;</div><div class="line">import java.net.ServerSocket;</div><div class="line">import java.net.Socket;</div><div class="line">import java.net.SocketTimeoutException;</div><div class="line"></div><div class="line">/**</div><div class="line"> * 非阻塞同步IO Java实现</div><div class="line"> *</div><div class="line"> * @author xin.liu</div><div class="line"> */</div><div class="line">public class SocketServer2 &#123;</div><div class="line"></div><div class="line">    private static final Logger LOGGER = LoggerFactory.getLogger(SocketServer2.class);</div><div class="line"></div><div class="line">    private static final Object xWait = new Object();</div><div class="line"></div><div class="line">    public static void main(String[] args) throws IOException &#123;</div><div class="line">        ServerSocket serverSocket = null;</div><div class="line">        try &#123;</div><div class="line">            serverSocket = new ServerSocket(10002);</div><div class="line">            serverSocket.setSoTimeout(100);</div><div class="line">            while (true) &#123;</div><div class="line">                Socket socket;</div><div class="line">                try &#123;</div><div class="line">                    socket = serverSocket.accept();</div><div class="line">                &#125; catch (SocketTimeoutException e1) &#123;</div><div class="line">                    //===========================================================</div><div class="line">                    //      执行到这里，说明本次accept没有接收到任何TCP连接</div><div class="line">                    //      主线程在这里就可以做一些事情，记为X</div><div class="line">                    //===========================================================</div><div class="line">                    synchronized (xWait) &#123;</div><div class="line">                        LOGGER.info(&quot;这次没有从底层接收到任何TCP连接，等待10毫秒，模拟事件X的处理时间&quot;);</div><div class="line">                        xWait.wait(10);</div><div class="line">                    &#125;</div><div class="line">                    continue;</div><div class="line">                &#125;</div><div class="line"></div><div class="line">                InputStream in = socket.getInputStream();</div><div class="line">                OutputStream out = socket.getOutputStream();</div><div class="line">                Integer sourcePort = socket.getPort();</div><div class="line">                int maxLen = 2048;</div><div class="line">                byte[] contextBytes = new byte[maxLen];</div><div class="line">                int realLen;</div><div class="line">                StringBuilder message = new StringBuilder();</div><div class="line">                //下面我们收取信息（设置成非阻塞方式，这样read信息的时候，又可以做一些其他事情）</div><div class="line">                socket.setSoTimeout(10);</div><div class="line">                BIORead:</div><div class="line">                while (true) &#123;</div><div class="line">                    try &#123;</div><div class="line">                        while ((realLen = in.read(contextBytes, 0, maxLen)) != -1) &#123;</div><div class="line">                            message.append(new String(contextBytes, 0, realLen));</div><div class="line">                            /*</div><div class="line">                             * 我们假设读取到“over”关键字，</div><div class="line">                             * 表示客户端的所有信息在经过若干次传送后，完成</div><div class="line">                             * */</div><div class="line">                            if (message.indexOf(&quot;over&quot;) != -1) &#123;</div><div class="line">                                break BIORead;</div><div class="line">                            &#125;</div><div class="line">                        &#125;</div><div class="line">                    &#125; catch (SocketTimeoutException e2) &#123;</div><div class="line">                        //===========================================================</div><div class="line">                        //      执行到这里，说明本次read没有接收到任何数据流</div><div class="line">                        //      主线程在这里又可以做一些事情，记为Y</div><div class="line">                        //===========================================================</div><div class="line">                        LOGGER.info(&quot;这次没有从底层接收到任务数据报文，等待10毫秒，模拟事件Y的处理时间&quot;);</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line">                //下面打印信息</div><div class="line">                LOGGER.info(&quot;服务器收到来自于端口：&quot; + sourcePort + &quot;的信息：&quot; + message);</div><div class="line"></div><div class="line">                //下面开始发送信息</div><div class="line">                out.write(&quot;回发响应信息！&quot;.getBytes());</div><div class="line"></div><div class="line">                //关闭</div><div class="line">                socket.close();</div><div class="line">            &#125;</div><div class="line">        &#125; catch (Exception e) &#123;</div><div class="line">            LOGGER.error(e.getMessage(), e);</div><div class="line">        &#125; finally &#123;</div><div class="line">            if (serverSocket != null) &#123;</div><div class="line">                serverSocket.close();</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="多路复用I-O（IO-multiplexing）"><a href="#多路复用I-O（IO-multiplexing）" class="headerlink" title="多路复用I/O（IO multiplexing）"></a>多路复用I/O（IO multiplexing）</h2><p><img src="/2016/12/18/Java-IO模型/IO-multiplexing.png" alt="IO-multiplexing"></p>
<p>IO multiplexing就是我们说的select，poll，epoll。IO多路复用模型从流程上和同步阻塞IO的区别不大，主要区别在于操作系统为用户提供了同时轮询多个IO句柄来查看是否有IO事件的接口（如select/epoll），这从根本上允许用户可以使用单个线程来管理多个IO句柄的问题。</p>
<p>当用户线程调用了select，那么整个线程会被block，而同时，kernel会“监视”所有select负责的socket，当任何一个socket中的数据准备好了，select就会返回。这个时候用户线程再调用read操作，直接把数据从kernel拷贝到用户线程。</p>
<p>在IO multiplexing Model中，实际中，对于每一个socket，一般都设置成为non-blocking，但是，如上图所示，整个用户的线程其实是一直被block的。只不过线程是被select这个函数block，而不是被socket IO给block。</p>
<p>I/O多路复用的特点是通过一种机制使一个线程能同时等待多个文件描述符，而这些文件描述符（套接字描述符）其中的任意一个进入就绪状态，select()函数就可以返回。<br>这个图和blocking IO的图其实并没有太大的不同，事实上，还更差一些。因为这里需要使用两个system call (select 和 recvfrom)，而blocking IO只调用了一个system call (recvfrom)。但是，用select的优势在于它可以同时处理多个socket。所以，如果处理的连接数不是很高的话，使用select/epoll的web server不一定比使用multi-threading + blocking IO的web server性能更好，可能延迟还更大。select/epoll的优势并不是对于单个连接能处理得更快，而是在于能处理更多的连接。</p>
<h3 id="多路复用IO-Java实现"><a href="#多路复用IO-Java实现" class="headerlink" title="多路复用IO Java实现"></a>多路复用IO Java实现</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div></pre></td><td class="code"><pre><div class="line">package com.kris.ioModel;</div><div class="line"></div><div class="line">import org.slf4j.Logger;</div><div class="line">import org.slf4j.LoggerFactory;</div><div class="line"></div><div class="line">import java.net.InetSocketAddress;</div><div class="line">import java.nio.ByteBuffer;</div><div class="line">import java.nio.channels.*;</div><div class="line">import java.util.Iterator;</div><div class="line"></div><div class="line">/**</div><div class="line"> * 多路复用IO Java实现</div><div class="line"> *</div><div class="line"> * @author xin.liu</div><div class="line"> */</div><div class="line">public class SocketServer3 &#123;</div><div class="line"></div><div class="line">    private static final Logger LOGGER = LoggerFactory.getLogger(SocketServer3.class);</div><div class="line"></div><div class="line"></div><div class="line">    private static final int PORT_NUMBER = 10003;</div><div class="line">    private static ByteBuffer buffer = ByteBuffer.allocateDirect(1024);</div><div class="line"></div><div class="line">    public static void main(String[] args) throws Exception &#123;</div><div class="line">        int port = PORT_NUMBER;</div><div class="line">        LOGGER.info(&quot;Listening on port &quot; + port);</div><div class="line"></div><div class="line">        Selector selector = Selector.open();</div><div class="line"></div><div class="line">        ServerSocketChannel serverChannel = ServerSocketChannel.open();</div><div class="line">        serverChannel.bind(new InetSocketAddress(port));</div><div class="line">        serverChannel.configureBlocking(false);</div><div class="line">        serverChannel.register(selector, SelectionKey.OP_ACCEPT);</div><div class="line"></div><div class="line">        while (true) &#123;</div><div class="line"></div><div class="line">            //查看是否有注册的IO事件发生</div><div class="line">            int n = selector.select();</div><div class="line">            if (n == 0) &#123;</div><div class="line">                continue; // nothing to do</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            //获取已准备好IO事件的通道集合</div><div class="line">            Iterator it = selector.selectedKeys().iterator();</div><div class="line">            while (it.hasNext()) &#123;</div><div class="line">                SelectionKey key = (SelectionKey) it.next();</div><div class="line"></div><div class="line">                //通道有accept事件发生</div><div class="line">                if (key.isValid() &amp;&amp; key.isAcceptable()) &#123;</div><div class="line">                    ServerSocketChannel server = (ServerSocketChannel) key.channel();</div><div class="line">                    SocketChannel channel = server.accept();</div><div class="line">                    registerChannel(selector, channel, SelectionKey.OP_READ);</div><div class="line">                &#125;</div><div class="line"></div><div class="line">                //通道有read事件发生</div><div class="line">                if (key.isValid() &amp;&amp; key.isReadable()) &#123;</div><div class="line">                    readDataFromSocket(key);</div><div class="line">                &#125;</div><div class="line"></div><div class="line">                //通道有write事件发生</div><div class="line">                if (key.isValid() &amp;&amp; key.isWritable()) &#123;</div><div class="line">                    LOGGER.info(&quot;isWritable = true&quot;);</div><div class="line">                &#125;</div><div class="line"></div><div class="line">                //通道有connect事件发生</div><div class="line">                if (key.isValid() &amp;&amp; key.isConnectable()) &#123;</div><div class="line">                    LOGGER.info(&quot;isConnectable = true&quot;);</div><div class="line">                &#125;</div><div class="line"></div><div class="line">                //移除已处理IO事件的通道</div><div class="line">                it.remove();</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    /**</div><div class="line">     * 处理监听IO操作，将接收到通道注册到Selector上</div><div class="line">     * @param selector</div><div class="line">     * @param channel</div><div class="line">     * @param ops</div><div class="line">     * @throws Exception</div><div class="line">     */</div><div class="line">    private static void registerChannel(Selector selector, SelectableChannel channel, int ops) throws Exception &#123;</div><div class="line">        if (channel == null) &#123;</div><div class="line">            return;</div><div class="line">        &#125;</div><div class="line">        channel.configureBlocking(false);</div><div class="line">        channel.register(selector, ops);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    /**</div><div class="line">     * 处理读取IO操作，将服务端接收到的数据发送回客户端</div><div class="line">     * @param key</div><div class="line">     * @throws Exception</div><div class="line">     */</div><div class="line">    private static void readDataFromSocket(SelectionKey key) throws Exception &#123;</div><div class="line">        SocketChannel socketChannel = (SocketChannel) key.channel();</div><div class="line">        int count;</div><div class="line">        buffer.clear();</div><div class="line"></div><div class="line">        while ((count = socketChannel.read(buffer)) &gt; 0) &#123;</div><div class="line">            buffer.flip();</div><div class="line">            while (buffer.hasRemaining()) &#123;</div><div class="line">                socketChannel.write(buffer);</div><div class="line">            &#125;</div><div class="line">            buffer.clear();</div><div class="line">            key.interestOps(SelectionKey.OP_READ | SelectionKey.OP_WRITE);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        if (count &lt; 0) &#123;</div><div class="line">            // Close channel on EOF, invalidates the key</div><div class="line">            socketChannel.close();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="异步I-O（asynchronous-IO）"><a href="#异步I-O（asynchronous-IO）" class="headerlink" title="异步I/O（asynchronous IO）"></a>异步I/O（asynchronous IO）</h2><p><img src="/2016/12/18/Java-IO模型/asynchronous-IO.png" alt="asynchronous-IO"></p>
<p>用户线程发起read操作之后，立刻就可以开始去做其它的事。而另一方面，从kernel的角度，当它受到一个asynchronous read之后，首先它会立刻返回，所以不会对用户线程产生任何block。然后，kernel会等待数据准备完成，然后将数据拷贝到用户内存，当这一切都完成之后，kernel会给用户线程发送一个signal，告诉它read操作完成了。</p>
<p>采用“订阅-通知”模式：即应用程序向操作系统注册IO监听，然后继续做自己的事情。当操作系统发生IO事件，并且准备好数据后，再主动通知应用程序，触发相应的函数去处理。</p>
<h3 id="异步IO-Java实现"><a href="#异步IO-Java实现" class="headerlink" title="异步IO Java实现"></a>异步IO Java实现</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div><div class="line">139</div><div class="line">140</div><div class="line">141</div><div class="line">142</div><div class="line">143</div><div class="line">144</div><div class="line">145</div><div class="line">146</div><div class="line">147</div><div class="line">148</div><div class="line">149</div><div class="line">150</div><div class="line">151</div><div class="line">152</div><div class="line">153</div><div class="line">154</div><div class="line">155</div><div class="line">156</div><div class="line">157</div><div class="line">158</div><div class="line">159</div><div class="line">160</div><div class="line">161</div><div class="line">162</div><div class="line">163</div><div class="line">164</div><div class="line">165</div><div class="line">166</div><div class="line">167</div><div class="line">168</div><div class="line">169</div><div class="line">170</div><div class="line">171</div><div class="line">172</div><div class="line">173</div><div class="line">174</div></pre></td><td class="code"><pre><div class="line">package com.kris.ioModel;</div><div class="line"></div><div class="line">import org.slf4j.Logger;</div><div class="line">import org.slf4j.LoggerFactory;</div><div class="line"></div><div class="line">import java.io.IOException;</div><div class="line">import java.io.UnsupportedEncodingException;</div><div class="line">import java.net.InetSocketAddress;</div><div class="line">import java.nio.ByteBuffer;</div><div class="line">import java.nio.channels.AsynchronousChannelGroup;</div><div class="line">import java.nio.channels.AsynchronousServerSocketChannel;</div><div class="line">import java.nio.channels.AsynchronousSocketChannel;</div><div class="line">import java.nio.channels.CompletionHandler;</div><div class="line">import java.util.concurrent.ExecutorService;</div><div class="line">import java.util.concurrent.Executors;</div><div class="line"></div><div class="line">/**</div><div class="line"> * 异步IO Java实现</div><div class="line"> *</div><div class="line"> * @author xin.liu</div><div class="line"> */</div><div class="line">public class SocketServer4 &#123;</div><div class="line"></div><div class="line">    private static final Object waitObject = new Object();</div><div class="line"></div><div class="line">    /**</div><div class="line">     * @param args</div><div class="line">     * @throws Exception</div><div class="line">     */</div><div class="line">    public static void main(String[] args) throws Exception &#123;</div><div class="line">        /*</div><div class="line">         * 这个线程池是用来得到操作系统的“IO事件通知”的，不是用来进行“得到IO数据后的业务处理的”。要进行后者的操作，您可以再使用一个池（最好不要混用）</div><div class="line">         */</div><div class="line">        ExecutorService threadPool = Executors.newFixedThreadPool(20);</div><div class="line">        AsynchronousChannelGroup group = AsynchronousChannelGroup.withThreadPool(threadPool);</div><div class="line">        final AsynchronousServerSocketChannel serverSocket = AsynchronousServerSocketChannel.open(group);</div><div class="line"></div><div class="line">        serverSocket.bind(new InetSocketAddress(&quot;0.0.0.0&quot;, 10004));</div><div class="line">        //为AsynchronousServerSocketChannel注册监听，注意只是为AsynchronousServerSocketChannel通道注册监听</div><div class="line">        serverSocket.accept(null, new ServerSocketChannelHandle(serverSocket));</div><div class="line"></div><div class="line">        //等待，只是为了保证守护线程不会退出</div><div class="line">        synchronized (waitObject) &#123;</div><div class="line">            waitObject.wait();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">/**</div><div class="line"> * 这个处理器类，专门用来响应 ServerSocketChannel 的事件。</div><div class="line"> * ServerSocketChannel只有一种事件：接受客户端的连接</div><div class="line"> */</div><div class="line">class ServerSocketChannelHandle implements CompletionHandler&lt;AsynchronousSocketChannel, Void&gt; &#123;</div><div class="line">    /**</div><div class="line">     * 日志</div><div class="line">     */</div><div class="line">    private static final Logger LOGGER = LoggerFactory.getLogger(ServerSocketChannelHandle.class);</div><div class="line"></div><div class="line">    private AsynchronousServerSocketChannel serverSocketChannel;</div><div class="line"></div><div class="line">    /**</div><div class="line">     * @param serverSocketChannel</div><div class="line">     */</div><div class="line">    public ServerSocketChannelHandle(AsynchronousServerSocketChannel serverSocketChannel) &#123;</div><div class="line">        this.serverSocketChannel = serverSocketChannel;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    /**</div><div class="line">     * 注意，我们分别观察 this、socketChannel、attachment三个对象的id。</div><div class="line">     * 来观察不同客户端连接到达时，这三个对象的变化，以说明ServerSocketChannelHandle的监听模式</div><div class="line">     */</div><div class="line">    @Override</div><div class="line">    public void completed(AsynchronousSocketChannel socketChannel, Void attachment) &#123;</div><div class="line">        LOGGER.info(&quot;completed(AsynchronousSocketChannel result, ByteBuffer attachment)&quot;);</div><div class="line">        //每次都要重新注册监听（一次注册，一次响应），但是由于“文件状态标示符”是独享的，所以不需要担心有“漏掉的”事件</div><div class="line">        this.serverSocketChannel.accept(attachment, this);</div><div class="line"></div><div class="line">        //为这个新的socketChannel注册“read”事件，以便操作系统在收到数据并准备好后，主动通知应用程序</div><div class="line">        //在这里，由于我们要将这个客户端多次传输的数据累加起来一起处理，所以我们将一个stringBuffer对象作为一个“附件”依附在这个channel上</div><div class="line">        //</div><div class="line">        ByteBuffer readBuffer = ByteBuffer.allocate(50);</div><div class="line">        socketChannel.read(readBuffer, new StringBuffer(), new SocketChannelReadHandle(socketChannel, readBuffer));</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    public void failed(Throwable exc, Void attachment) &#123;</div><div class="line">        LOGGER.error(&quot;failed(Throwable exc, ByteBuffer attachment)&quot;);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">/**</div><div class="line"> * 负责对每一个socketChannel的数据获取事件进行监听。&lt;p&gt;</div><div class="line"> * &lt;p&gt;</div><div class="line"> * 重要的说明：一个socketChannel都会有一个独立工作的SocketChannelReadHandle对象（CompletionHandler接口的实现），</div><div class="line"> * 其中又都将独享一个“文件状态标示”对象FileDescriptor、</div><div class="line"> * 一个独立的由程序员定义的Buffer缓存（这里我们使用的是ByteBuffer）、</div><div class="line"> * 所以不用担心在服务器端会出现“窜对象”这种情况，因为JAVA AIO框架已经帮您组织好了。&lt;p&gt;</div><div class="line"> * &lt;p&gt;</div><div class="line"> * 但是最重要的，用于生成channel的对象：AsynchronousChannelProvider是单例模式，无论在哪组socketChannel，</div><div class="line"> * 对是一个对象引用（但这没关系，因为您不会直接操作这个AsynchronousChannelProvider对象）。</div><div class="line"> */</div><div class="line">class SocketChannelReadHandle implements CompletionHandler&lt;Integer, StringBuffer&gt; &#123;</div><div class="line"></div><div class="line">    private static final Logger LOGGER = LoggerFactory.getLogger(SocketChannelReadHandle.class);</div><div class="line"></div><div class="line">    private AsynchronousSocketChannel socketChannel;</div><div class="line"></div><div class="line">    /**</div><div class="line">     * 专门用于进行这个通道数据缓存操作的ByteBuffer&lt;br&gt;</div><div class="line">     * 当然，您也可以作为CompletionHandler的attachment形式传入。&lt;br&gt;</div><div class="line">     * 这是，在这段示例代码中，attachment被我们用来记录所有传送过来的StringBuffer了。</div><div class="line">     */</div><div class="line">    private ByteBuffer byteBuffer;</div><div class="line"></div><div class="line">    public SocketChannelReadHandle(AsynchronousSocketChannel socketChannel, ByteBuffer byteBuffer) &#123;</div><div class="line">        this.socketChannel = socketChannel;</div><div class="line">        this.byteBuffer = byteBuffer;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    public void completed(Integer result, StringBuffer historyContext) &#123;</div><div class="line">        //如果条件成立，说明客户端主动终止了TCP套接字，这时服务端终止就可以了</div><div class="line">        if (result == -1) &#123;</div><div class="line">            try &#123;</div><div class="line">                this.socketChannel.close();</div><div class="line">            &#125; catch (IOException e) &#123;</div><div class="line">                LOGGER.error(e.getMessage(), e);</div><div class="line">            &#125;</div><div class="line">            return;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        LOGGER.info(&quot;completed(Integer result, Void attachment) : 然后我们来取出通道中准备好的值&quot;);</div><div class="line">        /*</div><div class="line">         * 实际上，由于我们从Integer result知道了本次channel从操作系统获取数据总长度</div><div class="line">         * 所以实际上，我们不需要切换成“读模式”的，但是为了保证编码的规范性，还是建议进行切换。</div><div class="line">         *</div><div class="line">         * 另外，无论是JAVA AIO框架还是JAVA NIO框架，都会出现“buffer的总容量”小于“当前从操作系统获取到的总数据量”，</div><div class="line">         * 但区别是，JAVA AIO框架中，我们不需要专门考虑处理这样的情况，因为JAVA AIO框架已经帮我们做了处理（做成了多次通知）</div><div class="line">         * */</div><div class="line">        this.byteBuffer.flip();</div><div class="line">        byte[] contexts = new byte[1024];</div><div class="line">        this.byteBuffer.get(contexts, 0, result);</div><div class="line">        this.byteBuffer.clear();</div><div class="line">        try &#123;</div><div class="line">            String nowContent = new String(contexts, 0, result, &quot;UTF-8&quot;);</div><div class="line">            historyContext.append(nowContent);</div><div class="line">            LOGGER.info(&quot;================目前的传输结果：&quot; + historyContext);</div><div class="line">        &#125; catch (UnsupportedEncodingException e) &#123;</div><div class="line">            LOGGER.error(e.getMessage(), e);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        //如果条件成立，说明还没有接收到“结束标记”</div><div class="line">        if (historyContext.indexOf(&quot;over&quot;) == -1) &#123;</div><div class="line">            return;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        LOGGER.info(&quot;=======收到完整信息，开始处理业务=========&quot;);</div><div class="line">        historyContext = new StringBuffer();</div><div class="line"></div><div class="line">        //还要继续监听（一次监听一次通知）</div><div class="line">        this.socketChannel.read(this.byteBuffer, historyContext, this);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    public void failed(Throwable exc, StringBuffer historyContext) &#123;</div><div class="line">        LOGGER.error(&quot;=====发现客户端异常关闭，服务器将关闭TCP通道&quot;);</div><div class="line">        try &#123;</div><div class="line">            this.socketChannel.close();</div><div class="line">        &#125; catch (IOException e) &#123;</div><div class="line">            LOGGER.error(e.getMessage(), e);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="IO模型总结"><a href="#IO模型总结" class="headerlink" title="IO模型总结"></a>IO模型总结</h2><h3 id="IO模型分类"><a href="#IO模型分类" class="headerlink" title="IO模型分类"></a>IO模型分类</h3><p>首先，一次IO操作发生时，它会经历两个阶段：</p>
<ol>
<li><p>等待内核数据就绪。网络I/O的情况就是等待远端数据陆续抵达；磁盘I/O的情况就是等待磁盘数据从磁盘上读取到内核态内存中。</p>
</li>
<li><p>数据从内核拷贝到进程。出于系统安全,用户态的程序没有权限直接读取内核态内存,因此内核负责把内核态内存中的数据拷贝一份到用户态内存中。</p>
</li>
</ol>
<h4 id="阻塞非阻塞的区别分类"><a href="#阻塞非阻塞的区别分类" class="headerlink" title="阻塞非阻塞的区别分类"></a>阻塞非阻塞的区别分类</h4><p>这个概念是针对应用程序而言，是指应用程序中的线程在向操作系统发送IO请求后，是否一直等待操作系统的IO响应。如果是，那么就是阻塞式的；如果不是，那么应用程序一般会以轮询的方式以一定周期询问操作系统，直到某次获得了IO响应为止（轮序间隔应用程序线程可以做一些其他工作）。调用blocking IO会一直block住对应的线程直到操作完成，而non-blocking IO在kernel还没准备好数据的情况下会立刻返回。</p>
<p><strong>主要区别就是内核还没准备好数据的时候是否block用户，阻塞IO整个IO操作阶段会一直block住用户直到全部完成；非阻塞IO在内核没有准备好数据时不会阻塞而是返回错误，需要用户主动轮询操作。</strong></p>
<ul>
<li><p>阻塞IO： blocking IO</p>
</li>
<li><p>非阻塞IO： non-blocking IO； IO multiplexing； asynchronous IO</p>
</li>
</ul>
<h4 id="同步异步的区别分类"><a href="#同步异步的区别分类" class="headerlink" title="同步异步的区别分类"></a>同步异步的区别分类</h4><p>POSIX的定义是这样子的：</p>
<ul>
<li><p>A synchronous I/O operation causes the requesting process to be blocked until that I/O operation completes;</p>
</li>
<li><p>An asynchronous I/O operation does not cause the requesting process to be blocked;</p>
</li>
</ul>
<p>两者的区别就在于synchronous IO做”IO operation”的时候会将process阻塞。按照这个定义，之前所述的blocking IO，non-blocking IO，IO multiplexing都属于synchronous IO。</p>
<p>定义中所指的”IO operation”是指真实的IO操作，即把数据从内核拷贝到进程这步操作，就是例子中的recvfrom这个system call。non-blocking IO在执行recvfrom这个system call的时候，如果kernel的数据没有准备好，这时候不会block线程。但是，当kernel中数据准备好的时候，recvfrom会将数据从kernel拷贝到用户内存中，这个时候线程是被block了，在这段时间内，线程是被block的。</p>
<p>而asynchronous IO则不一样，当线程发起IO 操作之后，就直接返回再也不理睬了，直到kernel发送一个信号，告诉线程说IO完成。在这整个过程中，线程完全没有被block。</p>
<p><strong>主要区别就是做真实IO操作即把数据从内核拷贝到进程时是否block用户，同步IO在把数据从内核拷贝到进程时会block用户；异步IO通过回调主动将数据拷贝到用户内存，整个过程不会block用户。</strong></p>
<ul>
<li>同步IO： blocking IO； non-blocking IO； IO multiplexing</li>
<li>异步IO： asynchronous IO</li>
</ul>
<h3 id="Java实现"><a href="#Java实现" class="headerlink" title="Java实现"></a>Java实现</h3><p>以上这些IO工作模型，在JAVA中都能够找到对应的支持：传统的JAVA Socket套接字支持阻塞/非阻塞模式下的同步IO；JAVA NIO框架在不同操作系统下支持不同种类的多路复用IO技术（windows下的select模型、Linux下的poll/epoll模型）；JAVA AIO框架支持异步IO（windows下的IOCP和Linux使用epoll的模拟AIO）。</p>
<h3 id="注意："><a href="#注意：" class="headerlink" title="注意："></a>注意：</h3><p><strong>上文中的示例代码只是针对各种IO模型下的Java实现示例展示，并没有使用线程池技术去处理业务逻辑。实际应用中推荐也应当使用线程池技术，用线程池去处理业务逻辑部分。</strong></p>
<p><strong>客户端使用何种IO技术，对整个系统架构的性能提升相关性并不大。</strong></p>
<p><strong>非阻塞IO模型中，报文的解析，粘包拆包的处理，连接状态的管理维护都需要额外去处理，增加了编程复杂度，一般可以借助Netty，Mina等成型的封装好的NIO类库。</strong></p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://segmentfault.com/a/1190000003063859" target="_blank" rel="external">Linux IO模式及 select、poll、epoll详解</a></p>
<p><a href="http://blog.csdn.net/yinwenjie/article/details/48472237" target="_blank" rel="external">架构设计：系统间通信 —— IO通信模型和JAVA实践</a></p>
</div><script type="text/javascript" src="/js/share.js?v=0.0.0" async></script><a class="article-share-link" data-url="http://blogxin.cn/2016/12/18/Java-IO模型/" data-id="ckav6mof20029bnr0x3r8fl5c" data-qrcode="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAMYAAADGCAAAAACs8KCBAAACNElEQVR42u3aQW7DMAwF0d7/0i7QVYFUznzSKSBqtAoax9bzgqVIfn3hdf2s17/8XqvrV1eSvzy8ZMiQsS3jul21R75eyZ94/wqWz5UhQ8YBDLKV+/BKkKsrybdv9ixDhgwZIF3jVP6tDBkyZNQYta2kyaIMGTJk1A6x/DPHpynpA2dxGTJkbMhIGwP/+fmD/Q0ZMmRswrjCVbsD2RwPsn/cX4YMGaMZtQMkL7SljYH0WcVNyJAhY0NG2mKsDYfxgy5PFpcYGTJkDGWkZaxny2dp4Q/995AhQ8Y4Rppl1dJBHqD7B2MZMmRMYpDxCBJM04MrL+G1sloZMmRsziDb5ZvovAiCXyJlyJAxmtEpbPFf3RfRaoBlaihDhozRDH47ngKm4bV1DJYhQ8ZoRhoo05EL3kGtNVBlyJBxGqNzNK21EEjiWJwZkSFDxiBG+oNaQEyHJEjbUoYMGacxOrfrND55AwDNtcmQIeMARmeOLC2KkaGK4GXJkCHjAAY/avIwnY5rkNQzyHBlyJAxgsEDK6E+VbaL01MZMmQcw+AJIg+U/YQS3VOGDBmjGemwRdrCrF3DRzSKMyMyZMjYinGFqzZ+kZbP4ufKkCFjNKMW7FJGOviVDnDIkCHjBEbtAEkCJWlScp4MGTJk8CDbObh2hjneXClDhgwZYQGOlOfiqZCnAq4MGTIOYKRH1lqjNC7eyZAh4wBGbdAh3QRvJPAXJEOGjBMYn2gMdMbCOgMfMmTIGMf4BoEMrWMelDzUAAAAAElFTkSuQmCC">分享</a><div class="tags"><a href="/tags/IO/">IO</a><a href="/tags/NIO/">NIO</a><a href="/tags/BIO/">BIO</a><a href="/tags/AIO/">AIO</a></div><div class="post-nav"><a class="pre" href="/2016/12/24/I-O-多路复用之select、poll、epoll实现原理及对比总结/">I/O 多路复用之select、poll、epoll实现原理及对比总结</a><a class="next" href="/2016/11/29/JUC-FutureTask-源码分析/">JUC - FutureTask 源码分析</a></div><div id="container"></div><link rel="stylesheet" type="text/css" href="//unpkg.com/gitalk/dist/gitalk.css?v=0.0.0"><script type="text/javascript" src="//cdn.bootcss.com/blueimp-md5/2.10.0/js/md5.js?v=0.0.0"></script><script type="text/javascript" src="//unpkg.com/gitalk/dist/gitalk.min.js?v=0.0.0"></script><script>var gitalk = new Gitalk({
  clientID: '530c0141e83989b1dc02',
  clientSecret: '89e61ba0adc9b0c630bcc2641c791bfd7ef9faea',
  repo: 'kris-liu.github.io',
  owner: 'kris-liu',
  admin: ['kris-liu'],
  id: md5(location.pathname),
  distractionFreeMode: false
})
gitalk.render('container')
</script></div></div></div><div class="pure-u-1-4 hidden_mid_and_down"><div id="sidebar"><div class="widget"><form class="search-form" action="//www.google.com/search" method="get" accept-charset="utf-8" target="_blank"><input type="text" name="q" maxlength="20" placeholder="Search"/><input type="hidden" name="sitesearch" value="http://blogxin.cn"/></form></div><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"> 分类</i></div><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/Concurrent/">Concurrent</a><span class="category-list-count">8</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Git/">Git</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/IO-NIO/">IO&NIO</a><span class="category-list-count">6</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Java/">Java</a><span class="category-list-count">5</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/MQ/">MQ</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Netty/">Netty</a><span class="category-list-count">6</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Spring/">Spring</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Tomcat/">Tomcat</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Tools/">Tools</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/架构/">架构</a><span class="category-list-count">13</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/线上问题/">线上问题</a><span class="category-list-count">4</span></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-star-o"> 标签</i></div><div class="tagcloud"><a href="/tags/源码/" style="font-size: 15px;">源码</a> <a href="/tags/Spring/" style="font-size: 15px;">Spring</a> <a href="/tags/架构/" style="font-size: 15px;">架构</a> <a href="/tags/JVM/" style="font-size: 15px;">JVM</a> <a href="/tags/GC/" style="font-size: 15px;">GC</a> <a href="/tags/线上问题/" style="font-size: 15px;">线上问题</a> <a href="/tags/Git/" style="font-size: 15px;">Git</a> <a href="/tags/IO/" style="font-size: 15px;">IO</a> <a href="/tags/NIO/" style="font-size: 15px;">NIO</a> <a href="/tags/内存泄漏/" style="font-size: 15px;">内存泄漏</a> <a href="/tags/Java/" style="font-size: 15px;">Java</a> <a href="/tags/并发/" style="font-size: 15px;">并发</a> <a href="/tags/异步/" style="font-size: 15px;">异步</a> <a href="/tags/Transaction/" style="font-size: 15px;">Transaction</a> <a href="/tags/锁/" style="font-size: 15px;">锁</a> <a href="/tags/读写锁/" style="font-size: 15px;">读写锁</a> <a href="/tags/缓存/" style="font-size: 15px;">缓存</a> <a href="/tags/线程池/" style="font-size: 15px;">线程池</a> <a href="/tags/BIO/" style="font-size: 15px;">BIO</a> <a href="/tags/AIO/" style="font-size: 15px;">AIO</a> <a href="/tags/JMM/" style="font-size: 15px;">JMM</a> <a href="/tags/内存模型/" style="font-size: 15px;">内存模型</a> <a href="/tags/Netty/" style="font-size: 15px;">Netty</a> <a href="/tags/Tomcat/" style="font-size: 15px;">Tomcat</a> <a href="/tags/MQ/" style="font-size: 15px;">MQ</a> <a href="/tags/Tools/" style="font-size: 15px;">Tools</a> <a href="/tags/SpringBoot/" style="font-size: 15px;">SpringBoot</a> <a href="/tags/MyBatis/" style="font-size: 15px;">MyBatis</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-file-o"> 最近文章</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2020/05/24/Distributed-Transaction-8/">从零开始写一个分布式事务框架(八)-使用教程</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/05/24/Distributed-Transaction-7/">从零开始写一个分布式事务框架(七)-SpringBootStarter</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/05/24/Distributed-Transaction-6/">从零开始写一个分布式事务框架(六)-事务协调器</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/05/16/Distributed-Transaction-5/">从零开始写一个分布式事务框架(五)-资源管理器</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/05/09/Distributed-Transaction-4/">从零开始写一个分布式事务框架(四)-事务管理器</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/05/05/Distributed-Transaction-3/">从零开始写一个分布式事务框架(三)-事务记录</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/05/04/Distributed-Transaction-2/">从零开始写一个分布式事务框架(二)-架构</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/02/16/Distributed-Transaction-1/">从零开始写一个分布式事务框架(一)</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/06/01/sharding-db/">基于Spring+MyBatis实现一个分库分表、读写分离功能的工具库</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/03/02/multi-datacenter/">多活架构思考总结</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-external-link"> 友情链接</i></div><ul></ul><a href="http://blog.csdn.net/xx_ytm" title="我的CSDN博客" target="_blank">我的CSDN博客</a></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">Copyright © 2020 <a href="/." rel="nofollow">佑祺's Blog.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/tufu9441/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/pagecho"> Cho.</a></div></div></div><a class="show" id="rocket" href="#top"></a><script type="text/javascript" src="/js/totop.js?v=0.0.0" async></script><script type="text/javascript" src="//cdn.bootcss.com/fancybox/3.3.5/jquery.fancybox.min.js" async></script><script type="text/javascript" src="/js/fancybox.js?v=0.0.0" async></script><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/fancybox/3.3.5/jquery.fancybox.min.css"><script type="text/javascript" src="/js/codeblock-resizer.js?v=0.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=0.0.0"></script></div></body></html>