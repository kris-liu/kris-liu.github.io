<!DOCTYPE html><html lang="zh-CN"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content="Kris's Blog"><title>Java IO模型 | Kris's Blog</title><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/normalize/5.0.0/normalize.min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/0.6.0/pure-min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/0.6.0/grids-responsive-min.css"><link rel="stylesheet" type="text/css" href="/css/style.css?v=0.0.0"><link rel="stylesheet" href="//cdn.bootcss.com/font-awesome/4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="//cdn.bootcss.com/jquery/3.1.1/jquery.min.js"></script><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">Java IO模型</h1><a id="logo" href="/.">Kris's Blog</a><p class="description">Whatever you do, you have to keep moving forward!</p></div><div id="nav-menu"><a href="/." class="current"><i class="fa fa-home"> 首页</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a><a href="/about/"><i class="fa fa-user"> 关于</i></a><a href="/atom.xml"><i class="fa fa-rss"> 订阅</i></a></div></div><div id="layout" class="pure-g"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">Java IO模型</h1><div class="post-meta">Dec 18, 2016<span> | </span><span class="category"><a href="/categories/IO-NIO/">IO&amp;NIO</a></span><script src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js" async></script><span id="busuanzi_container_page_pv"> | <span id="busuanzi_value_page_pv"></span><span> Hits</span></span></div><a data-thread-key="2016/12/18/Java-IO模型/" href="/2016/12/18/Java-IO模型/#comments" class="ds-thread-count"></a><div class="post-content"><p>目前常用的IO通信模型包括四种：</p>
<ul>
<li>阻塞同步I/O（blocking IO）</li>
<li>非阻塞同步I/O（nonblocking IO）</li>
<li>多路复用I/O（IO multiplexing）</li>
<li>异步I/O（asynchronous IO）</li>
</ul>
<p>这些IO模型都是要靠底层操作系统进行支持，应用程序只是提供相应的实现，对操作系统进行调用。本文将介绍这四种IO模型及Java对这四种IO模型的支持。</p>
<p>对于一次IO访问（以read举例），数据会先被拷贝到操作系统内核的缓冲区中，然后才会从操作系统内核的缓冲区拷贝到应用程序的地址空间。所以说，当一个read操作发生时，它会经历两个阶段：</p>
<ol>
<li>等待数据准备。</li>
<li>将数据从内核拷贝到进程中。</li>
</ol>
<h2 id="阻塞同步I-O（blocking-IO）"><a href="#阻塞同步I-O（blocking-IO）" class="headerlink" title="阻塞同步I/O（blocking IO）"></a>阻塞同步I/O（blocking IO）</h2><p><img src="/2016/12/18/Java-IO模型/blocking-IO.png" alt="blocking-IO"></p>
<p>在linux中，默认情况下所有的socket都是blocking，一个典型的读操作流程大概是这样：当用户线程调用了recvfrom这个系统调用，kernel就开始了IO的第一个阶段：准备数据（对于网络IO来说，很多时候数据在一开始还没有到达。比如，还没有收到一个完整的UDP包。这个时候kernel就要等待足够的数据到来）。这个过程需要等待，也就是说数据被拷贝到操作系统内核的缓冲区中是需要一个过程的。而在用户线程这边，整个线程会被阻塞（当然，是线程自己选择的阻塞）。当kernel一直等到数据准备好了，它就会将数据从kernel中拷贝到用户内存，然后kernel返回结果，用户线程才解除block的状态，重新运行起来。这意味着应用程序在调用时会一直阻塞，直到系统调用完成为止（数据传输完成或发生错误）。调用应用程序处于一种不再消费 CPU 而只是简单等待响应的状态，因此从处理的角度来看，这是非常有效的。</p>
<p>blocking IO的特点就是在IO执行的两个阶段都被block了。</p>
<h3 id="阻塞同步IO-Java实现"><a href="#阻塞同步IO-Java实现" class="headerlink" title="阻塞同步IO Java实现"></a>阻塞同步IO Java实现</h3><figure class="highlight d"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> com.kris.ioModel;</div><div class="line"></div><div class="line"><span class="keyword">import</span> org.slf4j.Logger;</div><div class="line"><span class="keyword">import</span> org.slf4j.LoggerFactory;</div><div class="line"></div><div class="line"><span class="keyword">import</span> java.io.IOException;</div><div class="line"><span class="keyword">import</span> java.io.InputStream;</div><div class="line"><span class="keyword">import</span> java.io.OutputStream;</div><div class="line"><span class="keyword">import</span> java.net.ServerSocket;</div><div class="line"><span class="keyword">import</span> java.net.Socket;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"> * 阻塞同步IO Java实现</div><div class="line"> *</div><div class="line"> * @author xin.liu</div><div class="line"> */</div><div class="line"><span class="keyword">public</span> <span class="keyword">class</span> SocketServer1 &#123;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger LOGGER = LoggerFactory.getLogger(SocketServer1.<span class="keyword">class</span>);</div><div class="line"></div><div class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> main(String[] args) throws IOException &#123;</div><div class="line">        ServerSocket serverSocket = <span class="literal">null</span>;</div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            serverSocket = <span class="keyword">new</span> ServerSocket(<span class="number">10001</span>);</div><div class="line">            <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</div><div class="line">                <span class="comment">//这里JAVA通过JNI请求操作系统，并一直等待操作系统返回结果（或者出错）</span></div><div class="line">                Socket socket = serverSocket.accept();</div><div class="line"></div><div class="line">                <span class="comment">//下面我们收取信息（这里还是阻塞式的,一直等待，直到有数据可以接受）</span></div><div class="line">                InputStream <span class="keyword">in</span> = socket.getInputStream();</div><div class="line">                OutputStream <span class="keyword">out</span> = socket.getOutputStream();</div><div class="line">                Integer sourcePort = socket.getPort();</div><div class="line">                <span class="keyword">int</span> maxLen = <span class="number">2048</span>;</div><div class="line">                <span class="keyword">byte</span>[] contextBytes = <span class="keyword">new</span> <span class="keyword">byte</span>[maxLen];</div><div class="line">                <span class="keyword">int</span> realLen;</div><div class="line">                StringBuilder message = <span class="keyword">new</span> StringBuilder();</div><div class="line">                <span class="comment">//read的时候，程序也会被阻塞，直到操作系统把网络传来的数据准备好。</span></div><div class="line">                <span class="keyword">while</span> ((realLen = <span class="keyword">in</span>.read(contextBytes, <span class="number">0</span>, maxLen)) != -<span class="number">1</span>) &#123;</div><div class="line">                    message.append(<span class="keyword">new</span> String(contextBytes, <span class="number">0</span>, realLen));</div><div class="line">                    <span class="comment">/*</span></div><div class="line">                     * 我们假设读取到“over”关键字，</div><div class="line">                     * 表示客户端的所有信息在经过若干次传送后，完成</div><div class="line">                     * */</div><div class="line">                    <span class="keyword">if</span> (message.indexOf(<span class="string">"over"</span>) != -<span class="number">1</span>) &#123;</div><div class="line">                        <span class="keyword">break</span>;</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line">                <span class="comment">//下面打印信息</span></div><div class="line">                LOGGER.info(<span class="string">"服务器收到来自于端口："</span> + sourcePort + <span class="string">"的信息："</span> + message);</div><div class="line"></div><div class="line">                <span class="comment">//下面开始发送信息</span></div><div class="line">                <span class="keyword">out</span>.write(<span class="string">"回发响应信息！"</span>.getBytes());</div><div class="line"></div><div class="line">                <span class="comment">//关闭</span></div><div class="line">                socket.close();</div><div class="line">            &#125;</div><div class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</div><div class="line">            LOGGER.error(e.getMessage(), e);</div><div class="line">        &#125; <span class="keyword">finally</span> &#123;</div><div class="line">            serverSocket.close();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="非阻塞同步I-O（nonblocking-IO）"><a href="#非阻塞同步I-O（nonblocking-IO）" class="headerlink" title="非阻塞同步I/O（nonblocking IO）"></a>非阻塞同步I/O（nonblocking IO）</h2><p><img src="/2016/12/18/Java-IO模型/nonblocking-IO.png" alt="nonblocking-IO"></p>
<p>linux下，可以通过设置socket使其变为non-blocking。当对一个non-blocking socket执行读操作时，流程是这个样子：当用户线程发出read操作时，如果kernel中的数据还没有准备好，那么它并不会block用户线程，而是立刻返回一个error。从用户线程角度讲 ，它发起一个read操作后，并不需要等待，而是马上就得到了一个结果。用户线程判断结果是一个error时，它就知道数据还没有准备好，于是它可以再次发送read操作。一旦kernel中的数据准备好了，并且又再次收到了用户线程的system call，那么它马上就将数据拷贝到了用户内存，然后返回。这种模式下，应用程序的线程不再一直等待操作系统的IO状态，而是在等待一段时间后，就解除阻塞。如果没有得到想要的结果，则再次进行相同的操作。</p>
<p>nonblocking IO的特点是用户线程需要不断的主动询问kernel数据好了没有。</p>
<h3 id="非阻塞同步IO-Java实现"><a href="#非阻塞同步IO-Java实现" class="headerlink" title="非阻塞同步IO Java实现"></a>非阻塞同步IO Java实现</h3><figure class="highlight d"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> com.kris.ioModel;</div><div class="line"></div><div class="line"><span class="keyword">import</span> org.slf4j.Logger;</div><div class="line"><span class="keyword">import</span> org.slf4j.LoggerFactory;</div><div class="line"></div><div class="line"><span class="keyword">import</span> java.io.IOException;</div><div class="line"><span class="keyword">import</span> java.io.InputStream;</div><div class="line"><span class="keyword">import</span> java.io.OutputStream;</div><div class="line"><span class="keyword">import</span> java.net.ServerSocket;</div><div class="line"><span class="keyword">import</span> java.net.Socket;</div><div class="line"><span class="keyword">import</span> java.net.SocketTimeoutException;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"> * 非阻塞同步IO Java实现</div><div class="line"> *</div><div class="line"> * @author xin.liu</div><div class="line"> */</div><div class="line"><span class="keyword">public</span> <span class="keyword">class</span> SocketServer2 &#123;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger LOGGER = LoggerFactory.getLogger(SocketServer2.<span class="keyword">class</span>);</div><div class="line"></div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Object xWait = <span class="keyword">new</span> Object();</div><div class="line"></div><div class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> main(String[] args) throws IOException &#123;</div><div class="line">        ServerSocket serverSocket = <span class="literal">null</span>;</div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            serverSocket = <span class="keyword">new</span> ServerSocket(<span class="number">10002</span>);</div><div class="line">            serverSocket.setSoTimeout(<span class="number">100</span>);</div><div class="line">            <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</div><div class="line">                Socket socket;</div><div class="line">                <span class="keyword">try</span> &#123;</div><div class="line">                    socket = serverSocket.accept();</div><div class="line">                &#125; <span class="keyword">catch</span> (SocketTimeoutException e1) &#123;</div><div class="line">                    <span class="comment">//===========================================================</span></div><div class="line">                    <span class="comment">//      执行到这里，说明本次accept没有接收到任何TCP连接</span></div><div class="line">                    <span class="comment">//      主线程在这里就可以做一些事情，记为X</span></div><div class="line">                    <span class="comment">//===========================================================</span></div><div class="line">                    <span class="keyword">synchronized</span> (xWait) &#123;</div><div class="line">                        LOGGER.info(<span class="string">"这次没有从底层接收到任何TCP连接，等待10毫秒，模拟事件X的处理时间"</span>);</div><div class="line">                        xWait.wait(<span class="number">10</span>);</div><div class="line">                    &#125;</div><div class="line">                    <span class="keyword">continue</span>;</div><div class="line">                &#125;</div><div class="line"></div><div class="line">                InputStream <span class="keyword">in</span> = socket.getInputStream();</div><div class="line">                OutputStream <span class="keyword">out</span> = socket.getOutputStream();</div><div class="line">                Integer sourcePort = socket.getPort();</div><div class="line">                <span class="keyword">int</span> maxLen = <span class="number">2048</span>;</div><div class="line">                <span class="keyword">byte</span>[] contextBytes = <span class="keyword">new</span> <span class="keyword">byte</span>[maxLen];</div><div class="line">                <span class="keyword">int</span> realLen;</div><div class="line">                StringBuilder message = <span class="keyword">new</span> StringBuilder();</div><div class="line">                <span class="comment">//下面我们收取信息（设置成非阻塞方式，这样read信息的时候，又可以做一些其他事情）</span></div><div class="line">                socket.setSoTimeout(<span class="number">10</span>);</div><div class="line">                BIORead:</div><div class="line">                <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</div><div class="line">                    <span class="keyword">try</span> &#123;</div><div class="line">                        <span class="keyword">while</span> ((realLen = <span class="keyword">in</span>.read(contextBytes, <span class="number">0</span>, maxLen)) != -<span class="number">1</span>) &#123;</div><div class="line">                            message.append(<span class="keyword">new</span> String(contextBytes, <span class="number">0</span>, realLen));</div><div class="line">                            <span class="comment">/*</span></div><div class="line">                             * 我们假设读取到“over”关键字，</div><div class="line">                             * 表示客户端的所有信息在经过若干次传送后，完成</div><div class="line">                             * */</div><div class="line">                            <span class="keyword">if</span> (message.indexOf(<span class="string">"over"</span>) != -<span class="number">1</span>) &#123;</div><div class="line">                                <span class="keyword">break</span> BIORead;</div><div class="line">                            &#125;</div><div class="line">                        &#125;</div><div class="line">                    &#125; <span class="keyword">catch</span> (SocketTimeoutException e2) &#123;</div><div class="line">                        <span class="comment">//===========================================================</span></div><div class="line">                        <span class="comment">//      执行到这里，说明本次read没有接收到任何数据流</span></div><div class="line">                        <span class="comment">//      主线程在这里又可以做一些事情，记为Y</span></div><div class="line">                        <span class="comment">//===========================================================</span></div><div class="line">                        LOGGER.info(<span class="string">"这次没有从底层接收到任务数据报文，等待10毫秒，模拟事件Y的处理时间"</span>);</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line">                <span class="comment">//下面打印信息</span></div><div class="line">                LOGGER.info(<span class="string">"服务器收到来自于端口："</span> + sourcePort + <span class="string">"的信息："</span> + message);</div><div class="line"></div><div class="line">                <span class="comment">//下面开始发送信息</span></div><div class="line">                <span class="keyword">out</span>.write(<span class="string">"回发响应信息！"</span>.getBytes());</div><div class="line"></div><div class="line">                <span class="comment">//关闭</span></div><div class="line">                socket.close();</div><div class="line">            &#125;</div><div class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</div><div class="line">            LOGGER.error(e.getMessage(), e);</div><div class="line">        &#125; <span class="keyword">finally</span> &#123;</div><div class="line">            <span class="keyword">if</span> (serverSocket != <span class="literal">null</span>) &#123;</div><div class="line">                serverSocket.close();</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="多路复用I-O（IO-multiplexing）"><a href="#多路复用I-O（IO-multiplexing）" class="headerlink" title="多路复用I/O（IO multiplexing）"></a>多路复用I/O（IO multiplexing）</h2><p><img src="/2016/12/18/Java-IO模型/IO-multiplexing.png" alt="IO-multiplexing"></p>
<p>IO multiplexing就是我们说的select，poll，epoll。IO多路复用模型从流程上和同步阻塞IO的区别不大，主要区别在于操作系统为用户提供了同时轮询多个IO句柄来查看是否有IO事件的接口（如select/epoll），这从根本上允许用户可以使用单个线程来管理多个IO句柄的问题。</p>
<p>当用户线程调用了select，那么整个线程会被block，而同时，kernel会“监视”所有select负责的socket，当任何一个socket中的数据准备好了，select就会返回。这个时候用户线程再调用read操作，直接把数据从kernel拷贝到用户线程。</p>
<p>在IO multiplexing Model中，实际中，对于每一个socket，一般都设置成为non-blocking，但是，如上图所示，整个用户的线程其实是一直被block的。只不过线程是被select这个函数block，而不是被socket IO给block。</p>
<p>I/O多路复用的特点是通过一种机制使一个线程能同时等待多个文件描述符，而这些文件描述符（套接字描述符）其中的任意一个进入就绪状态，select()函数就可以返回。<br>这个图和blocking IO的图其实并没有太大的不同，事实上，还更差一些。因为这里需要使用两个system call (select 和 recvfrom)，而blocking IO只调用了一个system call (recvfrom)。但是，用select的优势在于它可以同时处理多个socket。所以，如果处理的连接数不是很高的话，使用select/epoll的web server不一定比使用multi-threading + blocking IO的web server性能更好，可能延迟还更大。select/epoll的优势并不是对于单个连接能处理得更快，而是在于能处理更多的连接。</p>
<h3 id="多路复用IO-Java实现"><a href="#多路复用IO-Java实现" class="headerlink" title="多路复用IO Java实现"></a>多路复用IO Java实现</h3><figure class="highlight processing"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> com.kris.ioModel;</div><div class="line"></div><div class="line"><span class="keyword">import</span> org.slf4j.Logger;</div><div class="line"><span class="keyword">import</span> org.slf4j.LoggerFactory;</div><div class="line"></div><div class="line"><span class="keyword">import</span> java.net.InetSocketAddress;</div><div class="line"><span class="keyword">import</span> java.nio.ByteBuffer;</div><div class="line"><span class="keyword">import</span> java.nio.channels.*;</div><div class="line"><span class="keyword">import</span> java.util.Iterator;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"> * 多路复用IO Java实现</div><div class="line"> *</div><div class="line"> * @author xin.liu</div><div class="line"> */</div><div class="line"><span class="keyword">public</span> class SocketServer3 &#123;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger LOGGER = LoggerFactory.getLogger(SocketServer3.class);</div><div class="line"></div><div class="line"></div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="built_in">int</span> PORT_NUMBER = <span class="number">10003</span>;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> ByteBuffer buffer = ByteBuffer.allocateDirect(<span class="number">1024</span>);</div><div class="line"></div><div class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> main(<span class="keyword">String</span>[] args) <span class="keyword">throws</span> Exception &#123;</div><div class="line">        <span class="built_in">int</span> port = PORT_NUMBER;</div><div class="line">        LOGGER.info(<span class="string">"Listening on port "</span> + port);</div><div class="line"></div><div class="line">        Selector selector = Selector.<span class="built_in">open</span>();</div><div class="line"></div><div class="line">        ServerSocketChannel serverChannel = ServerSocketChannel.<span class="built_in">open</span>();</div><div class="line">        serverChannel.bind(<span class="keyword">new</span> InetSocketAddress(port));</div><div class="line">        serverChannel.configureBlocking(<span class="keyword">false</span>);</div><div class="line">        serverChannel.register(selector, SelectionKey.OP_ACCEPT);</div><div class="line"></div><div class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</div><div class="line"></div><div class="line">            <span class="comment">//查看是否有注册的IO事件发生</span></div><div class="line">            <span class="built_in">int</span> n = selector.select();</div><div class="line">            <span class="keyword">if</span> (n == <span class="number">0</span>) &#123;</div><div class="line">                <span class="keyword">continue</span>; <span class="comment">// nothing to do</span></div><div class="line">            &#125;</div><div class="line"></div><div class="line">            <span class="comment">//获取已准备好IO事件的通道集合</span></div><div class="line">            Iterator it = selector.selectedKeys().iterator();</div><div class="line">            <span class="keyword">while</span> (it.hasNext()) &#123;</div><div class="line">                SelectionKey <span class="built_in">key</span> = (SelectionKey) it.next();</div><div class="line"></div><div class="line">                <span class="comment">//通道有accept事件发生</span></div><div class="line">                <span class="keyword">if</span> (<span class="built_in">key</span>.isValid() &amp;&amp; <span class="built_in">key</span>.isAcceptable()) &#123;</div><div class="line">                    ServerSocketChannel server = (ServerSocketChannel) <span class="built_in">key</span>.channel();</div><div class="line">                    SocketChannel channel = server.accept();</div><div class="line">                    registerChannel(selector, channel, SelectionKey.OP_READ);</div><div class="line">                &#125;</div><div class="line"></div><div class="line">                <span class="comment">//通道有read事件发生</span></div><div class="line">                <span class="keyword">if</span> (<span class="built_in">key</span>.isValid() &amp;&amp; <span class="built_in">key</span>.isReadable()) &#123;</div><div class="line">                    readDataFromSocket(<span class="built_in">key</span>);</div><div class="line">                &#125;</div><div class="line"></div><div class="line">                <span class="comment">//通道有write事件发生</span></div><div class="line">                <span class="keyword">if</span> (<span class="built_in">key</span>.isValid() &amp;&amp; <span class="built_in">key</span>.isWritable()) &#123;</div><div class="line">                    LOGGER.info(<span class="string">"isWritable = true"</span>);</div><div class="line">                &#125;</div><div class="line"></div><div class="line">                <span class="comment">//通道有connect事件发生</span></div><div class="line">                <span class="keyword">if</span> (<span class="built_in">key</span>.isValid() &amp;&amp; <span class="built_in">key</span>.isConnectable()) &#123;</div><div class="line">                    LOGGER.info(<span class="string">"isConnectable = true"</span>);</div><div class="line">                &#125;</div><div class="line"></div><div class="line">                <span class="comment">//移除已处理IO事件的通道</span></div><div class="line">                it.remove();</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 处理监听IO操作，将接收到通道注册到Selector上</div><div class="line">     * @param selector</div><div class="line">     * @param channel</div><div class="line">     * @param ops</div><div class="line">     * @throws Exception</div><div class="line">     */</div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> registerChannel(Selector selector, SelectableChannel channel, <span class="built_in">int</span> ops) <span class="keyword">throws</span> Exception &#123;</div><div class="line">        <span class="keyword">if</span> (channel == <span class="keyword">null</span>) &#123;</div><div class="line">            <span class="keyword">return</span>;</div><div class="line">        &#125;</div><div class="line">        channel.configureBlocking(<span class="keyword">false</span>);</div><div class="line">        channel.register(selector, ops);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 处理读取IO操作，将服务端接收到的数据发送回客户端</div><div class="line">     * @param key</div><div class="line">     * @throws Exception</div><div class="line">     */</div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> readDataFromSocket(SelectionKey <span class="built_in">key</span>) <span class="keyword">throws</span> Exception &#123;</div><div class="line">        SocketChannel socketChannel = (SocketChannel) <span class="built_in">key</span>.channel();</div><div class="line">        <span class="built_in">int</span> count;</div><div class="line">        buffer.<span class="built_in">clear</span>();</div><div class="line"></div><div class="line">        <span class="keyword">while</span> ((count = socketChannel.read(buffer)) &gt; <span class="number">0</span>) &#123;</div><div class="line">            buffer.flip();</div><div class="line">            <span class="keyword">while</span> (buffer.hasRemaining()) &#123;</div><div class="line">                socketChannel.write(buffer);</div><div class="line">            &#125;</div><div class="line">            buffer.<span class="built_in">clear</span>();</div><div class="line">            <span class="built_in">key</span>.interestOps(SelectionKey.OP_READ | SelectionKey.OP_WRITE);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">if</span> (count &lt; <span class="number">0</span>) &#123;</div><div class="line">            <span class="comment">// Close channel on EOF, invalidates the key</span></div><div class="line">            socketChannel.close();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="异步I-O（asynchronous-IO）"><a href="#异步I-O（asynchronous-IO）" class="headerlink" title="异步I/O（asynchronous IO）"></a>异步I/O（asynchronous IO）</h2><p><img src="/2016/12/18/Java-IO模型/asynchronous-IO.png" alt="asynchronous-IO"></p>
<p>用户线程发起read操作之后，立刻就可以开始去做其它的事。而另一方面，从kernel的角度，当它受到一个asynchronous read之后，首先它会立刻返回，所以不会对用户线程产生任何block。然后，kernel会等待数据准备完成，然后将数据拷贝到用户内存，当这一切都完成之后，kernel会给用户线程发送一个signal，告诉它read操作完成了。</p>
<p>采用“订阅-通知”模式：即应用程序向操作系统注册IO监听，然后继续做自己的事情。当操作系统发生IO事件，并且准备好数据后，再主动通知应用程序，触发相应的函数去处理。</p>
<h3 id="异步IO-Java实现"><a href="#异步IO-Java实现" class="headerlink" title="异步IO Java实现"></a>异步IO Java实现</h3><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div><div class="line">139</div><div class="line">140</div><div class="line">141</div><div class="line">142</div><div class="line">143</div><div class="line">144</div><div class="line">145</div><div class="line">146</div><div class="line">147</div><div class="line">148</div><div class="line">149</div><div class="line">150</div><div class="line">151</div><div class="line">152</div><div class="line">153</div><div class="line">154</div><div class="line">155</div><div class="line">156</div><div class="line">157</div><div class="line">158</div><div class="line">159</div><div class="line">160</div><div class="line">161</div><div class="line">162</div><div class="line">163</div><div class="line">164</div><div class="line">165</div><div class="line">166</div><div class="line">167</div><div class="line">168</div><div class="line">169</div><div class="line">170</div><div class="line">171</div><div class="line">172</div><div class="line">173</div><div class="line">174</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> com.kris.ioModel;</div><div class="line"></div><div class="line"><span class="keyword">import</span> org.slf4j.Logger;</div><div class="line"><span class="keyword">import</span> org.slf4j.LoggerFactory;</div><div class="line"></div><div class="line"><span class="keyword">import</span> java.io.IOException;</div><div class="line"><span class="keyword">import</span> java.io.UnsupportedEncodingException;</div><div class="line"><span class="keyword">import</span> java.net.InetSocketAddress;</div><div class="line"><span class="keyword">import</span> java.nio.ByteBuffer;</div><div class="line"><span class="keyword">import</span> java.nio.channels.AsynchronousChannelGroup;</div><div class="line"><span class="keyword">import</span> java.nio.channels.AsynchronousServerSocketChannel;</div><div class="line"><span class="keyword">import</span> java.nio.channels.AsynchronousSocketChannel;</div><div class="line"><span class="keyword">import</span> java.nio.channels.CompletionHandler;</div><div class="line"><span class="keyword">import</span> java.util.concurrent.ExecutorService;</div><div class="line"><span class="keyword">import</span> java.util.concurrent.Executors;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"> * 异步IO Java实现</div><div class="line"> *</div><div class="line"> * <span class="doctag">@author</span> xin.liu</div><div class="line"> */</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SocketServer4</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Object waitObject = <span class="keyword">new</span> Object();</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * <span class="doctag">@param</span> args</div><div class="line">     * <span class="doctag">@throws</span> Exception</div><div class="line">     */</div><div class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">        <span class="comment">/*</span></div><div class="line">         * 这个线程池是用来得到操作系统的“IO事件通知”的，不是用来进行“得到IO数据后的业务处理的”。要进行后者的操作，您可以再使用一个池（最好不要混用）</div><div class="line">         */</div><div class="line">        ExecutorService threadPool = Executors.newFixedThreadPool(<span class="number">20</span>);</div><div class="line">        AsynchronousChannelGroup group = AsynchronousChannelGroup.withThreadPool(threadPool);</div><div class="line">        <span class="keyword">final</span> AsynchronousServerSocketChannel serverSocket = AsynchronousServerSocketChannel.open(group);</div><div class="line"></div><div class="line">        serverSocket.bind(<span class="keyword">new</span> InetSocketAddress(<span class="string">"0.0.0.0"</span>, <span class="number">10004</span>));</div><div class="line">        <span class="comment">//为AsynchronousServerSocketChannel注册监听，注意只是为AsynchronousServerSocketChannel通道注册监听</span></div><div class="line">        serverSocket.accept(<span class="keyword">null</span>, <span class="keyword">new</span> ServerSocketChannelHandle(serverSocket));</div><div class="line"></div><div class="line">        <span class="comment">//等待，只是为了保证守护线程不会退出</span></div><div class="line">        <span class="keyword">synchronized</span> (waitObject) &#123;</div><div class="line">            waitObject.wait();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"> * 这个处理器类，专门用来响应 ServerSocketChannel 的事件。</div><div class="line"> * ServerSocketChannel只有一种事件：接受客户端的连接</div><div class="line"> */</div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">ServerSocketChannelHandle</span> <span class="keyword">implements</span> <span class="title">CompletionHandler</span>&lt;<span class="title">AsynchronousSocketChannel</span>, <span class="title">Void</span>&gt; </span>&#123;</div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 日志</div><div class="line">     */</div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger LOGGER = LoggerFactory.getLogger(ServerSocketChannelHandle.class);</div><div class="line"></div><div class="line">    <span class="keyword">private</span> AsynchronousServerSocketChannel serverSocketChannel;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * <span class="doctag">@param</span> serverSocketChannel</div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ServerSocketChannelHandle</span><span class="params">(AsynchronousServerSocketChannel serverSocketChannel)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.serverSocketChannel = serverSocketChannel;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 注意，我们分别观察 this、socketChannel、attachment三个对象的id。</div><div class="line">     * 来观察不同客户端连接到达时，这三个对象的变化，以说明ServerSocketChannelHandle的监听模式</div><div class="line">     */</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">void</span> <span class="title">completed</span><span class="params">(AsynchronousSocketChannel socketChannel, Void attachment)</span> </span>&#123;</div><div class="line">        LOGGER.info(<span class="string">"completed(AsynchronousSocketChannel result, ByteBuffer attachment)"</span>);</div><div class="line">        <span class="comment">//每次都要重新注册监听（一次注册，一次响应），但是由于“文件状态标示符”是独享的，所以不需要担心有“漏掉的”事件</span></div><div class="line">        <span class="keyword">this</span>.serverSocketChannel.accept(attachment, <span class="keyword">this</span>);</div><div class="line"></div><div class="line">        <span class="comment">//为这个新的socketChannel注册“read”事件，以便操作系统在收到数据并准备好后，主动通知应用程序</span></div><div class="line">        <span class="comment">//在这里，由于我们要将这个客户端多次传输的数据累加起来一起处理，所以我们将一个stringBuffer对象作为一个“附件”依附在这个channel上</span></div><div class="line">        <span class="comment">//</span></div><div class="line">        ByteBuffer readBuffer = ByteBuffer.allocate(<span class="number">50</span>);</div><div class="line">        socketChannel.read(readBuffer, <span class="keyword">new</span> StringBuffer(), <span class="keyword">new</span> SocketChannelReadHandle(socketChannel, readBuffer));</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">void</span> <span class="title">failed</span><span class="params">(Throwable exc, Void attachment)</span> </span>&#123;</div><div class="line">        LOGGER.<span class="keyword">error</span>(<span class="string">"failed(Throwable exc, ByteBuffer attachment)"</span>);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"> * 负责对每一个socketChannel的数据获取事件进行监听。&lt;p&gt;</div><div class="line"> * &lt;p&gt;</div><div class="line"> * 重要的说明：一个socketChannel都会有一个独立工作的SocketChannelReadHandle对象（CompletionHandler接口的实现），</div><div class="line"> * 其中又都将独享一个“文件状态标示”对象FileDescriptor、</div><div class="line"> * 一个独立的由程序员定义的Buffer缓存（这里我们使用的是ByteBuffer）、</div><div class="line"> * 所以不用担心在服务器端会出现“窜对象”这种情况，因为JAVA AIO框架已经帮您组织好了。&lt;p&gt;</div><div class="line"> * &lt;p&gt;</div><div class="line"> * 但是最重要的，用于生成channel的对象：AsynchronousChannelProvider是单例模式，无论在哪组socketChannel，</div><div class="line"> * 对是一个对象引用（但这没关系，因为您不会直接操作这个AsynchronousChannelProvider对象）。</div><div class="line"> */</div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">SocketChannelReadHandle</span> <span class="keyword">implements</span> <span class="title">CompletionHandler</span>&lt;<span class="title">Integer</span>, <span class="title">StringBuffer</span>&gt; </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger LOGGER = LoggerFactory.getLogger(SocketChannelReadHandle.class);</div><div class="line"></div><div class="line">    <span class="keyword">private</span> AsynchronousSocketChannel socketChannel;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 专门用于进行这个通道数据缓存操作的ByteBuffer&lt;br&gt;</div><div class="line">     * 当然，您也可以作为CompletionHandler的attachment形式传入。&lt;br&gt;</div><div class="line">     * 这是，在这段示例代码中，attachment被我们用来记录所有传送过来的StringBuffer了。</div><div class="line">     */</div><div class="line">    <span class="keyword">private</span> ByteBuffer byteBuffer;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">SocketChannelReadHandle</span><span class="params">(AsynchronousSocketChannel socketChannel, ByteBuffer byteBuffer)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.socketChannel = socketChannel;</div><div class="line">        <span class="keyword">this</span>.byteBuffer = byteBuffer;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">void</span> <span class="title">completed</span><span class="params">(Integer result, StringBuffer historyContext)</span> </span>&#123;</div><div class="line">        <span class="comment">//如果条件成立，说明客户端主动终止了TCP套接字，这时服务端终止就可以了</span></div><div class="line">        <span class="keyword">if</span> (result == <span class="number">-1</span>) &#123;</div><div class="line">            <span class="keyword">try</span> &#123;</div><div class="line">                <span class="keyword">this</span>.socketChannel.close();</div><div class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</div><div class="line">                LOGGER.<span class="keyword">error</span>(e.getMessage(), e);</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">return</span>;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        LOGGER.info(<span class="string">"completed(Integer result, Void attachment) : 然后我们来取出通道中准备好的值"</span>);</div><div class="line">        <span class="comment">/*</span></div><div class="line">         * 实际上，由于我们从Integer result知道了本次channel从操作系统获取数据总长度</div><div class="line">         * 所以实际上，我们不需要切换成“读模式”的，但是为了保证编码的规范性，还是建议进行切换。</div><div class="line">         *</div><div class="line">         * 另外，无论是JAVA AIO框架还是JAVA NIO框架，都会出现“buffer的总容量”小于“当前从操作系统获取到的总数据量”，</div><div class="line">         * 但区别是，JAVA AIO框架中，我们不需要专门考虑处理这样的情况，因为JAVA AIO框架已经帮我们做了处理（做成了多次通知）</div><div class="line">         * */</div><div class="line">        <span class="keyword">this</span>.byteBuffer.flip();</div><div class="line">        <span class="keyword">byte</span>[] contexts = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];</div><div class="line">        <span class="keyword">this</span>.byteBuffer.get(contexts, <span class="number">0</span>, result);</div><div class="line">        <span class="keyword">this</span>.byteBuffer.clear();</div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            String nowContent = <span class="keyword">new</span> String(contexts, <span class="number">0</span>, result, <span class="string">"UTF-8"</span>);</div><div class="line">            historyContext.append(nowContent);</div><div class="line">            LOGGER.info(<span class="string">"================目前的传输结果："</span> + historyContext);</div><div class="line">        &#125; <span class="keyword">catch</span> (UnsupportedEncodingException e) &#123;</div><div class="line">            LOGGER.<span class="keyword">error</span>(e.getMessage(), e);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="comment">//如果条件成立，说明还没有接收到“结束标记”</span></div><div class="line">        <span class="keyword">if</span> (historyContext.indexOf(<span class="string">"over"</span>) == <span class="number">-1</span>) &#123;</div><div class="line">            <span class="keyword">return</span>;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        LOGGER.info(<span class="string">"=======收到完整信息，开始处理业务========="</span>);</div><div class="line">        historyContext = <span class="keyword">new</span> StringBuffer();</div><div class="line"></div><div class="line">        <span class="comment">//还要继续监听（一次监听一次通知）</span></div><div class="line">        <span class="keyword">this</span>.socketChannel.read(<span class="keyword">this</span>.byteBuffer, historyContext, <span class="keyword">this</span>);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">void</span> <span class="title">failed</span><span class="params">(Throwable exc, StringBuffer historyContext)</span> </span>&#123;</div><div class="line">        LOGGER.<span class="keyword">error</span>(<span class="string">"=====发现客户端异常关闭，服务器将关闭TCP通道"</span>);</div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            <span class="keyword">this</span>.socketChannel.close();</div><div class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</div><div class="line">            LOGGER.<span class="keyword">error</span>(e.getMessage(), e);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="IO模型总结"><a href="#IO模型总结" class="headerlink" title="IO模型总结"></a>IO模型总结</h2><h3 id="blocking和non-blocking的区别"><a href="#blocking和non-blocking的区别" class="headerlink" title="blocking和non-blocking的区别"></a>blocking和non-blocking的区别</h3><p>这个概念是针对应用程序而言，是指应用程序中的线程在向操作系统发送IO请求后，是否一直等待操作系统的IO响应。如果是，那么就是阻塞式的；如果不是，那么应用程序一般会以轮询的方式以一定周期询问操作系统，直到某次获得了IO响应为止（轮序间隔应用程序线程可以做一些其他工作）。调用blocking IO会一直block住对应的线程直到操作完成，而non-blocking IO在kernel还准备数据的情况下会立刻返回。</p>
<h3 id="synchronous-IO和asynchronous-IO的区别"><a href="#synchronous-IO和asynchronous-IO的区别" class="headerlink" title="synchronous IO和asynchronous IO的区别"></a>synchronous IO和asynchronous IO的区别</h3><p>在说明synchronous IO和asynchronous IO的区别之前，需要先给出两者的定义。POSIX的定义是这样子的：</p>
<ul>
<li>A synchronous I/O operation causes the requesting process to be blocked until that I/O operation completes;</li>
<li>An asynchronous I/O operation does not cause the requesting process to be blocked;</li>
</ul>
<p>两者的区别就在于synchronous IO做”IO operation”的时候会将process阻塞。按照这个定义，之前所述的blocking IO，non-blocking IO，IO multiplexing都属于synchronous IO。</p>
<p>有人会说，non-blocking IO并没有被block啊。这里有个非常“狡猾”的地方，定义中所指的”IO operation”是指真实的IO操作，就是例子中的recvfrom这个system call。non-blocking IO在执行recvfrom这个system call的时候，如果kernel的数据没有准备好，这时候不会block线程。但是，当kernel中数据准备好的时候，recvfrom会将数据从kernel拷贝到用户内存中，这个时候线程是被block了，在这段时间内，线程是被block的。</p>
<p>而asynchronous IO则不一样，当线程发起IO 操作之后，就直接返回再也不理睬了，直到kernel发送一个信号，告诉线程说IO完成。在这整个过程中，线程完全没有被block。</p>
<h3 id="IO模型分类"><a href="#IO模型分类" class="headerlink" title="IO模型分类"></a>IO模型分类</h3><p>同步异步：</p>
<ul>
<li>同步IO： blocking IO； non-blocking IO； IO multiplexing</li>
<li>异步IO： asynchronous IO</li>
</ul>
<p>阻塞非阻塞：</p>
<ul>
<li>阻塞IO： blocking IO</li>
<li>非阻塞IO： non-blocking IO； IO multiplexing； asynchronous IO</li>
</ul>
<h3 id="Java实现"><a href="#Java实现" class="headerlink" title="Java实现"></a>Java实现</h3><p>以上这些IO工作模型，在JAVA中都能够找到对应的支持：传统的JAVA Socket套接字支持阻塞/非阻塞模式下的同步IO；JAVA NIO框架在不同操作系统下支持不同种类的多路复用IO技术（windows下的select模型、Linux下的poll/epoll模型）；JAVA AIO框架支持异步IO（windows下的IOCP和Linux使用epoll的模拟AIO）。</p>
<h3 id="注："><a href="#注：" class="headerlink" title="注："></a>注：</h3><p>上文中的示例代码只是针对各种IO模型下的Java实现示例展示，并没有使用线程池技术去处理业务逻辑。实际应用中推荐也应当使用线程池技术，用线程池去处理业务逻辑部分。</p>
<p>客户端使用何种IO技术，对整个系统架构的性能提升相关性并不大。</p>
<p>非阻塞IO模型中，报文的解析，连接的管理维护都需要额外去处理，增加了编程复杂度，一般可以借助Netty，Mina等成型的封装好的NIO类库。</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://segmentfault.com/a/1190000003063859" target="_blank" rel="external">Linux IO模式及 select、poll、epoll详解</a></p>
<p><a href="http://blog.csdn.net/yinwenjie/article/details/48472237" target="_blank" rel="external">架构设计：系统间通信 —— IO通信模型和JAVA实践</a></p>
</div><script type="text/javascript" src="/js/share.js?v=0.0.0" async></script><a data-url="https://kris-liu.github.io/2016/12/18/Java-IO模型/" data-id="ciyn6f5sx000w1e6zronx4epo" class="article-share-link">分享到</a><div class="tags"><a href="/tags/IO/">IO</a><a href="/tags/NIO/">NIO</a><a href="/tags/BIO/">BIO</a><a href="/tags/AIO/">AIO</a></div><div class="post-nav"><a href="/2016/12/24/I-O-多路复用之select、poll、epoll实现原理及对比总结/" class="pre">I/O 多路复用之select、poll、epoll实现原理及对比总结</a><a href="/2016/11/29/JUC-FutureTask-源码分析/" class="next">JUC - FutureTask 源码分析</a></div><div data-thread-key="2016/12/18/Java-IO模型/" data-title="Java IO模型" data-url="https://kris-liu.github.io/2016/12/18/Java-IO模型/" class="ds-share flat"><div class="ds-share-inline"><ul class="ds-share-icons-16"><li data-toggle="ds-share-icons-more"><a href="javascript:void(0);" class="ds-more">分享到：</a></li><li><a href="javascript:void(0);" data-service="weibo" class="ds-weibo">微博</a></li><li><a href="javascript:void(0);" data-service="qzone" class="ds-qzone">QQ空间</a></li><li><a href="javascript:void(0);" data-service="qqt" class="ds-qqt">腾讯微博</a></li><li><a href="javascript:void(0);" data-service="wechat" class="ds-wechat">微信</a></li></ul><div class="ds-share-icons-more"></div></div></div><div data-thread-key="2016/12/18/Java-IO模型/" data-title="Java IO模型" data-url="https://kris-liu.github.io/2016/12/18/Java-IO模型/" data-author-key="1" class="ds-thread"></div></div></div></div><div class="pure-u-1-4 hidden_mid_and_down"><div id="sidebar"><div class="widget"><form action="//www.google.com/search" method="get" accept-charset="utf-8" target="_blank" class="search-form"><input type="text" name="q" maxlength="20" placeholder="Search"/><input type="hidden" name="sitesearch" value="https://kris-liu.github.io"/></form></div><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"> 分类</i></div><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/Concurrent/">Concurrent</a><span class="category-list-count">8</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Git/">Git</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/IO-NIO/">IO&NIO</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/JVM/">JVM</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Java/">Java</a><span class="category-list-count">3</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Spring/">Spring</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Tomcat/">Tomcat</a><span class="category-list-count">1</span></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-star-o"> 标签</i></div><div class="tagcloud"><a href="/tags/线程池/" style="font-size: 15px;">线程池</a> <a href="/tags/Git/" style="font-size: 15px;">Git</a> <a href="/tags/NIO/" style="font-size: 15px;">NIO</a> <a href="/tags/Java/" style="font-size: 15px;">Java</a> <a href="/tags/并发/" style="font-size: 15px;">并发</a> <a href="/tags/锁/" style="font-size: 15px;">锁</a> <a href="/tags/源码/" style="font-size: 15px;">源码</a> <a href="/tags/异步/" style="font-size: 15px;">异步</a> <a href="/tags/读写锁/" style="font-size: 15px;">读写锁</a> <a href="/tags/IO/" style="font-size: 15px;">IO</a> <a href="/tags/缓存/" style="font-size: 15px;">缓存</a> <a href="/tags/BIO/" style="font-size: 15px;">BIO</a> <a href="/tags/AIO/" style="font-size: 15px;">AIO</a> <a href="/tags/JVM/" style="font-size: 15px;">JVM</a> <a href="/tags/JMM/" style="font-size: 15px;">JMM</a> <a href="/tags/内存模型/" style="font-size: 15px;">内存模型</a> <a href="/tags/Spring/" style="font-size: 15px;">Spring</a> <a href="/tags/Tomcat/" style="font-size: 15px;">Tomcat</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-file-o"> 最新文章</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2016/12/24/I-O-多路复用之select、poll、epoll实现原理及对比总结/">I/O 多路复用之select、poll、epoll实现原理及对比总结</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/12/18/Java-IO模型/">Java IO模型</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/11/29/JUC-FutureTask-源码分析/">JUC - FutureTask 源码分析</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/11/27/JUC-ThreadPoolExecutor-源码分析/">JUC - ThreadPoolExecutor 源码分析</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/11/18/ThreadLocal-源码分析/">ThreadLocal 源码分析</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/11/17/Unsafe-源码分析/">Unsafe 源码分析</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/11/15/Java-Cache-Line-伪共享及解决方案/">Java Cache Line 伪共享及解决方案</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/11/12/Java内存模型-JMM-核心概念总结/">Java内存模型(JMM)核心概念总结</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/10/16/JUC-ReentrantReadWriteLock-源码分析/">JUC - ReentrantReadWriteLock 源码分析</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/10/12/JUC-Condition-源码分析/">JUC - Condition 源码分析</a></li></ul></div><div class="widget"><div class="comments-title"><i class="fa fa-comment-o"> 最近评论</i></div><div data-num-items="5" data-show-avatars="0" data-show-time="1" data-show-admin="0" data-excerpt-length="32" data-show-title="1" class="ds-recent-comments"></div></div><div class="widget"><div class="widget-title"><i class="fa fa-external-link"> 友情链接</i></div><ul></ul><a href="http://blog.csdn.net/xx_ytm" title="我的CSDN博客" target="_blank">我的CSDN博客</a></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">© <a href="/." rel="nofollow">Kris's Blog.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/tufu9441/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/pagecho"> Cho.</a></div></div></div><a id="rocket" href="#top" class="show"></a><script type="text/javascript" src="/js/totop.js?v=0.0.0" async></script><script type="text/javascript" src="//cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.pack.js" async></script><script type="text/javascript" src="/js/fancybox.js?v=0.0.0" async></script><link rel="stylesheet" type="text/css" href="/css/jquery.fancybox.css?v=0.0.0"><script>var duoshuoQuery = {short_name:'kris-liu'};
(function() {
    var ds = document.createElement('script');
    ds.type = 'text/javascript';ds.async = true;
    ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
    ds.charset = 'UTF-8';
    (document.getElementsByTagName('head')[0]
        || document.getElementsByTagName('body')[0]).appendChild(ds);
})();
</script><script type="text/javascript" src="/js/codeblock-resizer.js?v=0.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=0.0.0"></script></div></body></html>