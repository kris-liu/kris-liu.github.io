<!DOCTYPE html><html lang="zh-CN"><head><meta name="google-site-verification" content="DVfrDhwMEodDoWVy6nv0PCpolWhBlGBSaO9hiU2r61E"><meta name="google-site-verification" content="40TgWkMJTOetJQqAMZwk5nD5rtVQRjk5i2pe6FGka5g"><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content="Liu Xin's Blog"><title>Netty源码分析 ServerBootstrap服务端启动 | Liu Xin's Blog</title><link rel="stylesheet" type="text/css" href="/css/style.css?v=0.0.0"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/normalize/7.0.0/normalize.min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/1.0.0/pure-min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/1.0.0/grids-responsive-min.css"><link rel="stylesheet" href="//cdn.bootcss.com/font-awesome/4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="//cdn.bootcss.com/jquery/3.2.1/jquery.min.js"></script><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"><script>(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','https://www.google-analytics.com/analytics.js','ga');
ga('create','UA-91282031-1','auto');ga('send','pageview');</script></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">Netty源码分析 ServerBootstrap服务端启动</h1><a id="logo" href="/.">Liu Xin's Blog</a><p class="description">Whatever you do, you have to keep moving forward!</p></div><div id="nav-menu"><a href="/." class="current"><i class="fa fa-home"> 首页</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a><a href="/about/"><i class="fa fa-user"> 关于</i></a><a href="/atom.xml"><i class="fa fa-rss"> 订阅</i></a></div></div><div id="layout" class="pure-g"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">Netty源码分析 ServerBootstrap服务端启动</h1><div class="post-meta">Apr 1, 2017<span> | </span><span class="category"><a href="/categories/Netty/">Netty</a></span></div><a data-disqus-identifier="2017/04/01/Netty-ServerBootstrap/" href="/2017/04/01/Netty-ServerBootstrap/#disqus_thread" class="disqus-comment-count"></a><div class="post-content"><blockquote>
<p>本文使用<code>netty-4.1.5.Final</code>版本源码进行分析</p>
</blockquote>
<p>ServerBootstrap是Socket服务端的启动辅助类，用户通过ServerBootstrap可以方便的创建Netty的服务端，并加以定制。下面我们看一下服务端ServerBootstrap如何启动并对启动过程的源码进行分析。</p>
<a id="more"></a>
<h2 id="ServerBootstrap服务端启动"><a href="#ServerBootstrap服务端启动" class="headerlink" title="ServerBootstrap服务端启动"></a>ServerBootstrap服务端启动</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line">EventLoopGroup bossGroup = <span class="keyword">new</span> NioEventLoopGroup(<span class="number">1</span>);</div><div class="line">EventLoopGroup workerGroup = <span class="keyword">new</span> NioEventLoopGroup();</div><div class="line"><span class="keyword">try</span> &#123;</div><div class="line">    ServerBootstrap b = <span class="keyword">new</span> ServerBootstrap();</div><div class="line">    b.group(bossGroup, workerGroup)</div><div class="line">     .channel(NioServerSocketChannel.class)</div><div class="line">     .option(ChannelOption.SO_BACKLOG, <span class="number">100</span>)</div><div class="line">     .handler(<span class="keyword">new</span> LoggingHandler(LogLevel.INFO))</div><div class="line">     .childHandler(<span class="keyword">new</span> ChannelInitializer&lt;SocketChannel&gt;() &#123;</div><div class="line">         <span class="meta">@Override</span></div><div class="line">         <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">initChannel</span><span class="params">(SocketChannel ch)</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">             ChannelPipeline p = ch.pipeline();</div><div class="line">             p.addLast(<span class="keyword">new</span> EchoServerHandler());</div><div class="line">         &#125;</div><div class="line">     &#125;);</div><div class="line"></div><div class="line">    <span class="comment">// Start the server.</span></div><div class="line">    ChannelFuture f = b.bind(PORT).sync();</div><div class="line"></div><div class="line">    <span class="comment">// Wait until the server socket is closed.</span></div><div class="line">    f.channel().closeFuture().sync();</div><div class="line">&#125; <span class="keyword">finally</span> &#123;</div><div class="line">    <span class="comment">// Shut down all event loops to terminate all threads.</span></div><div class="line">    bossGroup.shutdownGracefully();</div><div class="line">    workerGroup.shutdownGracefully();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>创建ServerBootstrap实例，绑定用于监听TCP连接的bossGroup和用于处理I/O事件及task任务的workerGroup，并设置其他相关定制参数，最后绑定一个监听TCP连接的端口，就完成了启动Netty服务端的代码。</p>
<h2 id="ServerBootstrap服务端启动源码分析"><a href="#ServerBootstrap服务端启动源码分析" class="headerlink" title="ServerBootstrap服务端启动源码分析"></a>ServerBootstrap服务端启动源码分析</h2><h3 id="创建ServerBootstrap实例"><a href="#创建ServerBootstrap实例" class="headerlink" title="创建ServerBootstrap实例"></a>创建ServerBootstrap实例</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ServerBootstrap b = <span class="keyword">new</span> ServerBootstrap();</div></pre></td></tr></table></figure>
<h3 id="设置ServerBootstrap参数"><a href="#设置ServerBootstrap参数" class="headerlink" title="设置ServerBootstrap参数"></a>设置ServerBootstrap参数</h3><p>绑定Reactor线程池</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> ServerBootstrap <span class="title">group</span><span class="params">(EventLoopGroup parentGroup, EventLoopGroup childGroup)</span> </span>&#123;</div><div class="line">    <span class="keyword">super</span>.group(parentGroup);</div><div class="line">    <span class="keyword">if</span> (childGroup == <span class="keyword">null</span>) &#123;</div><div class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException(<span class="string">"childGroup"</span>);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.childGroup != <span class="keyword">null</span>) &#123;</div><div class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"childGroup set already"</span>);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">this</span>.childGroup = childGroup;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> B <span class="title">group</span><span class="params">(EventLoopGroup group)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (group == <span class="keyword">null</span>) &#123;</div><div class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException(<span class="string">"group"</span>);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.group != <span class="keyword">null</span>) &#123;</div><div class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"group set already"</span>);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">this</span>.group = group;</div><div class="line">    <span class="keyword">return</span> (B) <span class="keyword">this</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>parentGroup线程组主要用于处理TCP连接请求，childGroup线程组主要用于I/O读写以及task执行。</p>
<p>设置channel类型，用于根据class类型反射创建对应channel</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div></pre></td><td class="code"><pre><div class="line">    <span class="function"><span class="keyword">public</span> B <span class="title">channel</span><span class="params">(Class&lt;? extends C&gt; channelClass)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (channelClass == <span class="keyword">null</span>) &#123;</div><div class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException(<span class="string">"channelClass"</span>);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> channelFactory(<span class="keyword">new</span> ReflectiveChannelFactory&lt;C&gt;(channelClass));</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">public</span> B <span class="title">channelFactory</span><span class="params">(ChannelFactory&lt;? extends C&gt; channelFactory)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (channelFactory == <span class="keyword">null</span>) &#123;</div><div class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException(<span class="string">"channelFactory"</span>);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.channelFactory != <span class="keyword">null</span>) &#123;</div><div class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"channelFactory set already"</span>);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">this</span>.channelFactory = channelFactory;</div><div class="line">        <span class="keyword">return</span> (B) <span class="keyword">this</span>;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReflectiveChannelFactory</span>&lt;<span class="title">T</span> <span class="keyword">extends</span> <span class="title">Channel</span>&gt; <span class="keyword">implements</span> <span class="title">ChannelFactory</span>&lt;<span class="title">T</span>&gt; </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Class&lt;? extends T&gt; clazz;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ReflectiveChannelFactory</span><span class="params">(Class&lt;? extends T&gt; clazz)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (clazz == <span class="keyword">null</span>) &#123;</div><div class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException(<span class="string">"clazz"</span>);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">this</span>.clazz = clazz;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">newChannel</span><span class="params">()</span> </span>&#123;<span class="comment">//通过反射创建channel</span></div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            <span class="keyword">return</span> clazz.newInstance();</div><div class="line">        &#125; <span class="keyword">catch</span> (Throwable t) &#123;</div><div class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> ChannelException(<span class="string">"Unable to create Channel from class "</span> + clazz, t);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> StringUtil.simpleClassName(clazz) + <span class="string">".class"</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>根据channel的类型，创建一个生产channel的工厂，用于通过channel类型反射创建对应的channel，服务端一般使用<code>NioServerSocketChannel.class</code>。</p>
<p>设置channel参数</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> &lt;T&gt; <span class="function">B <span class="title">option</span><span class="params">(ChannelOption&lt;T&gt; option, T value)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (option == <span class="keyword">null</span>) &#123;</div><div class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException(<span class="string">"option"</span>);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">if</span> (value == <span class="keyword">null</span>) &#123;</div><div class="line">        <span class="keyword">synchronized</span> (options) &#123;</div><div class="line">            options.remove(option);</div><div class="line">        &#125;</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        <span class="keyword">synchronized</span> (options) &#123;</div><div class="line">            options.put(option, value);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> (B) <span class="keyword">this</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>设置handler</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> B <span class="title">handler</span><span class="params">(ChannelHandler handler)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (handler == <span class="keyword">null</span>) &#123;</div><div class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException(<span class="string">"handler"</span>);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">this</span>.handler = handler;</div><div class="line">    <span class="keyword">return</span> (B) <span class="keyword">this</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>为NioServerSocketChannel设置ChannelHandler。</p>
<p>设置子handler</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> ServerBootstrap <span class="title">childHandler</span><span class="params">(ChannelHandler childHandler)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (childHandler == <span class="keyword">null</span>) &#123;</div><div class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException(<span class="string">"childHandler"</span>);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">this</span>.childHandler = childHandler;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>每个NioSocketChannel设置ChannelHandler，ChannelHandler是netty提供给用户定制和扩展的关键接口，用户可以通过自定义ChannelHandler，添加具体的业务逻辑处理。</p>
<h3 id="启动ServerBootstrap的核心逻辑源码分析"><a href="#启动ServerBootstrap的核心逻辑源码分析" class="headerlink" title="启动ServerBootstrap的核心逻辑源码分析"></a>启动ServerBootstrap的核心逻辑源码分析</h3><p>绑定一个监听端口来启动服务端ServerBootstrap，绑定操作不仅要绑定端口并设置监听，首先需要将Channel初始化并注册到eventLoop中。</p>
<p>ServerBootstrap启动的核心逻辑总共分三步操作：</p>
<ol>
<li>初始化</li>
<li>注册</li>
<li>绑定端口</li>
</ol>
<p>首先看下启动过程的主干逻辑，然后再具体分析每一步操作的具体逻辑：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> ChannelFuture <span class="title">bind</span><span class="params">(SocketAddress localAddress)</span> </span>&#123;</div><div class="line">    validate();<span class="comment">//参数基本校验</span></div><div class="line">    <span class="keyword">if</span> (localAddress == <span class="keyword">null</span>) &#123;</div><div class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException(<span class="string">"localAddress"</span>);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> doBind(localAddress);<span class="comment">//发起绑定并返回绑定结果</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> ChannelFuture <span class="title">doBind</span><span class="params">(<span class="keyword">final</span> SocketAddress localAddress)</span> </span>&#123;</div><div class="line">    <span class="keyword">final</span> ChannelFuture regFuture = initAndRegister();<span class="comment">//初始化NioServerSocketChannel并注册到bossGroup的eventLoop上</span></div><div class="line">    <span class="keyword">final</span> Channel channel = regFuture.channel();</div><div class="line">    <span class="keyword">if</span> (regFuture.cause() != <span class="keyword">null</span>) &#123;</div><div class="line">        <span class="keyword">return</span> regFuture;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (regFuture.isDone()) &#123;<span class="comment">//如果注册到bossGroup上已完成则直接进行绑定操作</span></div><div class="line">        <span class="comment">// At this point we know that the registration was complete and successful.</span></div><div class="line">        ChannelPromise promise = channel.newPromise();</div><div class="line">        doBind0(regFuture, channel, localAddress, promise);<span class="comment">//绑定端口</span></div><div class="line">        <span class="keyword">return</span> promise;</div><div class="line">    &#125; <span class="keyword">else</span> &#123;<span class="comment">//如果注册到bossGroup上还未完成，则添加Listener当执行完注册操作后再回调Listener进行端口绑定操作</span></div><div class="line">        <span class="comment">// Registration future is almost always fulfilled already, but just in case it's not.</span></div><div class="line">        <span class="keyword">final</span> PendingRegistrationPromise promise = <span class="keyword">new</span> PendingRegistrationPromise(channel);</div><div class="line">        regFuture.addListener(<span class="keyword">new</span> ChannelFutureListener() &#123;</div><div class="line">            <span class="meta">@Override</span></div><div class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">operationComplete</span><span class="params">(ChannelFuture future)</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">                Throwable cause = future.cause();</div><div class="line">                <span class="keyword">if</span> (cause != <span class="keyword">null</span>) &#123;</div><div class="line">                    <span class="comment">// Registration on the EventLoop failed so fail the ChannelPromise directly to not cause an</span></div><div class="line">                    <span class="comment">// IllegalStateException once we try to access the EventLoop of the Channel.</span></div><div class="line">                    promise.setFailure(cause);</div><div class="line">                &#125; <span class="keyword">else</span> &#123;</div><div class="line">                    <span class="comment">// Registration was successful, so set the correct executor to use.</span></div><div class="line">                    <span class="comment">// See https://github.com/netty/netty/issues/2586</span></div><div class="line">                    promise.registered();</div><div class="line"></div><div class="line">                    doBind0(regFuture, channel, localAddress, promise);<span class="comment">//绑定端口</span></div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;);</div><div class="line">        <span class="keyword">return</span> promise;<span class="comment">//外部可以用过promise得到是否绑定完成的结果，或者阻塞直到完成绑定。</span></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>首先初始化NioServerSocketChannel并注册到bossGroup的eventLoop上，当NioServerSocketChannel已经执行完成注册操作，则直接进行端口绑定操作，否则添加Listener当执行完注册操作后再回调Listener进行端口绑定操作。</p>
<p>初始化NioServerSocketChannel并注册到bossGroup的eventLoop上</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">final</span> ChannelFuture <span class="title">initAndRegister</span><span class="params">()</span> </span>&#123;</div><div class="line">    Channel channel = <span class="keyword">null</span>;</div><div class="line">    <span class="keyword">try</span> &#123;</div><div class="line">        channel = channelFactory.newChannel();<span class="comment">//通过创建ServerBootstrap时设置的channel创建工厂通过反射创建对应的channel，服务端一般是NioServerSocketChannel</span></div><div class="line">        init(channel);<span class="comment">//初始化channel</span></div><div class="line">    &#125; <span class="keyword">catch</span> (Throwable t) &#123;</div><div class="line">        <span class="keyword">if</span> (channel != <span class="keyword">null</span>) &#123;</div><div class="line">            <span class="comment">// channel can be null if newChannel crashed (eg SocketException("too many open files"))</span></div><div class="line">            channel.unsafe().closeForcibly();</div><div class="line">        &#125;</div><div class="line">        <span class="comment">// as the Channel is not registered yet we need to force the usage of the GlobalEventExecutor</span></div><div class="line">        <span class="keyword">return</span> <span class="keyword">new</span> DefaultChannelPromise(channel, GlobalEventExecutor.INSTANCE).setFailure(t);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    ChannelFuture regFuture = config().group().register(channel);<span class="comment">//注册channel到eventLoop上</span></div><div class="line">    <span class="keyword">if</span> (regFuture.cause() != <span class="keyword">null</span>) &#123;</div><div class="line">        <span class="keyword">if</span> (channel.isRegistered()) &#123;</div><div class="line">            channel.close();</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            channel.unsafe().closeForcibly();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// If we are here and the promise is not failed, it's one of the following cases:</span></div><div class="line">    <span class="comment">// 1) If we attempted registration from the event loop, the registration has been completed at this point.</span></div><div class="line">    <span class="comment">//    i.e. It's safe to attempt bind() or connect() now because the channel has been registered.</span></div><div class="line">    <span class="comment">// 2) If we attempted registration from the other thread, the registration request has been successfully</span></div><div class="line">    <span class="comment">//    added to the event loop's task queue for later execution.</span></div><div class="line">    <span class="comment">//    i.e. It's safe to attempt bind() or connect() now:</span></div><div class="line">    <span class="comment">//         because bind() or connect() will be executed *after* the scheduled registration task is executed</span></div><div class="line">    <span class="comment">//         because register(), bind(), and connect() are all bound to the same thread.</span></div><div class="line"></div><div class="line">    <span class="keyword">return</span> regFuture;<span class="comment">//返回注册操作的结果，用于判断是否已注册完成</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>创建并初始化NioServerSocketChannel，然后将其注册到bossGroup的eventLoop上去，并返回注册操作的结果。</p>
<h4 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">(Channel channel)</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">    <span class="keyword">final</span> Map&lt;ChannelOption&lt;?&gt;, Object&gt; options = options0();<span class="comment">//设置channel的参数</span></div><div class="line">    <span class="keyword">synchronized</span> (options) &#123;</div><div class="line">        channel.config().setOptions(options);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">final</span> Map&lt;AttributeKey&lt;?&gt;, Object&gt; attrs = attrs0();<span class="comment">//设置channel的附加属性</span></div><div class="line">    <span class="keyword">synchronized</span> (attrs) &#123;</div><div class="line">        <span class="keyword">for</span> (Entry&lt;AttributeKey&lt;?&gt;, Object&gt; e: attrs.entrySet()) &#123;</div><div class="line">            <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</div><div class="line">            AttributeKey&lt;Object&gt; key = (AttributeKey&lt;Object&gt;) e.getKey();</div><div class="line">            channel.attr(key).set(e.getValue());</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    ChannelPipeline p = channel.pipeline();<span class="comment">//获取负责处理网络事件的职责链，用来管理和执行ChannelHandler</span></div><div class="line"></div><div class="line">    <span class="comment">//处理ServerBootstrapAcceptor的参数</span></div><div class="line">    <span class="keyword">final</span> EventLoopGroup currentChildGroup = childGroup;<span class="comment">//workGroup，处理I/O相关操作的线程组</span></div><div class="line">    <span class="keyword">final</span> ChannelHandler currentChildHandler = childHandler;<span class="comment">//创建ServerBootstrap时设置的childHandler</span></div><div class="line">    <span class="keyword">final</span> Entry&lt;ChannelOption&lt;?&gt;, Object&gt;[] currentChildOptions;</div><div class="line">    <span class="keyword">final</span> Entry&lt;AttributeKey&lt;?&gt;, Object&gt;[] currentChildAttrs;</div><div class="line">    <span class="keyword">synchronized</span> (childOptions) &#123;</div><div class="line">        currentChildOptions = childOptions.entrySet().toArray(newOptionArray(childOptions.size()));<span class="comment">//创建ServerBootstrap时设置的socket属性childOptions</span></div><div class="line">    &#125;</div><div class="line">    <span class="keyword">synchronized</span> (childAttrs) &#123;</div><div class="line">        currentChildAttrs = childAttrs.entrySet().toArray(newAttrArray(childAttrs.size()));<span class="comment">//创建ServerBootstrap时设置的附加参数childAttrs</span></div><div class="line">    &#125;</div><div class="line"></div><div class="line">    p.addLast(<span class="keyword">new</span> ChannelInitializer&lt;Channel&gt;() &#123;<span class="comment">//NioServerSocketChannel注册的时候会调用initChannel方法设置ChannelHandler</span></div><div class="line">        <span class="meta">@Override</span></div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">initChannel</span><span class="params">(Channel ch)</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">            <span class="keyword">final</span> ChannelPipeline pipeline = ch.pipeline();</div><div class="line">            ChannelHandler handler = config.handler();<span class="comment">//将创建ServerBootstrap时设置的handler添加到NioServerSocketChannel的责任链上</span></div><div class="line">            <span class="keyword">if</span> (handler != <span class="keyword">null</span>) &#123;</div><div class="line">                pipeline.addLast(handler);</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            <span class="comment">// We add this handler via the EventLoop as the user may have used a ChannelInitializer as handler.</span></div><div class="line">            <span class="comment">// In this case the initChannel(...) method will only be called after this method returns. Because</span></div><div class="line">            <span class="comment">// of this we need to ensure we add our handler in a delayed fashion so all the users handler are</span></div><div class="line">            <span class="comment">// placed in front of the ServerBootstrapAcceptor.</span></div><div class="line">            ch.eventLoop().execute(<span class="keyword">new</span> Runnable() &#123;<span class="comment">//封装成task任务交由channel对应的eventLoop线程来执行，防止并发操作channel</span></div><div class="line">                <span class="meta">@Override</span></div><div class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">                    pipeline.addLast(<span class="keyword">new</span> ServerBootstrapAcceptor(</div><div class="line">                            currentChildGroup, currentChildHandler, currentChildOptions, currentChildAttrs));<span class="comment">//添加ServerBootstrapAcceptor，主要用于接收TCP连接后初始化并注册NioSocketChannel到workGroup</span></div><div class="line">                &#125;</div><div class="line">            &#125;);</div><div class="line">        &#125;</div><div class="line">    &#125;);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>ServerBootstrapAcceptor主要用于接收TCP连接后初始化并注册NioSocketChannel到workGroup</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ServerBootstrapAcceptor</span> <span class="keyword">extends</span> <span class="title">ChannelInboundHandlerAdapter</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> EventLoopGroup childGroup;<span class="comment">//workGroup，处理I/O相关操作的线程组</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ChannelHandler childHandler;<span class="comment">//创建ServerBootstrap时设置的childHandler</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Entry&lt;ChannelOption&lt;?&gt;, Object&gt;[] childOptions;<span class="comment">//创建ServerBootstrap时设置的socket属性childOptions</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Entry&lt;AttributeKey&lt;?&gt;, Object&gt;[] childAttrs;<span class="comment">//创建ServerBootstrap时设置的附加参数childAttrs</span></div><div class="line"></div><div class="line">    ServerBootstrapAcceptor(</div><div class="line">            EventLoopGroup childGroup, ChannelHandler childHandler,</div><div class="line">            Entry&lt;ChannelOption&lt;?&gt;, Object&gt;[] childOptions, Entry&lt;AttributeKey&lt;?&gt;, Object&gt;[] childAttrs) &#123;</div><div class="line">        <span class="keyword">this</span>.childGroup = childGroup;</div><div class="line">        <span class="keyword">this</span>.childHandler = childHandler;</div><div class="line">        <span class="keyword">this</span>.childOptions = childOptions;</div><div class="line">        <span class="keyword">this</span>.childAttrs = childAttrs;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelRead</span><span class="params">(ChannelHandlerContext ctx, Object msg)</span> </span>&#123;<span class="comment">//Channel关心的网络事件`SelectionKey.OP_READ`或者`SelectionKey.OP_ACCEPT`发生都会触发read事件，进而调用责任链上ChannelHandler的channelRead相关逻辑，此处是因为`SelectionKey.OP_ACCEPT`事件导致的channelRead事件被触发。</span></div><div class="line">    </div><div class="line">        <span class="keyword">final</span> Channel child = (Channel) msg;<span class="comment">//msg即NioSocketChannel</span></div><div class="line"></div><div class="line">        child.pipeline().addLast(childHandler);<span class="comment">//为NioSocketChannel的责任链上添加childHandler</span></div><div class="line"></div><div class="line">        <span class="keyword">for</span> (Entry&lt;ChannelOption&lt;?&gt;, Object&gt; e: childOptions) &#123;<span class="comment">//为NioSocketChannel添加socket属性Option</span></div><div class="line">            <span class="keyword">try</span> &#123;</div><div class="line">                <span class="keyword">if</span> (!child.config().setOption((ChannelOption&lt;Object&gt;) e.getKey(), e.getValue())) &#123;</div><div class="line">                    logger.warn(<span class="string">"Unknown channel option: "</span> + e);</div><div class="line">                &#125;</div><div class="line">            &#125; <span class="keyword">catch</span> (Throwable t) &#123;</div><div class="line">                logger.warn(<span class="string">"Failed to set a channel option: "</span> + child, t);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">for</span> (Entry&lt;AttributeKey&lt;?&gt;, Object&gt; e: childAttrs) &#123;<span class="comment">//为NioSocketChannel添加附加参数attr</span></div><div class="line"></div><div class="line">            child.attr((AttributeKey&lt;Object&gt;) e.getKey()).set(e.getValue());</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            childGroup.register(child).addListener(<span class="keyword">new</span> ChannelFutureListener() &#123;<span class="comment">//将child注册到workGroup线程组上并添加Listener用于处理注册失败后的关闭操作</span></div><div class="line">                <span class="meta">@Override</span></div><div class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">operationComplete</span><span class="params">(ChannelFuture future)</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">                    <span class="keyword">if</span> (!future.isSuccess()) &#123;</div><div class="line">                        forceClose(child, future.cause());</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line">            &#125;);</div><div class="line">        &#125; <span class="keyword">catch</span> (Throwable t) &#123;</div><div class="line">            forceClose(child, t);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">forceClose</span><span class="params">(Channel child, Throwable t)</span> </span>&#123;</div><div class="line">        child.unsafe().closeForcibly();</div><div class="line">        logger.warn(<span class="string">"Failed to register an accepted channel: "</span> + child, t);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">exceptionCaught</span><span class="params">(ChannelHandlerContext ctx, Throwable cause)</span> <span class="keyword">throws</span> Exception </span>&#123;<span class="comment">//当发生链路异常，则关闭channel的AutoRead属性，并设置定时task在1s后恢复AutoRead属性，关闭AutoRead将导致不再监听新的连接请求，用于对java.io.IOException: Too many open files进行处理。</span></div><div class="line">        <span class="keyword">final</span> ChannelConfig config = ctx.channel().config();</div><div class="line">        <span class="keyword">if</span> (config.isAutoRead()) &#123;</div><div class="line">            <span class="comment">// stop accept new connections for 1 second to allow the channel to recover</span></div><div class="line">            <span class="comment">// See https://github.com/netty/netty/issues/1328</span></div><div class="line">            config.setAutoRead(<span class="keyword">false</span>);</div><div class="line">            ctx.channel().eventLoop().schedule(<span class="keyword">new</span> Runnable() &#123;<span class="comment">//定时task需要提交给channel对应的eventLoop线程处理</span></div><div class="line">                <span class="meta">@Override</span></div><div class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">                    config.setAutoRead(<span class="keyword">true</span>);</div><div class="line">                &#125;</div><div class="line">            &#125;, <span class="number">1</span>, TimeUnit.SECONDS);</div><div class="line">        &#125;</div><div class="line">        <span class="comment">// still let the exceptionCaught event flow through the pipeline to give the user</span></div><div class="line">        <span class="comment">// a chance to do something with it</span></div><div class="line">        ctx.fireExceptionCaught(cause);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>Channel关心的网络事件<code>SelectionKey.OP_READ</code>或者<code>SelectionKey.OP_ACCEPT</code>发生都会触发read事件，进而调用责任链上ChannelHandler的channelRead相关逻辑，此处是因为<code>SelectionKey.OP_ACCEPT</code>事件导致的ServerBootstrapAcceptor的channelRead事件被触发。这里主要是用于accept到连接后，对新建的NioSocketChannel进行属性设置并注册到workGroup线程组。</p>
<h4 id="注册"><a href="#注册" class="headerlink" title="注册"></a>注册</h4><p>注册NioServerSocketChannel，从bossGroup选择一个eventLoop线程，将NioServerSocketChannel注册到该eventLoop的selector上，通过channel获取unsafe，进而操作底层NIO的api进行注册操作</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> ChannelFuture <span class="title">register</span><span class="params">(<span class="keyword">final</span> ChannelPromise promise)</span> </span>&#123;</div><div class="line">    ObjectUtil.checkNotNull(promise, <span class="string">"promise"</span>);</div><div class="line">    promise.channel().unsafe().register(<span class="keyword">this</span>, promise);</div><div class="line">    <span class="keyword">return</span> promise;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>unsafe的register方法，判断当前线程是否是对应channel的eventLoop线程来决定是直接执行register0还是封装一个task交由对应的eventLoop来执行register0</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">register</span><span class="params">(EventLoop eventLoop, <span class="keyword">final</span> ChannelPromise promise)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (eventLoop == <span class="keyword">null</span>) &#123;</div><div class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException(<span class="string">"eventLoop"</span>);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">if</span> (isRegistered()) &#123;</div><div class="line">        promise.setFailure(<span class="keyword">new</span> IllegalStateException(<span class="string">"registered to an event loop already"</span>));</div><div class="line">        <span class="keyword">return</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">if</span> (!isCompatible(eventLoop)) &#123;</div><div class="line">        promise.setFailure(</div><div class="line">                <span class="keyword">new</span> IllegalStateException(<span class="string">"incompatible event loop type: "</span> + eventLoop.getClass().getName()));</div><div class="line">        <span class="keyword">return</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    AbstractChannel.<span class="keyword">this</span>.eventLoop = eventLoop;</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (eventLoop.inEventLoop()) &#123;<span class="comment">//判断当前线程是否是对应的eventLoop线程来决定是直接执行register0还是封装一个task交由对应的eventLoop来执行</span></div><div class="line">        register0(promise);</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            eventLoop.execute(<span class="keyword">new</span> Runnable() &#123;<span class="comment">//提交task执行register0</span></div><div class="line">                <span class="meta">@Override</span></div><div class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">                    register0(promise);</div><div class="line">                &#125;</div><div class="line">            &#125;);</div><div class="line">        &#125; <span class="keyword">catch</span> (Throwable t) &#123;</div><div class="line">            logger.warn(</div><div class="line">                    <span class="string">"Force-closing a channel whose registration task was not accepted by an event loop: &#123;&#125;"</span>,</div><div class="line">                    AbstractChannel.<span class="keyword">this</span>, t);</div><div class="line">            closeForcibly();</div><div class="line">            closeFuture.setClosed();</div><div class="line">            safeSetFailure(promise, t);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">register0</span><span class="params">(ChannelPromise promise)</span> </span>&#123;</div><div class="line">    <span class="keyword">try</span> &#123;</div><div class="line">        <span class="comment">// check if the channel is still open as it could be closed in the mean time when the register</span></div><div class="line">        <span class="comment">// call was outside of the eventLoop</span></div><div class="line">        <span class="keyword">if</span> (!promise.setUncancellable() || !ensureOpen(promise)) &#123;</div><div class="line">            <span class="keyword">return</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">boolean</span> firstRegistration = neverRegistered;<span class="comment">//是否第一次注册</span></div><div class="line">        doRegister();<span class="comment">//调用底层NIO的api执行注册操作</span></div><div class="line">        neverRegistered = <span class="keyword">false</span>;<span class="comment">//标识已经注册过一次</span></div><div class="line">        registered = <span class="keyword">true</span>;<span class="comment">////标识已经注册的状态</span></div><div class="line"></div><div class="line">        <span class="comment">// Ensure we call handlerAdded(...) before we actually notify the promise. This is needed as the</span></div><div class="line">        <span class="comment">// user may already fire events through the pipeline in the ChannelFutureListener.</span></div><div class="line">        pipeline.invokeHandlerAddedIfNeeded();<span class="comment">//最终会调用ChannelInitializer的handlerAdded方法，进而调用ChannelInitializer的initChannel方法初始化定制的ChannelHandler</span></div><div class="line"></div><div class="line">        safeSetSuccess(promise);<span class="comment">//设置promise结果为成功</span></div><div class="line">        pipeline.fireChannelRegistered();<span class="comment">//触发fireChannelRegistered事件，该方法也会调用invokeHandlerAddedIfNeeded()，不过通过状态位保证了invokeHandlerAddedIfNeeded只会执行一次，该方法主要是用于传播注册完成事件</span></div><div class="line">        <span class="comment">// Only fire a channelActive if the channel has never been registered. This prevents firing</span></div><div class="line">        <span class="comment">// multiple channel actives if the channel is deregistered and re-registered.</span></div><div class="line">        <span class="keyword">if</span> (isActive()) &#123;<span class="comment">//channel状态是否已绑定或已连接</span></div><div class="line">            <span class="keyword">if</span> (firstRegistration) &#123;<span class="comment">//第一次注册需要触发fireChannelActive事件来设置监听位</span></div><div class="line">                pipeline.fireChannelActive();</div><div class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (config().isAutoRead()) &#123;<span class="comment">//不是第一次注册，但是AutoRead，也需要设置监听位</span></div><div class="line">                <span class="comment">// This channel was registered before and autoRead() is set. This means we need to begin read</span></div><div class="line">                <span class="comment">// again so that we process inbound data.</span></div><div class="line">                <span class="comment">//</span></div><div class="line">                <span class="comment">// See https://github.com/netty/netty/issues/4805</span></div><div class="line">                beginRead();<span class="comment">//设置监听位</span></div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125; <span class="keyword">catch</span> (Throwable t) &#123;</div><div class="line">        <span class="comment">// Close the channel directly to avoid FD leak.</span></div><div class="line">        closeForcibly();</div><div class="line">        closeFuture.setClosed();</div><div class="line">        safeSetFailure(promise, t);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>调用底层NIO的api执行注册操作</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doRegister</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;<span class="comment">//调用底层NIO的api执行注册操作</span></div><div class="line">    <span class="keyword">boolean</span> selected = <span class="keyword">false</span>;</div><div class="line">    <span class="keyword">for</span> (;;) &#123;</div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            selectionKey = javaChannel().register(eventLoop().selector, <span class="number">0</span>, <span class="keyword">this</span>);<span class="comment">//此处没有设置监听位，后续会通过fireChannelActive事件传播到HeadContext中再根据channel类型来设置需要的监听位</span></div><div class="line">            <span class="keyword">return</span>;</div><div class="line">        &#125; <span class="keyword">catch</span> (CancelledKeyException e) &#123;</div><div class="line">            <span class="keyword">if</span> (!selected) &#123;</div><div class="line">                <span class="comment">// Force the Selector to select now as the "canceled" SelectionKey may still be</span></div><div class="line">                <span class="comment">// cached and not removed because no Select.select(..) operation was called yet.</span></div><div class="line">                eventLoop().selectNow();</div><div class="line">                selected = <span class="keyword">true</span>;</div><div class="line">            &#125; <span class="keyword">else</span> &#123;</div><div class="line">                <span class="comment">// We forced a select operation on the selector before but the SelectionKey is still cached</span></div><div class="line">                <span class="comment">// for whatever reason. JDK bug ?</span></div><div class="line">                <span class="keyword">throw</span> e;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="绑定端口"><a href="#绑定端口" class="headerlink" title="绑定端口"></a>绑定端口</h4><p>提交注册后回到doBind端口绑定方法，当NioServerSocketChannel已经执行完成注册操作，则直接进行端口绑定操作，否则添加Listener当执行完注册操作后再回调Listener进行端口绑定操作，绑定操作需要操作channel，所以需要封装成task任务交由channel对应的eventLoop线程执行其bind方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">doBind0</span><span class="params">(</span></span></div><div class="line">        <span class="keyword">final</span> ChannelFuture regFuture, <span class="keyword">final</span> Channel channel,</div><div class="line">        <span class="keyword">final</span> SocketAddress localAddress, <span class="keyword">final</span> ChannelPromise promise) &#123;</div><div class="line"></div><div class="line">    <span class="comment">// This method is invoked before channelRegistered() is triggered.  Give user handlers a chance to set up</span></div><div class="line">    <span class="comment">// the pipeline in its channelRegistered() implementation.</span></div><div class="line">    channel.eventLoop().execute(<span class="keyword">new</span> Runnable() &#123;<span class="comment">//封装成task任务交由channel对应的eventLoop线程来执行，防止并发操作channel</span></div><div class="line">        <span class="meta">@Override</span></div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">            <span class="keyword">if</span> (regFuture.isSuccess()) &#123;<span class="comment">//注册成功才需要绑定</span></div><div class="line">                channel.bind(localAddress, promise).addListener(ChannelFutureListener.CLOSE_ON_FAILURE);<span class="comment">//执行绑定操作，Listener用于处理bind失败时的close操作</span></div><div class="line">            &#125; <span class="keyword">else</span> &#123;</div><div class="line">                promise.setFailure(regFuture.cause());</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(Runnable task)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (task == <span class="keyword">null</span>) &#123;</div><div class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException(<span class="string">"task"</span>);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">boolean</span> inEventLoop = inEventLoop();</div><div class="line">    <span class="keyword">if</span> (inEventLoop) &#123;<span class="comment">//如果当前线程是EventLoop线程，直接将任务提交到队列，否则需要启动EventLoop线程再提交任务</span></div><div class="line">        addTask(task);</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        startThread();<span class="comment">//当前线程不是EventLoop线程，则看是否需要先启动EventLoop的线程</span></div><div class="line">        addTask(task);</div><div class="line">        <span class="keyword">if</span> (isShutdown() &amp;&amp; removeTask(task)) &#123;</div><div class="line">            reject();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (!addTaskWakesUp &amp;&amp; wakesUpForTask(task)) &#123;</div><div class="line">        wakeup(inEventLoop);<span class="comment">//唤醒Selector，进而唤醒EventLoop线程来处理task任务</span></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>为了防止并发操作channel，需要由channel对应的eventLoop线程执行bind操作，此处将bind操作封装成task任务交由对应的eventLoop线程执行bind操作。</p>
<p>从责任链中获取ChannelOutboundHandler执行bind方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> ChannelFuture <span class="title">bind</span><span class="params">(<span class="keyword">final</span> SocketAddress localAddress, <span class="keyword">final</span> ChannelPromise promise)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (localAddress == <span class="keyword">null</span>) &#123;</div><div class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException(<span class="string">"localAddress"</span>);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">if</span> (!validatePromise(promise, <span class="keyword">false</span>)) &#123;</div><div class="line">        <span class="comment">// cancelled</span></div><div class="line">        <span class="keyword">return</span> promise;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">final</span> AbstractChannelHandlerContext next = findContextOutbound();<span class="comment">//从责任链中获取ChannelOutboundHandler</span></div><div class="line">    EventExecutor executor = next.executor();</div><div class="line">    <span class="keyword">if</span> (executor.inEventLoop()) &#123;<span class="comment">//如果当前线程是channel对应的EventLoop线程，则直接执行，否则封装成task交由channel对应的EventLoop线程执行invokeBind方法</span></div><div class="line">        next.invokeBind(localAddress, promise);</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        safeExecute(executor, <span class="keyword">new</span> Runnable() &#123;</div><div class="line">            <span class="meta">@Override</span></div><div class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">                next.invokeBind(localAddress, promise);</div><div class="line">            &#125;</div><div class="line">        &#125;, promise, <span class="keyword">null</span>);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> promise;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">invokeBind</span><span class="params">(SocketAddress localAddress, ChannelPromise promise)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (invokeHandler()) &#123;</div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            ((ChannelOutboundHandler) handler()).bind(<span class="keyword">this</span>, localAddress, promise);</div><div class="line">        &#125; <span class="keyword">catch</span> (Throwable t) &#123;</div><div class="line">            notifyOutboundHandlerException(t, promise);</div><div class="line">        &#125;</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        bind(localAddress, promise);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>绑定需要用的ChannelOutboundHandler是责任链的头部ChannelHandler：HeadContext</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">bind</span><span class="params">(</span></span></div><div class="line">        ChannelHandlerContext ctx, SocketAddress localAddress, ChannelPromise promise)</div><div class="line">        <span class="keyword">throws</span> Exception &#123;</div><div class="line">    unsafe.bind(localAddress, promise);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>最终调用unsafe的bind方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">bind</span><span class="params">(<span class="keyword">final</span> SocketAddress localAddress, <span class="keyword">final</span> ChannelPromise promise)</span> </span>&#123;</div><div class="line">    assertEventLoop();</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (!promise.setUncancellable() || !ensureOpen(promise)) &#123;</div><div class="line">        <span class="keyword">return</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// See: https://github.com/netty/netty/issues/576</span></div><div class="line">    <span class="keyword">if</span> (Boolean.TRUE.equals(config().getOption(ChannelOption.SO_BROADCAST)) &amp;&amp;</div><div class="line">        localAddress <span class="keyword">instanceof</span> InetSocketAddress &amp;&amp;</div><div class="line">        !((InetSocketAddress) localAddress).getAddress().isAnyLocalAddress() &amp;&amp;</div><div class="line">        !PlatformDependent.isWindows() &amp;&amp; !PlatformDependent.isRoot()) &#123;</div><div class="line">        <span class="comment">// Warn a user about the fact that a non-root user can't receive a</span></div><div class="line">        <span class="comment">// broadcast packet on *nix if the socket is bound on non-wildcard address.</span></div><div class="line">        logger.warn(</div><div class="line">                <span class="string">"A non-root user can't receive a broadcast packet if the socket "</span> +</div><div class="line">                <span class="string">"is not bound to a wildcard address; binding to a non-wildcard "</span> +</div><div class="line">                <span class="string">"address ("</span> + localAddress + <span class="string">") anyway as requested."</span>);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">boolean</span> wasActive = isActive();<span class="comment">//此处为完成绑定</span></div><div class="line">    <span class="keyword">try</span> &#123;</div><div class="line">        doBind(localAddress);<span class="comment">//使用原生api绑定端口</span></div><div class="line">    &#125; <span class="keyword">catch</span> (Throwable t) &#123;</div><div class="line">        safeSetFailure(promise, t);</div><div class="line">        closeIfClosed();</div><div class="line">        <span class="keyword">return</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (!wasActive &amp;&amp; isActive()) &#123;<span class="comment">//如果之前未完成绑定，执行完doBind后isbind方法返回完成绑定，则触发责任链的fireChannelActive事件，fireChannelActive最终会设置SelectionKey.OP_ACCEPT监听位</span></div><div class="line">        invokeLater(<span class="keyword">new</span> Runnable() &#123;</div><div class="line">            <span class="meta">@Override</span></div><div class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">                pipeline.fireChannelActive();</div><div class="line">            &#125;</div><div class="line">        &#125;);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    safeSetSuccess(promise);<span class="comment">//设置promise结果为已成功完成绑定操作，外部可以通过bind返回的该promise得知已完成绑定操作。</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>doBind获得底层NIO原生的ServerSocketChannel进行绑定端口操作</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doBind</span><span class="params">(SocketAddress localAddress)</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">    <span class="keyword">if</span> (PlatformDependent.javaVersion() &gt;= <span class="number">7</span>) &#123;</div><div class="line">        javaChannel().bind(localAddress, config.getBacklog());<span class="comment">//获取NIO原生的ServerSocketChannel进行绑定端口操作</span></div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        javaChannel().socket().bind(localAddress, config.getBacklog());</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>绑定完成后如果绑定成功则触发fireChannelActive方法，通过责任链会调用责任链的头部HeadContext处理，主要用于设置channel需要监听的操作位</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelActive</span><span class="params">(ChannelHandlerContext ctx)</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">    ctx.fireChannelActive();</div><div class="line"></div><div class="line">    readIfIsAutoRead();</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">readIfIsAutoRead</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (channel.config().isAutoRead()) &#123;</div><div class="line">        channel.read();</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">read</span><span class="params">(ChannelHandlerContext ctx)</span> </span>&#123;</div><div class="line">    unsafe.beginRead();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>最终调用unsafe的方法操作底层NIO的原生api做处理</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">beginRead</span><span class="params">()</span> </span>&#123;</div><div class="line">    assertEventLoop();</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (!isActive()) &#123;<span class="comment">//没有绑定或者没有完成连接，则不需要处理监听位</span></div><div class="line">        <span class="keyword">return</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">try</span> &#123;</div><div class="line">        doBeginRead();</div><div class="line">    &#125; <span class="keyword">catch</span> (<span class="keyword">final</span> Exception e) &#123;</div><div class="line">        invokeLater(<span class="keyword">new</span> Runnable() &#123;</div><div class="line">            <span class="meta">@Override</span></div><div class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">                pipeline.fireExceptionCaught(e);</div><div class="line">            &#125;</div><div class="line">        &#125;);</div><div class="line">        close(voidPromise());</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在这里根据当前channel类型设置相应的监听位，此处处理的是NioServerSocketChannel，所以最终会设置<code>SelectionKey.OP_ACCEPT</code>监听位</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doBeginRead</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">    <span class="comment">// Channel.read() or ChannelHandlerContext.read() was called</span></div><div class="line">    <span class="keyword">final</span> SelectionKey selectionKey = <span class="keyword">this</span>.selectionKey;</div><div class="line">    <span class="keyword">if</span> (!selectionKey.isValid()) &#123;</div><div class="line">        <span class="keyword">return</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    readPending = <span class="keyword">true</span>;</div><div class="line"></div><div class="line">    <span class="keyword">final</span> <span class="keyword">int</span> interestOps = selectionKey.interestOps();</div><div class="line">    <span class="keyword">if</span> ((interestOps &amp; readInterestOp) == <span class="number">0</span>) &#123;<span class="comment">//如果SelectionKey没有当前channel需要关心的监听位，则添加该监听</span></div><div class="line">        selectionKey.interestOps(interestOps | readInterestOp);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>至此，ServerBootstrap服务端启动部分源码已经分析完成。</p>
</div><script type="text/javascript" src="/js/share.js?v=0.0.0" async></script><a data-url="http://blogxin.cn/2017/04/01/Netty-ServerBootstrap/" data-id="cj8xfmqgx001sgk6z8cgw3llc" data-qrcode="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAMYAAADGCAAAAACs8KCBAAACM0lEQVR42u3aS27DMAxFUe9/0y7QUYvC8n2kUkDS1ahIDdsnA4a/68Ln/j5Pn5D//jx/P3/6ZPKRIUPGsox7eMbXEPYTMqW+PF2GDBkHMMirPD1mfP0YQHjkB0CGDBky0lcfA0hwlyFDhow+o5bekSfKkCFDRqeIrZWgaVL48VpchgwZCzLSwcB//v3B+YYMGTIWYdzhIWliLSym9/x1fxkyZGzN4IldWtymw8tadA2ySxkyZCzLuEuHrIKl62Jpstj63ZAhQ8ZSDB7UyAvx+4zHnLX1DhkyZOzKSNcjeCgk3bDayAHV4jJkyNiIwdMsQuWf8NZbsRaXIUPGdoxZZWf8sMYi2sv9ZciQsRFjVtLWaailQRwVsTJkyNiIQYIjidO18Jo2717eR4YMGQcw+KoWf1gKrgV9GTJknMBIC8haIOaNOT7slCFDxsmMWuuNh9q0YRfsjMiQIWNTxqypAi9lOysaqIiVIUPGMYx0qYKkg3PbbfEtZMiQsTgjHRnyUMiTwjQdfJlvyJAhYwsGL0TTsWItEBdXN2TIkHEMI22fdVLJfuC++t+QDBkyFmGk7XgeTPvtttaRIUPGRow7POkYgCR2/RJahgwZezPSmMbXuWpXkiEBHyHIkCFjJ0angJw1yEzTUBkyZJzJqC1A1AaTnSIW7YzIkCHjYEYKI4F7VtIpQ4YMGWnrP12e4F+QDBkyTmbUAmU6thxfX1vIkCFDxgmMTujsjxj7i2UyZMjYmvEFA8kzCImDPxAAAAAASUVORK5CYII=" class="article-share-link">分享</a><div class="tags"><a href="/tags/源码/">源码</a><a href="/tags/Netty/">Netty</a></div><div class="post-nav"><a href="/2017/04/10/Netty-Bootstrap/" class="pre">Netty源码分析 Bootstrap客户端启动</a><a href="/2017/03/20/Netty-epollbug/" class="next">Netty源码分析 解决NIO的epoll死循环bug</a></div><div id="disqus_thread"><div class="btn_click_load"><button class="disqus_click_btn">阅读评论 「请确保 disqus.com 可以正常加载」</button></div><script>var disqus_shortname = 'kris-liu';
var disqus_identifier = '2017/04/01/Netty-ServerBootstrap/';
var disqus_title = 'Netty源码分析 ServerBootstrap服务端启动';
var disqus_url = 'http://blogxin.cn/2017/04/01/Netty-ServerBootstrap/';
$('.btn_click_load').click(function() {
  (function() {
    var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
    dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
    (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
  })();
  $('.btn_click_load').css('display','none');
});
$.ajax({
  url: 'https://disqus.com/next/config.json',
  timeout: 3000,
  type: 'GET',
  success: (function() {
    var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
    dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
    (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    $('.btn_click_load').css('display','none');
  })(),
  error: function() {
    $('.btn_click_load').css('display','block');
  }
});</script><script id="dsq-count-scr" src="//kris-liu.disqus.com/count.js" async></script></div></div></div></div><div class="pure-u-1-4 hidden_mid_and_down"><div id="sidebar"><div class="widget"><form action="//www.google.com/search" method="get" accept-charset="utf-8" target="_blank" class="search-form"><input type="text" name="q" maxlength="20" placeholder="Search"/><input type="hidden" name="sitesearch" value="http://blogxin.cn"/></form></div><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"> 分类</i></div><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/Concurrent/">Concurrent</a><span class="category-list-count">8</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Git/">Git</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/IO-NIO/">IO&NIO</a><span class="category-list-count">6</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Java/">Java</a><span class="category-list-count">5</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Netty/">Netty</a><span class="category-list-count">6</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Spring/">Spring</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Tomcat/">Tomcat</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Tools/">Tools</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/架构/">架构</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/线上问题/">线上问题</a><span class="category-list-count">2</span></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-star-o"> 标签</i></div><div class="tagcloud"><a href="/tags/读写锁/" style="font-size: 15px;">读写锁</a> <a href="/tags/JVM/" style="font-size: 15px;">JVM</a> <a href="/tags/线上问题/" style="font-size: 15px;">线上问题</a> <a href="/tags/Git/" style="font-size: 15px;">Git</a> <a href="/tags/IO/" style="font-size: 15px;">IO</a> <a href="/tags/NIO/" style="font-size: 15px;">NIO</a> <a href="/tags/内存泄漏/" style="font-size: 15px;">内存泄漏</a> <a href="/tags/Java/" style="font-size: 15px;">Java</a> <a href="/tags/并发/" style="font-size: 15px;">并发</a> <a href="/tags/锁/" style="font-size: 15px;">锁</a> <a href="/tags/源码/" style="font-size: 15px;">源码</a> <a href="/tags/异步/" style="font-size: 15px;">异步</a> <a href="/tags/GC/" style="font-size: 15px;">GC</a> <a href="/tags/缓存/" style="font-size: 15px;">缓存</a> <a href="/tags/线程池/" style="font-size: 15px;">线程池</a> <a href="/tags/BIO/" style="font-size: 15px;">BIO</a> <a href="/tags/AIO/" style="font-size: 15px;">AIO</a> <a href="/tags/JMM/" style="font-size: 15px;">JMM</a> <a href="/tags/内存模型/" style="font-size: 15px;">内存模型</a> <a href="/tags/Netty/" style="font-size: 15px;">Netty</a> <a href="/tags/架构/" style="font-size: 15px;">架构</a> <a href="/tags/Tomcat/" style="font-size: 15px;">Tomcat</a> <a href="/tags/Tools/" style="font-size: 15px;">Tools</a> <a href="/tags/Spring/" style="font-size: 15px;">Spring</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-file-o"> 最近文章</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2017/09/16/java-reference/">Java的强引用，软引用，弱引用，虚引用及其使用场景</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/06/27/InternalResourceViewResolver-Memory-Leak/">InternalResourceViewResolver引起的内存泄漏问题排查</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/05/14/Space-Based-Architecture/">基于空间的架构实践及思考</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/04/23/Netty-DataPacket/">Netty源码分析 解决TCP粘包拆包问题</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/04/22/jrebel-remote-server/">IntelliJ IDEA下使用JRebel远程热部署</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/04/10/Netty-Bootstrap/">Netty源码分析 Bootstrap客户端启动</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/04/01/Netty-ServerBootstrap/">Netty源码分析 ServerBootstrap服务端启动</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/03/20/Netty-epollbug/">Netty源码分析 解决NIO的epoll死循环bug</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/03/18/Netty-NioEventLoop/">Netty源码分析 I/O线程NioEventLoop</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/03/11/Netty-ThreadModel/">Netty 线程模型</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-comment-o"> 最近评论</i></div><script type="text/javascript" src="//kris-liu.disqus.com/recent_comments_widget.js?num_items=5&amp;hide_avatars=1&amp;avatar_size=32&amp;excerpt_length=20&amp;hide_mods=1"></script></div><div class="widget"><div class="widget-title"><i class="fa fa-external-link"> 友情链接</i></div><ul></ul><a href="http://blog.csdn.net/xx_ytm" title="我的CSDN博客" target="_blank">我的CSDN博客</a></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">Copyright © 2017 <a href="/." rel="nofollow">Liu Xin's Blog.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/tufu9441/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/pagecho"> Cho.</a></div></div></div><a id="rocket" href="#top" class="show"></a><script type="text/javascript" src="/js/totop.js?v=0.0.0" async></script><script type="text/javascript" src="//cdn.bootcss.com/fancybox/3.1.20/jquery.fancybox.min.js" async></script><script type="text/javascript" src="/js/fancybox.js?v=0.0.0" async></script><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/fancybox/3.1.20/jquery.fancybox.min.css"><script type="text/javascript" src="/js/codeblock-resizer.js?v=0.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=0.0.0"></script></div></body></html>