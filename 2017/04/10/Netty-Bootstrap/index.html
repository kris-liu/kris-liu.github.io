<!DOCTYPE html><html lang="zh-CN"><head><meta name="google-site-verification" content="DVfrDhwMEodDoWVy6nv0PCpolWhBlGBSaO9hiU2r61E"><meta name="google-site-verification" content="40TgWkMJTOetJQqAMZwk5nD5rtVQRjk5i2pe6FGka5g"><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content="Liu Xin's Blog"><title>Netty源码分析 Bootstrap客户端启动 | Liu Xin's Blog</title><link rel="stylesheet" type="text/css" href="/css/style.css?v=0.0.0"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/normalize/6.0.0/normalize.min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/0.6.2/pure-min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/0.6.2/grids-responsive-min.css"><link rel="stylesheet" href="//cdn.bootcss.com/font-awesome/4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="//cdn.bootcss.com/jquery/3.2.1/jquery.min.js"></script><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"><script>(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','https://www.google-analytics.com/analytics.js','ga');
ga('create','UA-91282031-1','auto');ga('send','pageview');</script></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">Netty源码分析 Bootstrap客户端启动</h1><a id="logo" href="/.">Liu Xin's Blog</a><p class="description">Whatever you do, you have to keep moving forward!</p></div><div id="nav-menu"><a href="/." class="current"><i class="fa fa-home"> 首页</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a><a href="/about/"><i class="fa fa-user"> 关于</i></a><a href="/atom.xml"><i class="fa fa-rss"> 订阅</i></a></div></div><div id="layout" class="pure-g"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">Netty源码分析 Bootstrap客户端启动</h1><div class="post-meta">Apr 10, 2017<span> | </span><span class="category"><a href="/categories/Netty/">Netty</a></span></div><a data-disqus-identifier="2017/04/10/Netty-Bootstrap/" href="/2017/04/10/Netty-Bootstrap/#disqus_thread" class="disqus-comment-count"></a><div class="post-content"><blockquote>
<p>本文使用<code>netty-4.1.5.Final</code>版本源码进行分析</p>
</blockquote>
<p>Bootstrap是Socket客户端创建工具类，用户通过Bootstrap可以方便的创建Netty的客户端并发起异步TCP连接操作。下面我们看一下客户端Bootstrap如何启动并对启动过程的源码进行分析。</p>
<a id="more"></a>
<h2 id="Bootstrap客户端启动"><a href="#Bootstrap客户端启动" class="headerlink" title="Bootstrap客户端启动"></a>Bootstrap客户端启动</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// Configure the client.</span></div><div class="line">EventLoopGroup group = <span class="keyword">new</span> NioEventLoopGroup();</div><div class="line"><span class="keyword">try</span> &#123;</div><div class="line">    Bootstrap b = <span class="keyword">new</span> Bootstrap();</div><div class="line">    b.group(group)</div><div class="line">     .channel(NioSocketChannel.class)</div><div class="line">     .option(ChannelOption.TCP_NODELAY, <span class="keyword">true</span>)</div><div class="line">     .handler(<span class="keyword">new</span> ChannelInitializer&lt;SocketChannel&gt;() &#123;</div><div class="line">         <span class="meta">@Override</span></div><div class="line">         <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">initChannel</span><span class="params">(SocketChannel ch)</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">             ChannelPipeline p = ch.pipeline();</div><div class="line">             p.addLast(<span class="keyword">new</span> EchoClientHandler());</div><div class="line">         &#125;</div><div class="line">     &#125;);</div><div class="line"></div><div class="line">    <span class="comment">// Start the client.</span></div><div class="line">    ChannelFuture f = b.connect(HOST, PORT).sync();</div><div class="line"></div><div class="line">    <span class="comment">// Wait until the connection is closed.</span></div><div class="line">    f.channel().closeFuture().sync();</div><div class="line">&#125; <span class="keyword">finally</span> &#123;</div><div class="line">    <span class="comment">// Shut down the event loop to terminate all threads.</span></div><div class="line">    group.shutdownGracefully();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>创建Bootstrap实例，绑定用于处理I/O事件及task任务的workerGroup，并设置其他相关定制参数，最后对指定的host和port发起建立连接请求，就完成了启动Netty客户端的代码。</p>
<h2 id="Bootstrap服务端启动源码分析"><a href="#Bootstrap服务端启动源码分析" class="headerlink" title="Bootstrap服务端启动源码分析"></a>Bootstrap服务端启动源码分析</h2><h3 id="创建Bootstrap实例"><a href="#创建Bootstrap实例" class="headerlink" title="创建Bootstrap实例"></a>创建Bootstrap实例</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Bootstrap b = <span class="keyword">new</span> Bootstrap();</div></pre></td></tr></table></figure>
<h3 id="设置Bootstrap参数"><a href="#设置Bootstrap参数" class="headerlink" title="设置Bootstrap参数"></a>设置Bootstrap参数</h3><p>绑定Reactor线程池</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> B <span class="title">group</span><span class="params">(EventLoopGroup group)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (group == <span class="keyword">null</span>) &#123;</div><div class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException(<span class="string">"group"</span>);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.group != <span class="keyword">null</span>) &#123;</div><div class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"group set already"</span>);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">this</span>.group = group;</div><div class="line">    <span class="keyword">return</span> (B) <span class="keyword">this</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>group线程组主要用于I/O读写以及task执行</p>
<p>设置channel类型，用于根据class类型反射创建对应channel</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div></pre></td><td class="code"><pre><div class="line">    <span class="function"><span class="keyword">public</span> B <span class="title">channel</span><span class="params">(Class&lt;? extends C&gt; channelClass)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (channelClass == <span class="keyword">null</span>) &#123;</div><div class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException(<span class="string">"channelClass"</span>);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> channelFactory(<span class="keyword">new</span> ReflectiveChannelFactory&lt;C&gt;(channelClass));</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">public</span> B <span class="title">channelFactory</span><span class="params">(ChannelFactory&lt;? extends C&gt; channelFactory)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (channelFactory == <span class="keyword">null</span>) &#123;</div><div class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException(<span class="string">"channelFactory"</span>);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.channelFactory != <span class="keyword">null</span>) &#123;</div><div class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"channelFactory set already"</span>);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">this</span>.channelFactory = channelFactory;</div><div class="line">        <span class="keyword">return</span> (B) <span class="keyword">this</span>;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReflectiveChannelFactory</span>&lt;<span class="title">T</span> <span class="keyword">extends</span> <span class="title">Channel</span>&gt; <span class="keyword">implements</span> <span class="title">ChannelFactory</span>&lt;<span class="title">T</span>&gt; </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Class&lt;? extends T&gt; clazz;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ReflectiveChannelFactory</span><span class="params">(Class&lt;? extends T&gt; clazz)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (clazz == <span class="keyword">null</span>) &#123;</div><div class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException(<span class="string">"clazz"</span>);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">this</span>.clazz = clazz;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">newChannel</span><span class="params">()</span> </span>&#123;<span class="comment">//通过反射创建channel</span></div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            <span class="keyword">return</span> clazz.newInstance();</div><div class="line">        &#125; <span class="keyword">catch</span> (Throwable t) &#123;</div><div class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> ChannelException(<span class="string">"Unable to create Channel from class "</span> + clazz, t);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> StringUtil.simpleClassName(clazz) + <span class="string">".class"</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>根据channel的类型，创建一个生产channel的工厂，用于通过channel类型反射创建对应的channel，服务端一般使用<code>NioServerSocketChannel.class</code></p>
<p>设置channel参数</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> &lt;T&gt; <span class="function">B <span class="title">option</span><span class="params">(ChannelOption&lt;T&gt; option, T value)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (option == <span class="keyword">null</span>) &#123;</div><div class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException(<span class="string">"option"</span>);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">if</span> (value == <span class="keyword">null</span>) &#123;</div><div class="line">        <span class="keyword">synchronized</span> (options) &#123;</div><div class="line">            options.remove(option);</div><div class="line">        &#125;</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        <span class="keyword">synchronized</span> (options) &#123;</div><div class="line">            options.put(option, value);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> (B) <span class="keyword">this</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>设置handler</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> B <span class="title">handler</span><span class="params">(ChannelHandler handler)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (handler == <span class="keyword">null</span>) &#123;</div><div class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException(<span class="string">"handler"</span>);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">this</span>.handler = handler;</div><div class="line">    <span class="keyword">return</span> (B) <span class="keyword">this</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>为NioSocketChannel设置ChannelHandler，ChannelHandler是netty提供给用户定制和扩展的关键接口，用户可以通过自定义ChannelHandler，添加具体的业务逻辑处理。</p>
<h3 id="启动Bootstrap的核心逻辑源码分析"><a href="#启动Bootstrap的核心逻辑源码分析" class="headerlink" title="启动Bootstrap的核心逻辑源码分析"></a>启动Bootstrap的核心逻辑源码分析</h3><p>启动客户端Bootstrap，需要对指定的host和port发起建立连接请求，首先需要将Channel初始化并注册到eventLoop中。</p>
<p>Bootstrap启动的核心逻辑总共分三步操作：</p>
<ol>
<li>初始化</li>
<li>注册</li>
<li>发起连接</li>
</ol>
<p>首先看下启动过程的主干逻辑，然后再具体分析每一步操作的具体逻辑：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> ChannelFuture <span class="title">connect</span><span class="params">(SocketAddress remoteAddress)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (remoteAddress == <span class="keyword">null</span>) &#123;</div><div class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException(<span class="string">"remoteAddress"</span>);</div><div class="line">    &#125;</div><div class="line">    validate();<span class="comment">//参数基本校验</span></div><div class="line">    <span class="keyword">return</span> doResolveAndConnect(remoteAddress, config.localAddress());<span class="comment">//发起连接并返回连接结果</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> ChannelFuture <span class="title">doResolveAndConnect</span><span class="params">(<span class="keyword">final</span> SocketAddress remoteAddress, <span class="keyword">final</span> SocketAddress localAddress)</span> </span>&#123;</div><div class="line">    <span class="keyword">final</span> ChannelFuture regFuture = initAndRegister();<span class="comment">//初始化NioSocketChannel并注册到group的eventLoop上</span></div><div class="line">    <span class="keyword">final</span> Channel channel = regFuture.channel();</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (regFuture.isDone()) &#123;<span class="comment">//如果注册到group上已完成则直接进行连接操作</span></div><div class="line">        <span class="keyword">if</span> (!regFuture.isSuccess()) &#123;</div><div class="line">            <span class="keyword">return</span> regFuture;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> doResolveAndConnect0(channel, remoteAddress, localAddress, channel.newPromise());<span class="comment">//发起连接</span></div><div class="line">    &#125; <span class="keyword">else</span> &#123;<span class="comment">//如果注册到group上还未完成，则添加Listener当执行完注册操作后再回调Listener进行连接操作</span></div><div class="line">        <span class="comment">// Registration future is almost always fulfilled already, but just in case it's not.</span></div><div class="line">        <span class="keyword">final</span> PendingRegistrationPromise promise = <span class="keyword">new</span> PendingRegistrationPromise(channel);</div><div class="line">        regFuture.addListener(<span class="keyword">new</span> ChannelFutureListener() &#123;</div><div class="line">            <span class="meta">@Override</span></div><div class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">operationComplete</span><span class="params">(ChannelFuture future)</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">                <span class="comment">// Direclty obtain the cause and do a null check so we only need one volatile read in case of a</span></div><div class="line">                <span class="comment">// failure.</span></div><div class="line">                Throwable cause = future.cause();</div><div class="line">                <span class="keyword">if</span> (cause != <span class="keyword">null</span>) &#123;</div><div class="line">                    <span class="comment">// Registration on the EventLoop failed so fail the ChannelPromise directly to not cause an</span></div><div class="line">                    <span class="comment">// IllegalStateException once we try to access the EventLoop of the Channel.</span></div><div class="line">                    promise.setFailure(cause);</div><div class="line">                &#125; <span class="keyword">else</span> &#123;</div><div class="line">                    <span class="comment">// Registration was successful, so set the correct executor to use.</span></div><div class="line">                    <span class="comment">// See https://github.com/netty/netty/issues/2586</span></div><div class="line">                    promise.registered();</div><div class="line">                    doResolveAndConnect0(channel, remoteAddress, localAddress, promise);<span class="comment">//发起连接</span></div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;);</div><div class="line">        <span class="keyword">return</span> promise;<span class="comment">//外部可以用过promise得到是否连接完成的结果，或者阻塞直到完成连接。</span></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>首先初始化NioSocketChannel并注册到group的eventLoop上，当NioSocketChannel已经执行完成注册操作，则直接发起连接操作，否则添加Listener当执行完注册操作后再回调Listener发起连接。</p>
<p>初始化NioSocketChannel并注册到group的eventLoop上</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">final</span> ChannelFuture <span class="title">initAndRegister</span><span class="params">()</span> </span>&#123;</div><div class="line">    Channel channel = <span class="keyword">null</span>;</div><div class="line">    <span class="keyword">try</span> &#123;</div><div class="line">        channel = channelFactory.newChannel();<span class="comment">//通过创建Bootstrap时设置的channel创建工厂通过反射创建对应的channel，客户端一般是NioSocketChannel</span></div><div class="line">        init(channel);<span class="comment">//初始化channel</span></div><div class="line">    &#125; <span class="keyword">catch</span> (Throwable t) &#123;</div><div class="line">        <span class="keyword">if</span> (channel != <span class="keyword">null</span>) &#123;</div><div class="line">            <span class="comment">// channel can be null if newChannel crashed (eg SocketException("too many open files"))</span></div><div class="line">            channel.unsafe().closeForcibly();</div><div class="line">        &#125;</div><div class="line">        <span class="comment">// as the Channel is not registered yet we need to force the usage of the GlobalEventExecutor</span></div><div class="line">        <span class="keyword">return</span> <span class="keyword">new</span> DefaultChannelPromise(channel, GlobalEventExecutor.INSTANCE).setFailure(t);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    ChannelFuture regFuture = config().group().register(channel);<span class="comment">//注册channel到eventLoop上</span></div><div class="line">    <span class="keyword">if</span> (regFuture.cause() != <span class="keyword">null</span>) &#123;</div><div class="line">        <span class="keyword">if</span> (channel.isRegistered()) &#123;</div><div class="line">            channel.close();</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            channel.unsafe().closeForcibly();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// If we are here and the promise is not failed, it's one of the following cases:</span></div><div class="line">    <span class="comment">// 1) If we attempted registration from the event loop, the registration has been completed at this point.</span></div><div class="line">    <span class="comment">//    i.e. It's safe to attempt bind() or connect() now because the channel has been registered.</span></div><div class="line">    <span class="comment">// 2) If we attempted registration from the other thread, the registration request has been successfully</span></div><div class="line">    <span class="comment">//    added to the event loop's task queue for later execution.</span></div><div class="line">    <span class="comment">//    i.e. It's safe to attempt bind() or connect() now:</span></div><div class="line">    <span class="comment">//         because bind() or connect() will be executed *after* the scheduled registration task is executed</span></div><div class="line">    <span class="comment">//         because register(), bind(), and connect() are all bound to the same thread.</span></div><div class="line"></div><div class="line">    <span class="keyword">return</span> regFuture;<span class="comment">//返回注册操作的结果，用于判断是否已注册完成</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>创建并初始化NioSocketChannel，然后将其注册到group的eventLoop上去，并返回注册操作的结果。</p>
<h4 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">(Channel channel)</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">    ChannelPipeline p = channel.pipeline();<span class="comment">//获取负责处理网络事件的职责链，用来管理和执行ChannelHandler</span></div><div class="line">    p.addLast(config.handler());<span class="comment">////将创建Bootstrap时设置的handler添加到NioSocketChannel的责任链上</span></div><div class="line"></div><div class="line">    <span class="keyword">final</span> Map&lt;ChannelOption&lt;?&gt;, Object&gt; options = options0();<span class="comment">//设置channel的参数</span></div><div class="line">    <span class="keyword">synchronized</span> (options) &#123;</div><div class="line">        <span class="keyword">for</span> (Entry&lt;ChannelOption&lt;?&gt;, Object&gt; e: options.entrySet()) &#123;</div><div class="line">            <span class="keyword">try</span> &#123;</div><div class="line">                <span class="keyword">if</span> (!channel.config().setOption((ChannelOption&lt;Object&gt;) e.getKey(), e.getValue())) &#123;</div><div class="line">                    logger.warn(<span class="string">"Unknown channel option: "</span> + e);</div><div class="line">                &#125;</div><div class="line">            &#125; <span class="keyword">catch</span> (Throwable t) &#123;</div><div class="line">                logger.warn(<span class="string">"Failed to set a channel option: "</span> + channel, t);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">final</span> Map&lt;AttributeKey&lt;?&gt;, Object&gt; attrs = attrs0();<span class="comment">//设置channel的附加属性</span></div><div class="line">    <span class="keyword">synchronized</span> (attrs) &#123;</div><div class="line">        <span class="keyword">for</span> (Entry&lt;AttributeKey&lt;?&gt;, Object&gt; e: attrs.entrySet()) &#123;</div><div class="line">            channel.attr((AttributeKey&lt;Object&gt;) e.getKey()).set(e.getValue());</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="注册"><a href="#注册" class="headerlink" title="注册"></a>注册</h4><p>注册NioSocketChannel，从group选择一个eventLoop线程，将NioSocketChannel注册到该eventLoop的selector上，通过channel获取unsafe，进而操作底层NIO的api进行注册操作</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> ChannelFuture <span class="title">register</span><span class="params">(<span class="keyword">final</span> ChannelPromise promise)</span> </span>&#123;</div><div class="line">    ObjectUtil.checkNotNull(promise, <span class="string">"promise"</span>);</div><div class="line">    promise.channel().unsafe().register(<span class="keyword">this</span>, promise);</div><div class="line">    <span class="keyword">return</span> promise;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>unsafe的register方法，判断当前线程是否是对应channel的eventLoop线程来决定是直接执行register0还是封装一个task交由对应的eventLoop来执行register0</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">register</span><span class="params">(EventLoop eventLoop, <span class="keyword">final</span> ChannelPromise promise)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (eventLoop == <span class="keyword">null</span>) &#123;</div><div class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException(<span class="string">"eventLoop"</span>);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">if</span> (isRegistered()) &#123;</div><div class="line">        promise.setFailure(<span class="keyword">new</span> IllegalStateException(<span class="string">"registered to an event loop already"</span>));</div><div class="line">        <span class="keyword">return</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">if</span> (!isCompatible(eventLoop)) &#123;</div><div class="line">        promise.setFailure(</div><div class="line">                <span class="keyword">new</span> IllegalStateException(<span class="string">"incompatible event loop type: "</span> + eventLoop.getClass().getName()));</div><div class="line">        <span class="keyword">return</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    AbstractChannel.<span class="keyword">this</span>.eventLoop = eventLoop;</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (eventLoop.inEventLoop()) &#123;<span class="comment">//判断当前线程是否是对应的eventLoop线程来决定是直接执行register0还是封装一个task交由对应的eventLoop来执行</span></div><div class="line">        register0(promise);</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            eventLoop.execute(<span class="keyword">new</span> Runnable() &#123;<span class="comment">//提交task执行register0</span></div><div class="line">                <span class="meta">@Override</span></div><div class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">                    register0(promise);</div><div class="line">                &#125;</div><div class="line">            &#125;);</div><div class="line">        &#125; <span class="keyword">catch</span> (Throwable t) &#123;</div><div class="line">            logger.warn(</div><div class="line">                    <span class="string">"Force-closing a channel whose registration task was not accepted by an event loop: &#123;&#125;"</span>,</div><div class="line">                    AbstractChannel.<span class="keyword">this</span>, t);</div><div class="line">            closeForcibly();</div><div class="line">            closeFuture.setClosed();</div><div class="line">            safeSetFailure(promise, t);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">register0</span><span class="params">(ChannelPromise promise)</span> </span>&#123;</div><div class="line">    <span class="keyword">try</span> &#123;</div><div class="line">        <span class="comment">// check if the channel is still open as it could be closed in the mean time when the register</span></div><div class="line">        <span class="comment">// call was outside of the eventLoop</span></div><div class="line">        <span class="keyword">if</span> (!promise.setUncancellable() || !ensureOpen(promise)) &#123;</div><div class="line">            <span class="keyword">return</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">boolean</span> firstRegistration = neverRegistered;<span class="comment">//是否第一次注册</span></div><div class="line">        doRegister();<span class="comment">//调用底层NIO的api执行注册操作</span></div><div class="line">        neverRegistered = <span class="keyword">false</span>;<span class="comment">//标识已经注册过一次</span></div><div class="line">        registered = <span class="keyword">true</span>;<span class="comment">////标识已经注册的状态</span></div><div class="line"></div><div class="line">        <span class="comment">// Ensure we call handlerAdded(...) before we actually notify the promise. This is needed as the</span></div><div class="line">        <span class="comment">// user may already fire events through the pipeline in the ChannelFutureListener.</span></div><div class="line">        pipeline.invokeHandlerAddedIfNeeded();<span class="comment">//最终会调用ChannelInitializer的handlerAdded方法，进而调用ChannelInitializer的initChannel方法初始化定制的ChannelHandler</span></div><div class="line"></div><div class="line">        safeSetSuccess(promise);<span class="comment">//设置promise结果为成功</span></div><div class="line">        pipeline.fireChannelRegistered();<span class="comment">//触发fireChannelRegistered事件，该方法也会调用invokeHandlerAddedIfNeeded()，不过通过状态位保证了invokeHandlerAddedIfNeeded只会执行一次，该方法主要是用于传播注册完成事件</span></div><div class="line">        <span class="comment">// Only fire a channelActive if the channel has never been registered. This prevents firing</span></div><div class="line">        <span class="comment">// multiple channel actives if the channel is deregistered and re-registered.</span></div><div class="line">        <span class="keyword">if</span> (isActive()) &#123;<span class="comment">//channel状态是否已绑定或已连接</span></div><div class="line">            <span class="keyword">if</span> (firstRegistration) &#123;<span class="comment">//第一次注册需要触发fireChannelActive事件来设置监听位</span></div><div class="line">                pipeline.fireChannelActive();</div><div class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (config().isAutoRead()) &#123;<span class="comment">//不是第一次注册，但是AutoRead，也需要设置监听位</span></div><div class="line">                <span class="comment">// This channel was registered before and autoRead() is set. This means we need to begin read</span></div><div class="line">                <span class="comment">// again so that we process inbound data.</span></div><div class="line">                <span class="comment">//</span></div><div class="line">                <span class="comment">// See https://github.com/netty/netty/issues/4805</span></div><div class="line">                beginRead();<span class="comment">//设置监听位</span></div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125; <span class="keyword">catch</span> (Throwable t) &#123;</div><div class="line">        <span class="comment">// Close the channel directly to avoid FD leak.</span></div><div class="line">        closeForcibly();</div><div class="line">        closeFuture.setClosed();</div><div class="line">        safeSetFailure(promise, t);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>调用底层NIO的api执行注册操作</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doRegister</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;<span class="comment">//调用底层NIO的api执行注册操作</span></div><div class="line">    <span class="keyword">boolean</span> selected = <span class="keyword">false</span>;</div><div class="line">    <span class="keyword">for</span> (;;) &#123;</div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            selectionKey = javaChannel().register(eventLoop().selector, <span class="number">0</span>, <span class="keyword">this</span>);<span class="comment">//此处没有设置监听位，后续会通过fireChannelActive事件传播到HeadContext中再根据channel类型来设置需要的监听位</span></div><div class="line">            <span class="keyword">return</span>;</div><div class="line">        &#125; <span class="keyword">catch</span> (CancelledKeyException e) &#123;</div><div class="line">            <span class="keyword">if</span> (!selected) &#123;</div><div class="line">                <span class="comment">// Force the Selector to select now as the "canceled" SelectionKey may still be</span></div><div class="line">                <span class="comment">// cached and not removed because no Select.select(..) operation was called yet.</span></div><div class="line">                eventLoop().selectNow();</div><div class="line">                selected = <span class="keyword">true</span>;</div><div class="line">            &#125; <span class="keyword">else</span> &#123;</div><div class="line">                <span class="comment">// We forced a select operation on the selector before but the SelectionKey is still cached</span></div><div class="line">                <span class="comment">// for whatever reason. JDK bug ?</span></div><div class="line">                <span class="keyword">throw</span> e;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="发起连接"><a href="#发起连接" class="headerlink" title="发起连接"></a>发起连接</h4><p>注册完成回到连接方法，当NioSocketChannel已经执行完成注册操作，则直接发起连接操作，否则添加Listener当执行完注册操作后再回调Listener发起连接操作，连接操作需要操作channel，所以需要封装成task任务交由channel对应的eventLoop线程执行其connect方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> ChannelFuture <span class="title">doResolveAndConnect0</span><span class="params">(<span class="keyword">final</span> Channel channel, SocketAddress remoteAddress,</span></span></div><div class="line">                                           <span class="keyword">final</span> SocketAddress localAddress, <span class="keyword">final</span> ChannelPromise promise) &#123;</div><div class="line">    <span class="keyword">try</span> &#123;</div><div class="line">        <span class="keyword">final</span> EventLoop eventLoop = channel.eventLoop();</div><div class="line">        <span class="keyword">final</span> AddressResolver&lt;SocketAddress&gt; resolver = <span class="keyword">this</span>.resolver.getResolver(eventLoop);<span class="comment">//对目标地址做一些解析校验</span></div><div class="line"></div><div class="line">        <span class="keyword">if</span> (!resolver.isSupported(remoteAddress) || resolver.isResolved(remoteAddress)) &#123;<span class="comment">//无法解析或者已经解析过则立刻发起连接操作</span></div><div class="line">            <span class="comment">// Resolver has no idea about what to do with the specified remote address or it's resolved already.</span></div><div class="line">            doConnect(remoteAddress, localAddress, promise);<span class="comment">//对目标地址发起连接</span></div><div class="line">            <span class="keyword">return</span> promise;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">final</span> Future&lt;SocketAddress&gt; resolveFuture = resolver.resolve(remoteAddress);<span class="comment">//解析目标地址</span></div><div class="line"></div><div class="line">        <span class="keyword">if</span> (resolveFuture.isDone()) &#123;<span class="comment">//解析完成则直接发起连接操作</span></div><div class="line">            <span class="keyword">final</span> Throwable resolveFailureCause = resolveFuture.cause();</div><div class="line"></div><div class="line">            <span class="keyword">if</span> (resolveFailureCause != <span class="keyword">null</span>) &#123;</div><div class="line">                <span class="comment">// Failed to resolve immediately</span></div><div class="line">                channel.close();</div><div class="line">                promise.setFailure(resolveFailureCause);</div><div class="line">            &#125; <span class="keyword">else</span> &#123;</div><div class="line">                <span class="comment">// Succeeded to resolve immediately; cached? (or did a blocking lookup)</span></div><div class="line">                doConnect(resolveFuture.getNow(), localAddress, promise);<span class="comment">//对目标地址发起连接</span></div><div class="line">            &#125;</div><div class="line">            <span class="keyword">return</span> promise;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="comment">// Wait until the name resolution is finished.</span></div><div class="line">        resolveFuture.addListener(<span class="keyword">new</span> FutureListener&lt;SocketAddress&gt;() &#123;<span class="comment">//解析未完成则添加Listener当解析完成通过校验后再回调Listener发起连接操作</span></div><div class="line">            <span class="meta">@Override</span></div><div class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">operationComplete</span><span class="params">(Future&lt;SocketAddress&gt; future)</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">                <span class="keyword">if</span> (future.cause() != <span class="keyword">null</span>) &#123;</div><div class="line">                    channel.close();</div><div class="line">                    promise.setFailure(future.cause());</div><div class="line">                &#125; <span class="keyword">else</span> &#123;</div><div class="line">                    doConnect(future.getNow(), localAddress, promise);<span class="comment">//对目标地址发起连接</span></div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;);</div><div class="line">    &#125; <span class="keyword">catch</span> (Throwable cause) &#123;</div><div class="line">        promise.tryFailure(cause);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> promise;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>封装成task任务交由channel对应的eventLoop线程来执行，防止并发操作channel</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">doConnect</span><span class="params">(</span></span></div><div class="line">        <span class="keyword">final</span> SocketAddress remoteAddress, <span class="keyword">final</span> SocketAddress localAddress, <span class="keyword">final</span> ChannelPromise connectPromise) &#123;</div><div class="line"></div><div class="line">    <span class="comment">// This method is invoked before channelRegistered() is triggered.  Give user handlers a chance to set up</span></div><div class="line">    <span class="comment">// the pipeline in its channelRegistered() implementation.</span></div><div class="line">    <span class="keyword">final</span> Channel channel = connectPromise.channel();</div><div class="line">    channel.eventLoop().execute(<span class="keyword">new</span> Runnable() &#123;<span class="comment">//封装成task任务交由channel对应的eventLoop线程来执行，防止并发操作channel</span></div><div class="line">        <span class="meta">@Override</span></div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">            <span class="keyword">if</span> (localAddress == <span class="keyword">null</span>) &#123;</div><div class="line">                channel.connect(remoteAddress, connectPromise);<span class="comment">//执行channel的connect方法进行连接</span></div><div class="line">            &#125; <span class="keyword">else</span> &#123;</div><div class="line">                channel.connect(remoteAddress, localAddress, connectPromise);</div><div class="line">            &#125;</div><div class="line">            connectPromise.addListener(ChannelFutureListener.CLOSE_ON_FAILURE);<span class="comment">//如果连接失败则通过回调进行关闭</span></div><div class="line">        &#125;</div><div class="line">    &#125;);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>从责任链中获取ChannelOutboundHandler执行connect方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> ChannelFuture <span class="title">connect</span><span class="params">(</span></span></div><div class="line">        <span class="keyword">final</span> SocketAddress remoteAddress, <span class="keyword">final</span> SocketAddress localAddress, <span class="keyword">final</span> ChannelPromise promise) &#123;</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (remoteAddress == <span class="keyword">null</span>) &#123;</div><div class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException(<span class="string">"remoteAddress"</span>);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">if</span> (!validatePromise(promise, <span class="keyword">false</span>)) &#123;</div><div class="line">        <span class="comment">// cancelled</span></div><div class="line">        <span class="keyword">return</span> promise;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">final</span> AbstractChannelHandlerContext next = findContextOutbound();<span class="comment">//从责任链中获取ChannelOutboundHandler</span></div><div class="line">    EventExecutor executor = next.executor();</div><div class="line">    <span class="keyword">if</span> (executor.inEventLoop()) &#123;<span class="comment">//如果当前线程是channel对应的EventLoop线程，则直接执行，否则封装成task交由channel对应的EventLoop线程执行invokeConnect方法</span></div><div class="line">        next.invokeConnect(remoteAddress, localAddress, promise);</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        safeExecute(executor, <span class="keyword">new</span> Runnable() &#123;</div><div class="line">            <span class="meta">@Override</span></div><div class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">                next.invokeConnect(remoteAddress, localAddress, promise);</div><div class="line">            &#125;</div><div class="line">        &#125;, promise, <span class="keyword">null</span>);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> promise;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">invokeConnect</span><span class="params">(SocketAddress remoteAddress, SocketAddress localAddress, ChannelPromise promise)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (invokeHandler()) &#123;</div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            ((ChannelOutboundHandler) handler()).connect(<span class="keyword">this</span>, remoteAddress, localAddress, promise);</div><div class="line">        &#125; <span class="keyword">catch</span> (Throwable t) &#123;</div><div class="line">            notifyOutboundHandlerException(t, promise);</div><div class="line">        &#125;</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        connect(remoteAddress, localAddress, promise);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>连接需要用的ChannelOutboundHandler是责任链的头部ChannelHandler：HeadContext</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">connect</span><span class="params">(</span></span></div><div class="line">        ChannelHandlerContext ctx,</div><div class="line">        SocketAddress remoteAddress, SocketAddress localAddress,</div><div class="line">        ChannelPromise promise) <span class="keyword">throws</span> Exception &#123;</div><div class="line">    unsafe.connect(remoteAddress, localAddress, promise);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>最终调用unsafe的connect方法，也是真正进行连接操作的核心逻辑</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">connect</span><span class="params">(</span></span></div><div class="line">        <span class="keyword">final</span> SocketAddress remoteAddress, <span class="keyword">final</span> SocketAddress localAddress, <span class="keyword">final</span> ChannelPromise promise) &#123;</div><div class="line">    <span class="keyword">if</span> (!promise.setUncancellable() || !ensureOpen(promise)) &#123;</div><div class="line">        <span class="keyword">return</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">try</span> &#123;</div><div class="line">        <span class="keyword">if</span> (connectPromise != <span class="keyword">null</span>) &#123;</div><div class="line">            <span class="comment">// Already a connect in process.</span></div><div class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> ConnectionPendingException();</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">boolean</span> wasActive = isActive();</div><div class="line">        <span class="keyword">if</span> (doConnect(remoteAddress, localAddress)) &#123;<span class="comment">//发起连接，如果成功，则执行fulfillConnectPromise触发fireChannelActive事件，</span></div><div class="line">            fulfillConnectPromise(promise, wasActive);</div><div class="line">        &#125; <span class="keyword">else</span> &#123;<span class="comment">//如果连接未成功，需要添加处理连接超时的定时任务</span></div><div class="line">            connectPromise = promise;</div><div class="line">            requestedRemoteAddress = remoteAddress;</div><div class="line"></div><div class="line">            <span class="comment">// Schedule connect timeout.</span></div><div class="line">            <span class="keyword">int</span> connectTimeoutMillis = config().getConnectTimeoutMillis();<span class="comment">//获取连接超时时间。默认30s，最好根据实际情况使用ChannelOption定制合理的超时时间</span></div><div class="line">            <span class="keyword">if</span> (connectTimeoutMillis &gt; <span class="number">0</span>) &#123;</div><div class="line">                connectTimeoutFuture = eventLoop().schedule(<span class="keyword">new</span> Runnable() &#123;<span class="comment">//根据连接超时时间设置定时任务，如果超时仍未能连接则关闭连接，设置连接结果Promise为失败</span></div><div class="line">                    <span class="meta">@Override</span></div><div class="line">                    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">                        ChannelPromise connectPromise = AbstractNioChannel.<span class="keyword">this</span>.connectPromise;</div><div class="line">                        ConnectTimeoutException cause =</div><div class="line">                                <span class="keyword">new</span> ConnectTimeoutException(<span class="string">"connection timed out: "</span> + remoteAddress);</div><div class="line">                        <span class="keyword">if</span> (connectPromise != <span class="keyword">null</span> &amp;&amp; connectPromise.tryFailure(cause)) &#123;</div><div class="line">                            close(voidPromise());</div><div class="line">                        &#125;</div><div class="line">                    &#125;</div><div class="line">                &#125;, connectTimeoutMillis, TimeUnit.MILLISECONDS);</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            promise.addListener(<span class="keyword">new</span> ChannelFutureListener() &#123;<span class="comment">//为连接结果promise设置Listener，当完成操作后触发回调，如果连接失败，则取消掉处理当前连接超时的定时任务。</span></div><div class="line">                <span class="meta">@Override</span></div><div class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">operationComplete</span><span class="params">(ChannelFuture future)</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">                    <span class="keyword">if</span> (future.isCancelled()) &#123;</div><div class="line">                        <span class="keyword">if</span> (connectTimeoutFuture != <span class="keyword">null</span>) &#123;</div><div class="line">                            connectTimeoutFuture.cancel(<span class="keyword">false</span>);</div><div class="line">                        &#125;</div><div class="line">                        connectPromise = <span class="keyword">null</span>;</div><div class="line">                        close(voidPromise());</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line">            &#125;);</div><div class="line">        &#125;</div><div class="line">    &#125; <span class="keyword">catch</span> (Throwable t) &#123;</div><div class="line">        promise.tryFailure(annotateConnectException(t, remoteAddress));</div><div class="line">        closeIfClosed();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">doConnect</span><span class="params">(SocketAddress remoteAddress, SocketAddress localAddress)</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">    <span class="keyword">if</span> (localAddress != <span class="keyword">null</span>) &#123;</div><div class="line">        doBind0(localAddress);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">boolean</span> success = <span class="keyword">false</span>;</div><div class="line">    <span class="keyword">try</span> &#123;</div><div class="line">        <span class="keyword">boolean</span> connected = javaChannel().connect(remoteAddress);<span class="comment">//获取SocketChannel发起连接</span></div><div class="line">        <span class="keyword">if</span> (!connected) &#123;<span class="comment">//如果连接失败需要设置`SelectionKey.OP_CONNECT`监听位。</span></div><div class="line">            selectionKey().interestOps(SelectionKey.OP_CONNECT);</div><div class="line">        &#125;</div><div class="line">        success = <span class="keyword">true</span>;</div><div class="line">        <span class="keyword">return</span> connected;<span class="comment">//返回是否连接成功的结果</span></div><div class="line">    &#125; <span class="keyword">finally</span> &#123;</div><div class="line">        <span class="keyword">if</span> (!success) &#123;</div><div class="line">            doClose();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>调用doConnect方法获得底层NIO原生的SocketChannel发起连接操作，并返回连接操作的结果，因为此处的SocketChannel被设置为非阻塞，所以这里有可能没有立即连接成功，如果当前操作立即连接成功，则调用fulfillConnectPromise方法进而触发fireChannelActive事件；如果当前操作未能立即连接成功，则设置<code>SelectionKey.OP_CONNECT</code>监听位，异步监听连接就绪事件来完成连接操作，并为当前连接添加处理连接超时的定时任务task，并设置Listener用来在连接失败时清理废弃的定时任务task。</p>
<p>如果当前操作立即连接成功，则调用fulfillConnectPromise方法进而触发fireChannelActive事件</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">fulfillConnectPromise</span><span class="params">(ChannelPromise promise, <span class="keyword">boolean</span> wasActive)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (promise == <span class="keyword">null</span>) &#123;</div><div class="line">        <span class="comment">// Closed via cancellation and the promise has been notified already.</span></div><div class="line">        <span class="keyword">return</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// Get the state as trySuccess() may trigger an ChannelFutureListener that will close the Channel.</span></div><div class="line">    <span class="comment">// We still need to ensure we call fireChannelActive() in this case.</span></div><div class="line">    <span class="keyword">boolean</span> active = isActive();</div><div class="line"></div><div class="line">    <span class="comment">// trySuccess() will return false if a user cancelled the connection attempt.</span></div><div class="line">    <span class="keyword">boolean</span> promiseSet = promise.trySuccess();</div><div class="line"></div><div class="line">    <span class="comment">// Regardless if the connection attempt was cancelled, channelActive() event should be triggered,</span></div><div class="line">    <span class="comment">// because what happened is what happened.</span></div><div class="line">    <span class="keyword">if</span> (!wasActive &amp;&amp; active) &#123;<span class="comment">//需要保证是当前操作完成的连接操作，才触发fireChannelActive事件，确保fireChannelActive事件只被执行一次，这块不会有并发问题是因为对一个channel的操作都是在channel对应的eventLoop线程内串行执行的。</span></div><div class="line">        pipeline().fireChannelActive();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// If a user cancelled the connection attempt, close the channel, which is followed by channelInactive().</span></div><div class="line">    <span class="keyword">if</span> (!promiseSet) &#123;</div><div class="line">        close(voidPromise());</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>如果当前操作未能立即连接成功，则设置<code>SelectionKey.OP_CONNECT</code>监听位，异步监听连接就绪事件来完成连接操作，异步监听的逻辑在NioEventLoop的处理就绪的SelectedKey的方法中</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> ((readyOps &amp; SelectionKey.OP_CONNECT) != <span class="number">0</span>) &#123;<span class="comment">//监听SelectionKey.OP_CONNECT就绪事件</span></div><div class="line">    <span class="comment">// remove OP_CONNECT as otherwise Selector.select(..) will always return without blocking</span></div><div class="line">    <span class="comment">// See https://github.com/netty/netty/issues/924</span></div><div class="line">    <span class="keyword">int</span> ops = k.interestOps();</div><div class="line">    ops &amp;= ~SelectionKey.OP_CONNECT;<span class="comment">//已经监听到SelectionKey.OP_CONNECT就绪事件，需要清除掉SelectionKey.OP_CONNECT的监听位</span></div><div class="line">    k.interestOps(ops);</div><div class="line"></div><div class="line">    unsafe.finishConnect();<span class="comment">//完成连接操作，触发fireChannelActive事件</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">finishConnect</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="comment">// Note this method is invoked by the event loop only if the connection attempt was</span></div><div class="line">    <span class="comment">// neither cancelled nor timed out.</span></div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">assert</span> <span class="title">eventLoop</span><span class="params">()</span>.<span class="title">inEventLoop</span><span class="params">()</span></span>;</div><div class="line"></div><div class="line">    <span class="keyword">try</span> &#123;</div><div class="line">        <span class="keyword">boolean</span> wasActive = isActive();</div><div class="line">        doFinishConnect();<span class="comment">//完成连接操作</span></div><div class="line">        fulfillConnectPromise(connectPromise, wasActive);<span class="comment">//完成连接操作后调用之前的fulfillConnectPromise方法进而触发fireChannelActive事件</span></div><div class="line">    &#125; <span class="keyword">catch</span> (Throwable t) &#123;</div><div class="line">        fulfillConnectPromise(connectPromise, annotateConnectException(t, requestedRemoteAddress));<span class="comment">//连接失败需要设置连接结果Promise为失败，并清理关闭该连接</span></div><div class="line">    &#125; <span class="keyword">finally</span> &#123;</div><div class="line">        <span class="comment">// Check for null as the connectTimeoutFuture is only created if a connectTimeoutMillis &gt; 0 is used</span></div><div class="line">        <span class="comment">// See https://github.com/netty/netty/issues/1770</span></div><div class="line">        <span class="keyword">if</span> (connectTimeoutFuture != <span class="keyword">null</span>) &#123;<span class="comment">//如果有处理连接超时的定时任务则取消该任务</span></div><div class="line">            connectTimeoutFuture.cancel(<span class="keyword">false</span>);</div><div class="line">        &#125;</div><div class="line">        connectPromise = <span class="keyword">null</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doFinishConnect</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">    <span class="keyword">if</span> (!javaChannel().finishConnect()) &#123;<span class="comment">//获取NIO原生api的SocketChannel调用finishConnect方法完成连接操作，返回false代表连接失败</span></div><div class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> Error();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>至此，Bootstrap客户端启动部分源码已经分析完成。</p>
</div><script type="text/javascript" src="/js/share.js?v=0.0.0" async></script><a data-url="http://blogxin.cn/2017/04/10/Netty-Bootstrap/" data-id="cj8xdl1qd001iio6z9stv7jrq" class="article-share-link">分享</a><div class="tags"><a href="/tags/源码/">源码</a><a href="/tags/Netty/">Netty</a></div><div class="post-nav"><a href="/2017/04/22/jrebel-remote-server/" class="pre">IntelliJ IDEA下使用JRebel远程热部署</a><a href="/2017/04/01/Netty-ServerBootstrap/" class="next">Netty源码分析 ServerBootstrap服务端启动</a></div><div id="disqus_thread"><div class="btn_click_load"><button class="disqus_click_btn">阅读评论 「请确保 disqus.com 可以正常加载」</button></div><script>var disqus_shortname = 'kris-liu';
var disqus_identifier = '2017/04/10/Netty-Bootstrap/';
var disqus_title = 'Netty源码分析 Bootstrap客户端启动';
var disqus_url = 'http://blogxin.cn/2017/04/10/Netty-Bootstrap/';
$('.btn_click_load').click(function() {
  (function() {
    var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
    dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
    (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
  })();
  $('.btn_click_load').css('display','none');
});
$.ajax({
  url: 'https://disqus.com/favicon.ico',
  timeout: 3000,
  type: 'GET',
  success: (function() {
    var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
    dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
    (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    $('.btn_click_load').css('display','none');
  })(),
  error: function() {
    $('.btn_click_load').css('display','block');
  }
});</script><script id="dsq-count-scr" src="//kris-liu.disqus.com/count.js" async></script></div></div></div></div><div class="pure-u-1-4 hidden_mid_and_down"><div id="sidebar"><div class="widget"><form action="//www.google.com/search" method="get" accept-charset="utf-8" target="_blank" class="search-form"><input type="text" name="q" maxlength="20" placeholder="Search"/><input type="hidden" name="sitesearch" value="http://blogxin.cn"/></form></div><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"> 分类</i></div><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/Concurrent/">Concurrent</a><span class="category-list-count">8</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Git/">Git</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/IO-NIO/">IO&NIO</a><span class="category-list-count">6</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Java/">Java</a><span class="category-list-count">5</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Netty/">Netty</a><span class="category-list-count">6</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Spring/">Spring</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Tomcat/">Tomcat</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Tools/">Tools</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/架构/">架构</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/线上问题/">线上问题</a><span class="category-list-count">2</span></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-star-o"> 标签</i></div><div class="tagcloud"><a href="/tags/读写锁/" style="font-size: 15px;">读写锁</a> <a href="/tags/JVM/" style="font-size: 15px;">JVM</a> <a href="/tags/线上问题/" style="font-size: 15px;">线上问题</a> <a href="/tags/Git/" style="font-size: 15px;">Git</a> <a href="/tags/IO/" style="font-size: 15px;">IO</a> <a href="/tags/NIO/" style="font-size: 15px;">NIO</a> <a href="/tags/内存泄漏/" style="font-size: 15px;">内存泄漏</a> <a href="/tags/Java/" style="font-size: 15px;">Java</a> <a href="/tags/并发/" style="font-size: 15px;">并发</a> <a href="/tags/锁/" style="font-size: 15px;">锁</a> <a href="/tags/源码/" style="font-size: 15px;">源码</a> <a href="/tags/异步/" style="font-size: 15px;">异步</a> <a href="/tags/GC/" style="font-size: 15px;">GC</a> <a href="/tags/线程池/" style="font-size: 15px;">线程池</a> <a href="/tags/缓存/" style="font-size: 15px;">缓存</a> <a href="/tags/BIO/" style="font-size: 15px;">BIO</a> <a href="/tags/AIO/" style="font-size: 15px;">AIO</a> <a href="/tags/JMM/" style="font-size: 15px;">JMM</a> <a href="/tags/内存模型/" style="font-size: 15px;">内存模型</a> <a href="/tags/Netty/" style="font-size: 15px;">Netty</a> <a href="/tags/架构/" style="font-size: 15px;">架构</a> <a href="/tags/Tomcat/" style="font-size: 15px;">Tomcat</a> <a href="/tags/Spring/" style="font-size: 15px;">Spring</a> <a href="/tags/Tools/" style="font-size: 15px;">Tools</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-file-o"> 最近文章</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2017/09/16/java-reference/">Java的强引用，软引用，弱引用，虚引用及其使用场景</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/06/27/InternalResourceViewResolver-Memory-Leak/">InternalResourceViewResolver引起的内存泄漏问题排查</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/05/14/Space-Based-Architecture/">基于空间的架构实践及思考</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/04/23/Netty-DataPacket/">Netty源码分析 解决TCP粘包拆包问题</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/04/22/jrebel-remote-server/">IntelliJ IDEA下使用JRebel远程热部署</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/04/10/Netty-Bootstrap/">Netty源码分析 Bootstrap客户端启动</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/04/01/Netty-ServerBootstrap/">Netty源码分析 ServerBootstrap服务端启动</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/03/20/Netty-epollbug/">Netty源码分析 解决NIO的epoll死循环bug</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/03/18/Netty-NioEventLoop/">Netty源码分析 I/O线程NioEventLoop</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/03/11/Netty-ThreadModel/">Netty 线程模型</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-comment-o"> 最近评论</i></div><script type="text/javascript" src="//kris-liu.disqus.com/recent_comments_widget.js?num_items=5&amp;hide_avatars=1&amp;avatar_size=32&amp;excerpt_length=20&amp;hide_mods=1"></script></div><div class="widget"><div class="widget-title"><i class="fa fa-external-link"> 友情链接</i></div><ul></ul><a href="http://blog.csdn.net/xx_ytm" title="我的CSDN博客" target="_blank">我的CSDN博客</a></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">Copyright © 2017 <a href="/." rel="nofollow">Liu Xin's Blog.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/tufu9441/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/pagecho"> Cho.</a></div></div></div><a id="rocket" href="#top" class="show"></a><script type="text/javascript" src="/js/totop.js?v=0.0.0" async></script><script type="text/javascript" src="//cdn.bootcss.com/fancybox/3.0.47/jquery.fancybox.min.js" async></script><script type="text/javascript" src="/js/fancybox.js?v=0.0.0" async></script><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/fancybox/3.0.47/jquery.fancybox.min.css"><script type="text/javascript" src="/js/codeblock-resizer.js?v=0.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=0.0.0"></script></div></body></html>