<!DOCTYPE html><html lang="zh-CN"><head><meta name="google-site-verification" content="DVfrDhwMEodDoWVy6nv0PCpolWhBlGBSaO9hiU2r61E"><meta name="google-site-verification" content="40TgWkMJTOetJQqAMZwk5nD5rtVQRjk5i2pe6FGka5g"><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content="佑祺's Blog"><title>基于Spring+MyBatis实现一个分库分表、读写分离功能的工具库 | 佑祺's Blog</title><link rel="stylesheet" type="text/css" href="/css/style.css?v=0.0.0"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/normalize/8.0.0/normalize.min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/1.0.0/pure-min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/1.0.0/grids-responsive-min.css"><link rel="stylesheet" href="//cdn.bootcss.com/font-awesome/4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="//cdn.bootcss.com/jquery/3.3.1/jquery.min.js"></script><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"><script>(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','https://www.google-analytics.com/analytics.js','ga');
ga('create','UA-91282031-1','auto');ga('send','pageview');
</script></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">基于Spring+MyBatis实现一个分库分表、读写分离功能的工具库</h1><a id="logo" href="/.">佑祺's Blog</a><p class="description">Whatever you do, you have to keep moving forward!</p></div><div id="nav-menu"><a class="current" href="/."><i class="fa fa-home"> 首页</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a><a href="/about/"><i class="fa fa-user"> 关于</i></a><a href="/atom.xml"><i class="fa fa-rss"> 订阅</i></a></div></div><div class="pure-g" id="layout"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">基于Spring+MyBatis实现一个分库分表、读写分离功能的工具库</h1><div class="post-meta">Jun 1, 2019<span> | </span><span class="category"><a href="/categories/架构/">架构</a></span></div><div class="post-content"><p>一般随着业务的高速发展，业务量越来越大，业务也越来越复杂，数据量也越来越大，数据库层面的优化通常会使用分库分表、主从读写分离的策略进行扩展。本文介绍了分库分表，主从读写分离的优缺点，并对其中一种实现方案进行了原理描述，并亲自动手实现了一个可实用的demo。</p>
<h2 id="分表的优缺点"><a href="#分表的优缺点" class="headerlink" title="分表的优缺点"></a>分表的优缺点</h2><h3 id="垂直拆分："><a href="#垂直拆分：" class="headerlink" title="垂直拆分："></a>垂直拆分：</h3><p>垂直拆分分表指的是将一张大表根据业务、字段冷热、大字段等因素，拆分成多个结构不同的表。</p>
<h4 id="优点："><a href="#优点：" class="headerlink" title="优点："></a>优点：</h4><ol>
<li>优化查询性能，减少IO消耗。数据库索引通常以页位单位加载数据，单行数据越小，一页中包含的数据就越多，内存能加载更多数据，命中率更高。</li>
</ol>
<h4 id="缺点："><a href="#缺点：" class="headerlink" title="缺点："></a>缺点：</h4><ol>
<li>产生多表之间的关联查询，一般在业务层面进行多表数据组装，增加了一定的复杂性。</li>
</ol>
<h3 id="水平拆分："><a href="#水平拆分：" class="headerlink" title="水平拆分："></a>水平拆分：</h3><p>水平拆分分表指的是按一定的分片算法，将同一张表的数据拆分到多个表，每个表结构相同。</p>
<h4 id="优点：-1"><a href="#优点：-1" class="headerlink" title="优点："></a>优点：</h4><ol>
<li>降低单表数据量，优化查询性能，一般来说MYSQL建议单表数据量在1000W以内，一般预估数据有效时间或热点时间内的数据量单表不超过1000W即可，历史数据进行归档。</li>
</ol>
<h4 id="缺点：-1"><a href="#缺点：-1" class="headerlink" title="缺点："></a>缺点：</h4><ol>
<li>若使用场景存在多个分表键，往往需要根据各个分表键进行一定的数据冗余存储。冗余一般分为冗余索引关系表和冗余全量表，需要根据性能，存储成本，维护成本等方面进行选择。</li>
<li>复杂查询支持度不高。一般分表会通过某个业务键比如uid进行分表，非uid维度的查询，比如进行一些聚合查询，分页查询，排序，统计等SQL，将难以执行。解决方案一般通过添加额外存储结构进行处理，常用的ES+HBase方案，通过ES将索引字段进行存储，通过主键或唯一键，关联到HBase进行全量数据查询查询。</li>
</ol>
<h2 id="分库的优缺点"><a href="#分库的优缺点" class="headerlink" title="分库的优缺点"></a>分库的优缺点</h2><h3 id="垂直拆分：-1"><a href="#垂直拆分：-1" class="headerlink" title="垂直拆分："></a>垂直拆分：</h3><p>垂直拆分分库指的是根据业务模块，将不同业务、关联度不高的表拆分到不同的数据库中，关联度高的表集中在一个库。</p>
<h4 id="优点：-2"><a href="#优点：-2" class="headerlink" title="优点："></a>优点：</h4><ol>
<li>业务隔离，不同业务的库中只包含该业务所属的表，减少业务系统相互之间的影响。</li>
<li>优化数据库库性能，减少数据库压力，避免磁盘存储容量不足。</li>
</ol>
<h4 id="缺点：-2"><a href="#缺点：-2" class="headerlink" title="缺点："></a>缺点：</h4><ol>
<li>跨库的复杂查询，需要业务层面进行数据组装，增加了复杂性。</li>
<li>跨库的事务引起的分布式事务问题。解决方案见：<a href="http://blogxin.cn/2018/04/23/Distributed-Transaction/">分布式事务</a>。不过还是建议一般情况下通过一定的系统设计，避免分布式事务的问题。</li>
</ol>
<h3 id="水平拆分：-1"><a href="#水平拆分：-1" class="headerlink" title="水平拆分："></a>水平拆分：</h3><p>水平拆分分库指的是按一定的分片算法，先将同一张表的数据拆分到多个表，每个表结构相同，再将这多个表拆分到多个数据库中。</p>
<h4 id="优点：-3"><a href="#优点：-3" class="headerlink" title="优点："></a>优点：</h4><ol>
<li>优化单机和单库的性能瓶颈，比如CPU、IO、内存等瓶颈，提高数据库集群整体的吞吐量，提高稳定性。</li>
<li>避免磁盘存储容量不足。</li>
</ol>
<h4 id="缺点：-3"><a href="#缺点：-3" class="headerlink" title="缺点："></a>缺点：</h4><ol>
<li>若使用场景存在多个分表键，往往需要根据各个分表键进行一定的数据冗余存储。冗余一般分为冗余索引关系表和冗余全量表，需要根据性能，存储成本，维护成本等方面进行选择。</li>
<li>复杂查询支持度不高。一般分库分表会通过某个业务键比如uid进行分库分表，非uid维度的查询，比如进行一些聚合查询，分页查询，排序，统计等SQL，将难以执行，一般通过添加额外存储结构进行处理，常用的ES+HBase方案，通过ES将索引字段进行存储，通过主键或唯一键，关联到HBase进行全量数据查询查询。</li>
<li>跨分片的事务引起的分布式事务问题。解决方案见：<a href="http://blogxin.cn/2018/04/23/Distributed-Transaction/">分布式事务</a>。不过还是建议一般情况下通过一定的系统设计，避免分布式事务的问题。</li>
</ol>
<h2 id="主从读写分离的优缺点"><a href="#主从读写分离的优缺点" class="headerlink" title="主从读写分离的优缺点"></a>主从读写分离的优缺点</h2><h4 id="优点：-4"><a href="#优点：-4" class="headerlink" title="优点："></a>优点：</h4><ol>
<li>减少主库压力，一般系统都是读多写少，将部分一致性要求低的查询放到从库，可以有效降低主库的压力，尤其是一些统计类SQL。</li>
</ol>
<h4 id="缺点：-4"><a href="#缺点：-4" class="headerlink" title="缺点："></a>缺点：</h4><ol>
<li>主从之间数据存在延迟，查询从库有可能读到脏数据，需要根据实际查询场景，决定是否可以查从库。</li>
</ol>
<h2 id="如何自己实现一个分库分表、读写分离功能的工具库"><a href="#如何自己实现一个分库分表、读写分离功能的工具库" class="headerlink" title="如何自己实现一个分库分表、读写分离功能的工具库"></a>如何自己实现一个分库分表、读写分离功能的工具库</h2><p>这里主要介绍水平分库分表的工具和实现原理：</p>
<h3 id="常见的有两大类型"><a href="#常见的有两大类型" class="headerlink" title="常见的有两大类型"></a>常见的有两大类型</h3><ul>
<li><p>Client模式：该模式是提供一个jar包集成到业务框架中，执行SQL时通过该jar包提供的扩展，直接在客户端完成SQL进行解析，重写，路由的能力。比如Sharding-Sphere。</p>
</li>
<li><p>Proxy模式：该模式是提供一个中间层Proxy，业务系统像访问数据库一样对Proxy进行访问，由Proxy对SQL进行解析，重写，路由到实际数据库等功能。比如DBProxy。</p>
</li>
</ul>
<p>Client模式架构简单，没有中间层，性能较好，减少了中间层Proxy的运维成本。Proxy模式对多语言的支持较好，不必为每种语言都进行一次应用框架客户端的封装和维护。相对来说个人比较喜欢Client模式。</p>
<h3 id="基于Client模式封装一个应用客户端jar"><a href="#基于Client模式封装一个应用客户端jar" class="headerlink" title="基于Client模式封装一个应用客户端jar"></a>基于Client模式封装一个应用客户端jar</h3><p>一般有两种实现方式：</p>
<ol>
<li><p>代理DataSource、Connection、Statement等jdbc协议中的接口，内部对原始DataSource，Connection，Statement等进行增强，添加SQL解析，重写，路由的能力。</p>
</li>
<li><p>基于spring和mybatis的扩展和插件，进行SQL的拦截，解析SQL，进行重写和路由。</p>
</li>
</ol>
<p>第一种方式对所属容器，ORM框架没有依赖，兼容性更好，第二种方式强依赖spring和mybatis，由于我们日常开发基本都是使用spring和mybatis，所以这里主要介绍第二种方式的实现原理，并亲自动手实现一个工具库：</p>
<h4 id="实现分表能力"><a href="#实现分表能力" class="headerlink" title="实现分表能力"></a>实现分表能力</h4><p>首先我们需要实现分表的能力：</p>
<ol>
<li><p>通过mybatis插件对SQL进行拦截，需要在创建Statement之前进行拦截，可以使用该拦截器：</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Intercepts</span>(&#123;<span class="meta">@Signature</span>(method = <span class="string">"prepare"</span>, type = StatementHandler.class, args = &#123;Connection.class, Integer.class&#125;)&#125;)</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ShardingInterceptor</span> <span class="keyword">implements</span> <span class="title">Interceptor</span> </span>&#123;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>由于需要知道哪些表的SQL需要被拦截重写，一般可以通过注解进行元数据的标记，定义如下注解，并将该注解标记在mybatis的mapper接口上，便可以在拦截器中获取分库分表规则：</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</div><div class="line"><span class="meta">@Target</span>(&#123;ElementType.TYPE&#125;)</div><div class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Sharding &#123;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 是否分表</div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">sharding</span><span class="params">()</span> <span class="keyword">default</span> <span class="keyword">true</span></span>;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 库名</div><div class="line">     */</div><div class="line">    <span class="function">String <span class="title">databaseName</span><span class="params">()</span></span>;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 基础表名</div><div class="line">     */</div><div class="line">    <span class="function">String <span class="title">tableName</span><span class="params">()</span></span>;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * <span class="doctag">@see</span> ShardingStrategy</div><div class="line">     * 分表策略</div><div class="line">     */</div><div class="line">    <span class="function">String <span class="title">strategy</span><span class="params">()</span></span>;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 分表数量</div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">int</span> <span class="title">count</span><span class="params">()</span></span>;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>对SQL进行重写时，需要根据一定的策略进行计算数据所在分表，定义如下分表策略接口，并提供一些基本实现：</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ShardingStrategy</span> </span>&#123;</div><div class="line"></div><div class="line">    String UNDERLINE = <span class="string">"_"</span>;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 获取分表位的实际表名</div><div class="line">     *</div><div class="line">     * <span class="doctag">@param</span> sharding    Sharding信息</div><div class="line">     * <span class="doctag">@param</span> shardingKey 分库分表因子</div><div class="line">     * <span class="doctag">@return</span> 带分表位的实际表名</div><div class="line">     */</div><div class="line">    <span class="function">String <span class="title">getTargetTableName</span><span class="params">(Sharding sharding, String shardingKey)</span></span>;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 计算分表</div><div class="line">     *</div><div class="line">     * <span class="doctag">@param</span> sharding    Sharding信息</div><div class="line">     * <span class="doctag">@param</span> shardingKey 分库分表因子</div><div class="line">     * <span class="doctag">@return</span> 计算分表</div><div class="line">     */</div><div class="line">    <span class="function">Integer <span class="title">calculateTableSuffix</span><span class="params">(Sharding sharding, String shardingKey)</span></span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractShardingStrategyWithDataBase</span> <span class="keyword">implements</span> <span class="title">ShardingStrategy</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">protected</span> <span class="keyword">static</span> Map&lt;String, ShardingDataSourceInfo&gt; shardingDataSourceInfoMap = Maps.newHashMap();</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">setShardingDataSourceInfoMap</span><span class="params">(Map&lt;String, ShardingDataSourceInfo&gt; shardingDataSourceInfoMap)</span> </span>&#123;</div><div class="line">        AbstractShardingStrategyWithDataBase.shardingDataSourceInfoMap = shardingDataSourceInfoMap;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getTargetTableName</span><span class="params">(Sharding sharding, String shardingKey)</span> </span>&#123;</div><div class="line">        Integer tableSuffix = calculateTableSuffix(sharding, shardingKey);</div><div class="line">        <span class="keyword">return</span> getTableName(sharding.tableName(), tableSuffix);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getTableName</span><span class="params">(String tableName, Integer shardingKey)</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> tableName + UNDERLINE + shardingKey;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HashShardingStrategyWithDataBase</span> <span class="keyword">extends</span> <span class="title">AbstractShardingStrategyWithDataBase</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> Integer <span class="title">calculateTableSuffix</span><span class="params">(Sharding sharding, String shardingKey)</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> Math.abs(shardingKey.hashCode()) % sharding.count();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>在拦截器中，获取当前sql对应的mybatis元信息，从元信息中获取对应mapper接口上的标记注解，用来获取分库分表信息，进行SQL的重写：</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div></pre></td><td class="code"><pre><div class="line">@Override</div><div class="line">   public Object intercept(Invocation invocation) throws Throwable &#123;</div><div class="line">       StatementHandler statementHandler = (StatementHandler) realTarget(invocation.getTarget());</div><div class="line">       MetaObject metaObject = SystemMetaObject.forObject(statementHandler);</div><div class="line">	</div><div class="line">       String id = (String) metaObject.getValue(DELEGATE_MAPPED_STATEMENT_ID);</div><div class="line">       String className = id.substring(0, id.lastIndexOf(POINT));</div><div class="line">       Sharding sharding = Class.forName(className).getDeclaredAnnotation(Sharding.class);</div><div class="line">       if (sharding != null &amp;&amp; sharding.sharding()) &#123;</div><div class="line">           String sql = (String) metaObject.getValue(DELEGATE_BOUND_SQL_SQL);</div><div class="line">           sql = sql.replaceAll(sharding.tableName(), getTargetTableName(metaObject, sharding));</div><div class="line">           metaObject.setValue(DELEGATE_BOUND_SQL_SQL, sql);</div><div class="line">       &#125;</div><div class="line">       return invocation.proceed();</div><div class="line">   &#125;</div><div class="line">   </div><div class="line">   private String getTargetTableName(MetaObject metaObject, Sharding sharding) throws Exception &#123;</div><div class="line">       String shardingKey = getShardingKey(metaObject);</div><div class="line">       String targetTableName;</div><div class="line">       if (!StringUtils.isEmpty(shardingKey)) &#123;</div><div class="line">           targetTableName = getShardingStrategy(sharding).getTargetTableName(sharding, shardingKey);</div><div class="line">       &#125; else if (StringUtils.isEmpty(shardingKey) &amp;&amp; !StringUtils.isEmpty(ShardingContext.getShardingTable())) &#123;</div><div class="line">           targetTableName = DEFAULT_SHARDING_STRATEGY.getTargetTableName(sharding, ShardingContext.getShardingTable());</div><div class="line">       &#125; else &#123;</div><div class="line">           throw new RuntimeException(&quot;没有找到分表信息。shardingKey=&quot; + shardingKey + &quot;，ShardingContext=&quot; + ShardingContext.getShardingTable());</div><div class="line">       &#125;</div><div class="line">       return targetTableName;</div><div class="line">   &#125;</div><div class="line"></div><div class="line">   /**</div><div class="line">    * 默认取第一个参数作为分表键</div><div class="line">    * @param metaObject</div><div class="line">    * @return</div><div class="line">    */</div><div class="line">   private String getShardingKey(MetaObject metaObject) &#123;</div><div class="line">       String shardingKey = null;</div><div class="line">       Object parameterObject = metaObject.getValue(DELEGATE_PARAMETER_HANDLER_PARAMETER_OBJECT);</div><div class="line">       if (parameterObject instanceof String) &#123;</div><div class="line">           shardingKey = (String) parameterObject;</div><div class="line">       &#125; else if (parameterObject instanceof Map) &#123;</div><div class="line">           Map&lt;String, Object&gt; parameterMap = (Map&lt;String, Object&gt;) parameterObject;</div><div class="line">           Object param1 = parameterMap.get(PARAM_1);</div><div class="line">           if (param1 instanceof String) &#123;</div><div class="line">               shardingKey = (String) param1;</div><div class="line">           &#125;</div><div class="line">       &#125;</div><div class="line">       return shardingKey;</div><div class="line">   &#125;</div></pre></td></tr></table></figure>
</li>
<li><p>考虑到有些扫表类sql并不包含分表键，所以提供如下扩展类，通过ThreadLocal进行路由填充，当sql中不存在分表键时，使用该扩展类处理：</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ShardingContext</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 分表Key 表名后缀</div><div class="line">     * 直接填充分表位，主要用于按表进行扫描，使用完成后必须及时调用clear方法清空上下文</div><div class="line">     */</div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ThreadLocal&lt;String&gt; SHARDING_TABLE = <span class="keyword">new</span> ThreadLocal&lt;&gt;();</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">getShardingTable</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> SHARDING_TABLE.get();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">setShardingTable</span><span class="params">(String shardingTable)</span> </span>&#123;</div><div class="line">        SHARDING_TABLE.set(shardingTable);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span> </span>&#123;</div><div class="line">        ShardingContext.SHARDING_TABLE.remove();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ol>
<p>这样我们就实现了一个具备分表能力的插件了。</p>
<h3 id="实现分库能力"><a href="#实现分库能力" class="headerlink" title="实现分库能力"></a>实现分库能力</h3><p>基于分表能力，进行增强，实现分库能力：</p>
<ol>
<li><p>进行分库可以通过spring提供的<code>AbstractRoutingDataSource</code>抽象类进行扩展，该类内部维护了一个DataSource的map，需要自行实现<code>determineCurrentLookupKey</code>方法获取分库key，然后根据该key来获取对应的DataSource：</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ShardingDataSource</span> <span class="keyword">extends</span> <span class="title">AbstractRoutingDataSource</span> </span>&#123;</div><div class="line">	</div><div class="line">    <span class="comment">/**</span></div><div class="line">     * ShardingContext.getShardingDatabase() 为库名+分库序号</div><div class="line">     *</div><div class="line">     * <span class="doctag">@return</span></div><div class="line">     */</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">protected</span> Object <span class="title">determineCurrentLookupKey</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> ShardingContext.getShardingDatabase();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ShardingContext</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 分库key 库名+分库序号</div><div class="line">     * 用于获取对应库名序号的dataSource</div><div class="line">     * 使用分库插件时必须及时调用clear方法清空上下文</div><div class="line">     */</div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ThreadLocal&lt;String&gt; SHARDING_DATABASE = <span class="keyword">new</span> ThreadLocal&lt;&gt;();</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 分表Key 表名后缀</div><div class="line">     * 直接填充分表位，主要用于按表进行扫描，使用完成后必须及时调用clear方法清空上下文</div><div class="line">     */</div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ThreadLocal&lt;String&gt; SHARDING_TABLE = <span class="keyword">new</span> ThreadLocal&lt;&gt;();</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">getShardingDatabase</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> SHARDING_DATABASE.get();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">setShardingDatabase</span><span class="params">(String shardingDatabase)</span> </span>&#123;</div><div class="line">        SHARDING_DATABASE.set(shardingDatabase);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">getShardingTable</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> SHARDING_TABLE.get();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">setShardingTable</span><span class="params">(String shardingTable)</span> </span>&#123;</div><div class="line">        SHARDING_TABLE.set(shardingTable);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span> </span>&#123;</div><div class="line">        ShardingContext.SHARDING_DATABASE.remove();</div><div class="line">        ShardingContext.SHARDING_TABLE.remove();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>通过<code>AbstractRoutingDataSource</code>进行分库需要我们获取数据库连接前计算好所属分库，首先需要自定义如下配置格式信息用于配置各个分库相关信息，配置文件中需要定义各个分库的分库策略、分库数量、每个数据库的连接池配置：</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">sharding.databases.test.shardingStrategy=cn.blogxin.sharding.plugin.strategy.database.DefaultShardingDataBaseStrategy</div><div class="line">sharding.databases.test.shardingCount=<span class="number">2</span></div><div class="line"></div><div class="line">sharding.databases.test.dataSource.master.0.driverClassName=com.mysql.jdbc.Driver</div><div class="line">sharding.databases.test.dataSource.master.0.url=jdbc:mysql:<span class="comment">//127.0.0.1:3306/test?useUnicode=true&amp;characterEncoding=utf-8</span></div><div class="line">sharding.databases.test.dataSource.master.0.username=root</div><div class="line">sharding.databases.test.dataSource.master.0.password=</div><div class="line"></div><div class="line">sharding.databases.test.dataSource.master.1.driverClassName=com.mysql.jdbc.Driver</div><div class="line">sharding.databases.test.dataSource.master.1.url=jdbc:mysql:<span class="comment">//127.0.0.1:3306/test1?useUnicode=true&amp;characterEncoding=utf-8</span></div><div class="line">sharding.databases.test.dataSource.master.1.username=root</div><div class="line">sharding.databases.test.dataSource.master.1.password=</div></pre></td></tr></table></figure>
</li>
<li><p>需要根据一定的策略进行分库的计算，定义如下分库策略接口，并提供一些基本实现：</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ShardingDataBaseStrategy</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 计算获取对应分库序号</div><div class="line">     *</div><div class="line">     * <span class="doctag">@param</span> sharingDataBaseCount    分库数量</div><div class="line">     * <span class="doctag">@param</span> sharingTableCount       分表数量</div><div class="line">     * <span class="doctag">@param</span> currentShardingTableKey 当前分表位</div><div class="line">     * <span class="doctag">@return</span> 分库序号</div><div class="line">     */</div><div class="line">    <span class="function">Integer <span class="title">calculate</span><span class="params">(<span class="keyword">int</span> sharingDataBaseCount, <span class="keyword">int</span> sharingTableCount, <span class="keyword">int</span> currentShardingTableKey)</span></span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * 默认分库策略，将分表从小到大均匀分配至各分库中</div><div class="line"> * 比如：</div><div class="line"> * 2个库，10个表</div><div class="line"> * 0-4表在0库，5-9表在1库</div><div class="line"> *</div><div class="line"> * <span class="doctag">@author</span> kris</div><div class="line"> */</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DefaultShardingDataBaseStrategy</span> <span class="keyword">implements</span> <span class="title">ShardingDataBaseStrategy</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> Integer <span class="title">calculate</span><span class="params">(<span class="keyword">int</span> sharingDataBaseCount, <span class="keyword">int</span> sharingTableCount, <span class="keyword">int</span> currentShardingTableKey)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (sharingTableCount &gt;= sharingDataBaseCount &amp;&amp; sharingTableCount % sharingDataBaseCount == <span class="number">0</span>) &#123;</div><div class="line">            <span class="keyword">int</span> base = sharingTableCount / sharingDataBaseCount;</div><div class="line">            <span class="keyword">return</span> currentShardingTableKey / base;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"分库分表规则配置错误"</span>);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>加载该分库配置文件信息，并初始化<code>ShardingDataSource</code>：</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Configuration</span></div><div class="line"><span class="meta">@ConfigurationProperties</span>(prefix = <span class="string">"sharding"</span>)</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ShardingProperties</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> Map&lt;String, Database&gt; databases;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> Map&lt;String, Database&gt; <span class="title">getDatabases</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> databases;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setDatabases</span><span class="params">(Map&lt;String, Database&gt; databases)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.databases = databases;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Database</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 分库策略</div><div class="line">     */</div><div class="line">    <span class="keyword">private</span> String shardingStrategy = <span class="string">""</span>;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 分库数量</div><div class="line">     */</div><div class="line">    <span class="keyword">private</span> Integer shardingCount;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * key：分库位</div><div class="line">     * value：分库对应的dataSource配置</div><div class="line">     */</div><div class="line">    <span class="keyword">private</span> Map&lt;String, Map&lt;Integer, DataSourceProperties&gt;&gt; dataSource;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getShardingStrategy</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> shardingStrategy;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setShardingStrategy</span><span class="params">(String shardingStrategy)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.shardingStrategy = shardingStrategy;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> Integer <span class="title">getShardingCount</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> shardingCount;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setShardingCount</span><span class="params">(Integer shardingCount)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.shardingCount = shardingCount;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">public</span> Map&lt;String, Map&lt;Integer, DataSourceProperties&gt;&gt; getDataSource() &#123;</div><div class="line">        <span class="keyword">return</span> dataSource;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setDataSource</span><span class="params">(Map&lt;String, Map&lt;Integer, DataSourceProperties&gt;&gt; dataSource)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.dataSource = dataSource;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Resource</span></div><div class="line"><span class="keyword">private</span> ShardingProperties shardingProperties;</div><div class="line">	</div><div class="line"><span class="function"><span class="keyword">private</span> DataSource <span class="title">shardingDataSource</span><span class="params">()</span> </span>&#123;</div><div class="line">    Map&lt;String, Database&gt; databases = shardingProperties.getDatabases();</div><div class="line">    Preconditions.checkArgument(!CollectionUtils.isEmpty(databases), <span class="string">"不存在分库配置"</span>);</div><div class="line">	</div><div class="line">    Map&lt;String, ShardingDataSourceInfo&gt; shardingDataSourceInfoMap = Maps.newHashMap();</div><div class="line">    Map&lt;Object, Object&gt; targetDataSources = Maps.newHashMap();</div><div class="line">    DataSource dataSource = <span class="keyword">null</span>;</div><div class="line">	</div><div class="line">    <span class="keyword">for</span> (Map.Entry&lt;String, Database&gt; entry : databases.entrySet()) &#123;</div><div class="line">        String dataBaseName = entry.getKey();</div><div class="line">        Database database = entry.getValue();</div><div class="line">	</div><div class="line">        ShardingDataSourceInfo shardingDataSourceInfo = <span class="keyword">new</span> ShardingDataSourceInfo();</div><div class="line">        shardingDataSourceInfo.setShardingCount(database.getShardingCount());</div><div class="line">        shardingDataSourceInfo.setShardingDataBaseStrategy(createShardingDataBaseStrategy(database.getShardingStrategy()));</div><div class="line">        shardingDataSourceInfoMap.put(dataBaseName, shardingDataSourceInfo);</div><div class="line">	</div><div class="line">        Set&lt;Map.Entry&lt;String, Map&lt;Integer, DataSourceProperties&gt;&gt;&gt; entries = database.getDataSource().entrySet();</div><div class="line">        <span class="keyword">for</span> (Map.Entry&lt;String, Map&lt;Integer, DataSourceProperties&gt;&gt; masterSlave : entries) &#123;</div><div class="line">            String masterSlaveKey = masterSlave.getKey();</div><div class="line">            Map&lt;Integer, DataSourceProperties&gt; masterSlaveValue = masterSlave.getValue();</div><div class="line">            <span class="keyword">for</span> (Map.Entry&lt;Integer, DataSourceProperties&gt; propertiesEntry : masterSlaveValue.entrySet()) &#123;</div><div class="line">                String shardingDataBaseKey = dataBaseName + masterSlaveKey + propertiesEntry.getKey();</div><div class="line">                dataSource = createDataSource(propertiesEntry.getValue(), HikariDataSource.class);</div><div class="line">                targetDataSources.put(shardingDataBaseKey, dataSource);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">	</div><div class="line">    Preconditions.checkArgument(MapUtils.isNotEmpty(targetDataSources), <span class="string">"找不到database配置"</span>);</div><div class="line">    Preconditions.checkNotNull(dataSource, <span class="string">"找不到database配置"</span>);</div><div class="line">	</div><div class="line">    AbstractShardingStrategyWithDataBase.setShardingDataSourceInfoMap(shardingDataSourceInfoMap);</div><div class="line">	</div><div class="line">    ShardingDataSource shardingDataSource = <span class="keyword">new</span> ShardingDataSource();</div><div class="line">    shardingDataSource.setTargetDataSources(targetDataSources);</div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 用于创建LazyConnectionDataSourceProxy时获取真实数据库连接，来获取实际数据库的自动提交配置和隔离级别</div><div class="line">     */</div><div class="line">    shardingDataSource.setDefaultTargetDataSource(dataSource);</div><div class="line">    shardingDataSource.setLenientFallback(<span class="keyword">false</span>);</div><div class="line">    shardingDataSource.afterPropertiesSet();</div><div class="line">    <span class="keyword">return</span> shardingDataSource;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>计算分表时，需要额外计算好分库位，扩展分表插件的抽象类<code>AbstractShardingStrategyWithDataBase</code>，在计算分表时，根据分表位，获取分表所属的分库key，设置到<code>ShardingContext.setShardingDatabase</code>中，用于在<code>ShardingDataSource.determineCurrentLookupKey()</code>中获取分库key，来获取所属的真实DataSource：</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractShardingStrategyWithDataBase</span> <span class="keyword">implements</span> <span class="title">ShardingStrategy</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Map&lt;String, ShardingDataSourceInfo&gt; shardingDataSourceInfoMap = Maps.newHashMap();</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">setShardingDataSourceInfoMap</span><span class="params">(Map&lt;String, ShardingDataSourceInfo&gt; shardingDataSourceInfoMap)</span> </span>&#123;</div><div class="line">        AbstractShardingStrategyWithDataBase.shardingDataSourceInfoMap = shardingDataSourceInfoMap;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getTargetTableName</span><span class="params">(Sharding sharding, String shardingKey)</span> </span>&#123;</div><div class="line">        Integer tableSuffix = calculateTableSuffix(sharding, shardingKey);</div><div class="line">        ShardingDataSourceInfo shardingDataSourceInfo = shardingDataSourceInfoMap.get(sharding.databaseName());</div><div class="line">        <span class="keyword">if</span> (shardingDataSourceInfo != <span class="keyword">null</span>) &#123;</div><div class="line">            <span class="keyword">int</span> databaseNum = shardingDataSourceInfo.getShardingDataBaseStrategy().calculate(shardingDataSourceInfo.getShardingCount(), sharding.count(), tableSuffix);</div><div class="line">            ShardingContext.setShardingDatabase(sharding.databaseName() + ShardingContext.getMasterSalve() + databaseNum);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> getTableName(sharding.tableName(), tableSuffix);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">private</span> String <span class="title">getTableName</span><span class="params">(String tableName, Integer shardingKey)</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> tableName + UNDERLINE + shardingKey;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>由于进行SQL重写路由时使用的是创建Statement前阶段的mybatis插件，此时已经获取到了一个真实的数据库连接，无法重新进行分库级别的路由了，那么我们只能将路由阶段提前或者将获取数据库连接阶段延后，提前的话有可能我们拿不到待执行的SQL，所以我们只能选择将获取连接阶段延后。可以使用spring提供的<code>LazyConnectionDataSourceProxy</code>，使用该延迟类型数据库连接池在创建连接时，并不会真正创建连接，而是产生一个<code>Connection</code>代理类，对该代理<code>Connection</code>进行属性设置，比如开启事务、设置隔离级别等配置修改时，只是在内存中进行记录，只有需要执行sql时，才会真正创建一个<code>Connection</code>，并将之前内存中的事务属性、隔离级别属性应用到该真实<code>Connection</code>上。通过该延迟类型连接池，我们就可以在创建Statement前阶段的mybatis插件中，通过<code>ShardingContext.setShardingDatabase</code>进行分库key的设置，从而在<code>ShardingDataSource</code>中获取该SQL所属的分库对应的<code>DataSource</code>，来获取对应的<code>Connection</code>：</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Configuration</span></div><div class="line"><span class="meta">@AutoConfigureBefore</span>(DataSourceAutoConfiguration.class)</div><div class="line"><span class="meta">@ConditionalOnProperty</span>(name = <span class="string">"sharding.databases"</span>, havingValue = <span class="string">"enable"</span>)</div><div class="line"><span class="meta">@EnableConfigurationProperties</span>(ShardingProperties.class)</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ShardingDataSourceConfiguration</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="meta">@Resource</span></div><div class="line">    <span class="keyword">private</span> ShardingProperties shardingProperties;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">private</span> DataSource <span class="title">shardingDataSource</span><span class="params">()</span> </span>&#123;</div><div class="line">        Map&lt;String, Database&gt; databases = shardingProperties.getDatabases();</div><div class="line">        Preconditions.checkArgument(!CollectionUtils.isEmpty(databases), <span class="string">"不存在分库配置"</span>);</div><div class="line"></div><div class="line">        Map&lt;String, ShardingDataSourceInfo&gt; shardingDataSourceInfoMap = Maps.newHashMap();</div><div class="line">        Map&lt;Object, Object&gt; targetDataSources = Maps.newHashMap();</div><div class="line">        DataSource dataSource = <span class="keyword">null</span>;</div><div class="line"></div><div class="line">        <span class="keyword">for</span> (Map.Entry&lt;String, Database&gt; entry : databases.entrySet()) &#123;</div><div class="line">            String dataBaseName = entry.getKey();</div><div class="line">            Database database = entry.getValue();</div><div class="line"></div><div class="line">            ShardingDataSourceInfo shardingDataSourceInfo = <span class="keyword">new</span> ShardingDataSourceInfo();</div><div class="line">            shardingDataSourceInfo.setShardingCount(database.getShardingCount());</div><div class="line">            shardingDataSourceInfo.setShardingDataBaseStrategy(createShardingDataBaseStrategy(database.getShardingStrategy()));</div><div class="line">            shardingDataSourceInfoMap.put(dataBaseName, shardingDataSourceInfo);</div><div class="line"></div><div class="line">            Set&lt;Map.Entry&lt;String, Map&lt;Integer, DataSourceProperties&gt;&gt;&gt; entries = database.getDataSource().entrySet();</div><div class="line">            <span class="keyword">for</span> (Map.Entry&lt;String, Map&lt;Integer, DataSourceProperties&gt;&gt; masterSlave : entries) &#123;</div><div class="line">                String masterSlaveKey = masterSlave.getKey();</div><div class="line">                Map&lt;Integer, DataSourceProperties&gt; masterSlaveValue = masterSlave.getValue();</div><div class="line">                <span class="keyword">for</span> (Map.Entry&lt;Integer, DataSourceProperties&gt; propertiesEntry : masterSlaveValue.entrySet()) &#123;</div><div class="line">                    String shardingDataBaseKey = dataBaseName + masterSlaveKey + propertiesEntry.getKey();</div><div class="line">                    dataSource = createDataSource(propertiesEntry.getValue(), HikariDataSource.class);</div><div class="line">                    targetDataSources.put(shardingDataBaseKey, dataSource);</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        Preconditions.checkArgument(MapUtils.isNotEmpty(targetDataSources), <span class="string">"找不到database配置"</span>);</div><div class="line">        Preconditions.checkNotNull(dataSource, <span class="string">"找不到database配置"</span>);</div><div class="line"></div><div class="line">        AbstractShardingStrategyWithDataBase.setShardingDataSourceInfoMap(shardingDataSourceInfoMap);</div><div class="line"></div><div class="line">        ShardingDataSource shardingDataSource = <span class="keyword">new</span> ShardingDataSource();</div><div class="line">        shardingDataSource.setTargetDataSources(targetDataSources);</div><div class="line">        <span class="comment">/**</span></div><div class="line">         * 用于创建LazyConnectionDataSourceProxy时获取真实数据库连接，来获取实际数据库的自动提交配置和隔离级别</div><div class="line">         */</div><div class="line">        shardingDataSource.setDefaultTargetDataSource(dataSource);</div><div class="line">        shardingDataSource.setLenientFallback(<span class="keyword">false</span>);</div><div class="line">        shardingDataSource.afterPropertiesSet();</div><div class="line">        <span class="keyword">return</span> shardingDataSource;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Bean</span></div><div class="line">    <span class="function"><span class="keyword">public</span> DataSource <span class="title">dataSource</span><span class="params">()</span> </span>&#123;</div><div class="line">        LazyConnectionDataSourceProxy dataSourceProxy = <span class="keyword">new</span> LazyConnectionDataSourceProxy();</div><div class="line">        dataSourceProxy.setTargetDataSource(shardingDataSource());</div><div class="line">        <span class="keyword">return</span> dataSourceProxy;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ol>
<p>通过spring提供的<code>AbstractRoutingDataSource</code>以及<code>LazyConnectionDataSourceProxy</code>扩展类，便可以快速实现分库能力了。</p>
<h3 id="实现读写分离能力"><a href="#实现读写分离能力" class="headerlink" title="实现读写分离能力"></a>实现读写分离能力</h3><ol>
<li><p>分库分表配置文件信息中添加<code>slave</code>从库节点的信息：</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">sharding.databases.test.shardingStrategy=cn.blogxin.sharding.plugin.strategy.database.DefaultShardingDataBaseStrategy</div><div class="line">sharding.databases.test.shardingCount=<span class="number">2</span></div><div class="line"></div><div class="line">sharding.databases.test.dataSource.master.0.driverClassName=com.mysql.jdbc.Driver</div><div class="line">sharding.databases.test.dataSource.master.0.url=jdbc:mysql:<span class="comment">//127.0.0.1:3306/test?useUnicode=true&amp;characterEncoding=utf-8</span></div><div class="line">sharding.databases.test.dataSource.master.0.username=root</div><div class="line">sharding.databases.test.dataSource.master.0.password=</div><div class="line"></div><div class="line">sharding.databases.test.dataSource.master.1.driverClassName=com.mysql.jdbc.Driver</div><div class="line">sharding.databases.test.dataSource.master.1.url=jdbc:mysql:<span class="comment">//127.0.0.1:3306/test1?useUnicode=true&amp;characterEncoding=utf-8</span></div><div class="line">sharding.databases.test.dataSource.master.1.username=root</div><div class="line">sharding.databases.test.dataSource.master.1.password=</div><div class="line"></div><div class="line">sharding.databases.test.dataSource.slave.0.driverClassName=com.mysql.jdbc.Driver</div><div class="line">sharding.databases.test.dataSource.slave.0.url=jdbc:mysql:<span class="comment">//127.0.0.1:3306/test?useUnicode=true&amp;characterEncoding=utf-8</span></div><div class="line">sharding.databases.test.dataSource.slave.0.username=root</div><div class="line">sharding.databases.test.dataSource.slave.0.password=</div><div class="line"></div><div class="line">sharding.databases.test.dataSource.slave.1.driverClassName=com.mysql.jdbc.Driver</div><div class="line">sharding.databases.test.dataSource.slave.1.url=jdbc:mysql:<span class="comment">//127.0.0.1:3306/test1?useUnicode=true&amp;characterEncoding=utf-8</span></div><div class="line">sharding.databases.test.dataSource.slave.1.username=root</div><div class="line">sharding.databases.test.dataSource.slave.1.password=</div></pre></td></tr></table></figure>
</li>
<li><p>在<code>ShardingContext</code>中添加主从信息的上下文，需要使用从库时，通过<code>forceSlave()</code>方法进行设置，这样在设置分库key的时候就可以通过<code>ShardingContext.getMasterSalve()</code>方法获取主从节点信息，然后通过<code>ShardingContext.setShardingDatabase(sharding.databaseName() + ShardingContext.getMasterSalve() + databaseNum);</code>方法设置分库key，通过这种方式将SQL的执行路由到从库对应的<code>DataSource</code>。一般可以通过AOP的方式，在切面中通过<code>ShardingContext</code>来设置是否需要在从库执行SQL，并在切面中及时清除上下文信息：</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * 分库分表表上下文，使用完成后必须及时调用clear方法清空上下文</div><div class="line"> *</div><div class="line"> * <span class="doctag">@author</span> kris</div><div class="line"> */</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ShardingContext</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * MASTER OR SLAVE</div><div class="line">     * 建议通过切面设置强制读从库，DB操作执行完成后在切面执行clearSlave方法，清除主从上下文</div><div class="line">     */</div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ThreadLocal&lt;String&gt; MASTER_SALVE = <span class="keyword">new</span> ThreadLocal&lt;String&gt;() &#123;</div><div class="line">        <span class="meta">@Override</span></div><div class="line">        <span class="function"><span class="keyword">protected</span> String <span class="title">initialValue</span><span class="params">()</span> </span>&#123;</div><div class="line">            <span class="keyword">return</span> Constants.MASTER;</div><div class="line">        &#125;</div><div class="line">    &#125;;</div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">forceSlave</span><span class="params">()</span> </span>&#123;</div><div class="line">        MASTER_SALVE.set(Constants.SLAVE);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">clearSlave</span><span class="params">()</span> </span>&#123;</div><div class="line">        MASTER_SALVE.remove();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">getMasterSalve</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> MASTER_SALVE.get();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span> </span>&#123;</div><div class="line">        ShardingContext.MASTER_SALVE.remove();</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
</li>
</ol>
<h3 id="使用springboot的starter自动装配"><a href="#使用springboot的starter自动装配" class="headerlink" title="使用springboot的starter自动装配"></a>使用springboot的starter自动装配</h3><p>Spring Boot Starter是在SpringBoot组件中被提出来的一种概念，Starter会把该功能模块所有用到的依赖都给包含进来，避免了开发者自己去引入依赖所带来的麻烦，基于“约定大于配置”这一理念对模块内的Bean根据一定条件进行自动装配。使用者只需要依赖相应功能的Starter，无需做过多的配置和依赖，Spring Boot就能自动扫描并加载相应的模块。</p>
<p>下面我们把该分库分表库封装成一个Starter：</p>
<ol>
<li><p>首先在封装的插件jar中添加如下两个自动配置类：</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Configuration</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ShardingTableConfiguration</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="meta">@Bean</span></div><div class="line">    <span class="function"><span class="keyword">public</span> ShardingInterceptor <span class="title">shardingInterceptor</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ShardingInterceptor();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Configuration</span></div><div class="line"><span class="meta">@AutoConfigureBefore</span>(DataSourceAutoConfiguration.class)</div><div class="line"><span class="meta">@ConditionalOnProperty</span>(name = <span class="string">"sharding.databases"</span>, havingValue = <span class="string">"enable"</span>)</div><div class="line"><span class="meta">@EnableConfigurationProperties</span>(ShardingProperties.class)</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ShardingDataSourceConfiguration</span> </span>&#123;</div><div class="line"></div><div class="line">	... ...</div><div class="line">	... ...</div><div class="line">	</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>创建一个<code>sharding-db-spring-boot-starter</code>模块，引入插件jar：</p>
 <figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></div><div class="line">	<span class="tag">&lt;<span class="name">dependency</span>&gt;</span></div><div class="line">		<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>cn.blogxin.sharding<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></div><div class="line">		<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></div><div class="line">		<span class="tag">&lt;<span class="name">version</span>&gt;</span>0.0.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></div><div class="line">	<span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></div></pre></td></tr></table></figure>
</li>
<li><p>在<code>sharding-db-spring-boot-starter</code>模块中，路径<code>resources/META-INF/</code>下创建一个<code>spring.factories</code>文件，在该文件内添加需要自动装配的类：</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">org.springframework.boot.autoconfigure.EnableAutoConfiguration=\</div><div class="line">cn.blogxin.sharding.plugin.ShardingTableConfiguration,\</div><div class="line">cn.blogxin.sharding.plugin.ShardingDataSourceConfiguration</div></pre></td></tr></table></figure>
</li>
<li><p>引入该Starter即可以使用分库分表、主从分离的能力。由于分库、主从分离能力需要对数据库连接池进行特殊配置，所以将分库能力做成可选，只有添加了相关特殊配置才能自动启动该能力：</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@ConditionalOnProperty</span>(name = <span class="string">"sharding.databases"</span>, havingValue = <span class="string">"enable"</span>)</div></pre></td></tr></table></figure>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sharding.databases=enable</div></pre></td></tr></table></figure>
 <figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>cn.blogxin.sharding<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>sharding-db-spring-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;project.parent.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></div></pre></td></tr></table></figure>
</li>
</ol>
<h3 id="实现DOME"><a href="#实现DOME" class="headerlink" title="实现DOME"></a>实现DOME</h3><p>基于上述对分库分表、主从读写分离的一种实现方案的原理描述，亲自动手实现了一个可实用的demo：</p>
<p><a href="https://github.com/kris-liu/Sharding-DB" target="_blank" rel="external">https://github.com/kris-liu/Sharding-DB</a></p>
</div><script type="text/javascript" src="/js/share.js?v=0.0.0" async></script><a class="article-share-link" data-url="http://blogxin.cn/2019/06/01/sharding-db/" data-id="ck79275bq00401015ao4eme28" data-qrcode="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAK4AAACuCAAAAACKZ2kyAAABvElEQVR42u3aQQ6DMAwEwP7/0+0LgN0Y0lYaThWkycDBSmy/XvH1PrjOxySzvZ64cHFxx9z36ZVQjhY+muH86cVr4+LibuQmiz1HSQy4uLj/wm1DXj4/Li7uf3Hz12jv4OLi/hq33YKcL7/22jef1XBxcQfcPEv53O9H8ru4uLhL3Hd5tUGn/e/FzLi4uFu4eUBpSynJyHZdXFzc/dy1QNamUBPo6KyGi4s75rbESYCbjCx2ZLi4uDdx2zCUF0jaxOjFx8LFxf0SNymN5G0WbQHm4qPg4uJ+lbtW+MyLo/nTw/wNLi7uRm6+obmrwaLYNuHi4n6Je28ga5MsF1sfXFzcLdwnGqrap3XZBhcXdwu3baQ4DzTzImv+8ri4uM9xk0RG0Ti1dDQqGrxwcXG3c+cNWJOYE82Mi4u7nVvshtp0RjlPHTtxcXFv4q61Sa0djfL7RZzDxcV9gDs/5LRFkajNYp4DwcXFHXPXyqLJyLxMks+Pi4u7kzsPNHlK5eZqDy4u7g9wzxHttqY9buHi4v4mN7+zln69mBkXF3cjt22dbI8uycjoY+Hi4m7htsGlXXgywyi/i4uLu8L9ANVbuWis2NxXAAAAAElFTkSuQmCC">分享</a><div class="tags"><a href="/tags/架构/">架构</a><a href="/tags/Spring/">Spring</a><a href="/tags/SpringBoot/">SpringBoot</a><a href="/tags/MyBatis/">MyBatis</a></div><div class="post-nav"><a class="pre" href="/2020/02/16/Distributed-Transaction-1/">从零开始写一个分布式事务框架(一)</a><a class="next" href="/2019/03/02/multi-datacenter/">多活架构思考总结</a></div><div id="container"></div><link rel="stylesheet" type="text/css" href="//unpkg.com/gitalk/dist/gitalk.css?v=0.0.0"><script type="text/javascript" src="//cdn.bootcss.com/blueimp-md5/2.10.0/js/md5.js?v=0.0.0"></script><script type="text/javascript" src="//unpkg.com/gitalk/dist/gitalk.min.js?v=0.0.0"></script><script>var gitalk = new Gitalk({
  clientID: '530c0141e83989b1dc02',
  clientSecret: '89e61ba0adc9b0c630bcc2641c791bfd7ef9faea',
  repo: 'kris-liu.github.io',
  owner: 'kris-liu',
  admin: ['kris-liu'],
  id: md5(location.pathname),
  distractionFreeMode: false
})
gitalk.render('container')
</script></div></div></div><div class="pure-u-1-4 hidden_mid_and_down"><div id="sidebar"><div class="widget"><form class="search-form" action="//www.google.com/search" method="get" accept-charset="utf-8" target="_blank"><input type="text" name="q" maxlength="20" placeholder="Search"/><input type="hidden" name="sitesearch" value="http://blogxin.cn"/></form></div><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"> 分类</i></div><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/Concurrent/">Concurrent</a><span class="category-list-count">8</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Git/">Git</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/IO-NIO/">IO&NIO</a><span class="category-list-count">6</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Java/">Java</a><span class="category-list-count">5</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/MQ/">MQ</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Netty/">Netty</a><span class="category-list-count">6</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Spring/">Spring</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Tomcat/">Tomcat</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Tools/">Tools</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/架构/">架构</a><span class="category-list-count">6</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/线上问题/">线上问题</a><span class="category-list-count">4</span></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-star-o"> 标签</i></div><div class="tagcloud"><a href="/tags/源码/" style="font-size: 15px;">源码</a> <a href="/tags/架构/" style="font-size: 15px;">架构</a> <a href="/tags/Spring/" style="font-size: 15px;">Spring</a> <a href="/tags/JVM/" style="font-size: 15px;">JVM</a> <a href="/tags/GC/" style="font-size: 15px;">GC</a> <a href="/tags/线上问题/" style="font-size: 15px;">线上问题</a> <a href="/tags/Git/" style="font-size: 15px;">Git</a> <a href="/tags/IO/" style="font-size: 15px;">IO</a> <a href="/tags/NIO/" style="font-size: 15px;">NIO</a> <a href="/tags/内存泄漏/" style="font-size: 15px;">内存泄漏</a> <a href="/tags/Java/" style="font-size: 15px;">Java</a> <a href="/tags/并发/" style="font-size: 15px;">并发</a> <a href="/tags/锁/" style="font-size: 15px;">锁</a> <a href="/tags/Transaction/" style="font-size: 15px;">Transaction</a> <a href="/tags/异步/" style="font-size: 15px;">异步</a> <a href="/tags/读写锁/" style="font-size: 15px;">读写锁</a> <a href="/tags/缓存/" style="font-size: 15px;">缓存</a> <a href="/tags/线程池/" style="font-size: 15px;">线程池</a> <a href="/tags/BIO/" style="font-size: 15px;">BIO</a> <a href="/tags/AIO/" style="font-size: 15px;">AIO</a> <a href="/tags/JMM/" style="font-size: 15px;">JMM</a> <a href="/tags/内存模型/" style="font-size: 15px;">内存模型</a> <a href="/tags/Netty/" style="font-size: 15px;">Netty</a> <a href="/tags/Tomcat/" style="font-size: 15px;">Tomcat</a> <a href="/tags/MQ/" style="font-size: 15px;">MQ</a> <a href="/tags/Tools/" style="font-size: 15px;">Tools</a> <a href="/tags/SpringBoot/" style="font-size: 15px;">SpringBoot</a> <a href="/tags/MyBatis/" style="font-size: 15px;">MyBatis</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-file-o"> 最近文章</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2020/02/16/Distributed-Transaction-1/">从零开始写一个分布式事务框架(一)</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/06/01/sharding-db/">基于Spring+MyBatis实现一个分库分表、读写分离功能的工具库</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/03/02/multi-datacenter/">多活架构思考总结</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/02/06/spring-boot-init/">SpringBoot启动流程解析</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/11/15/OOM-killer/">线上Java进程消失排查分析</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/09/30/Distributed-Consistency/">分布式系统数据一致性问题常见解决方案</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/08/11/kafka-block/">由一次kafka消费端消息阻塞问题分析kafka消费端线程模型</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/07/29/TransactionMessage/">事务消息实现原理</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/04/23/Distributed-Transaction/">分布式事务</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/09/16/java-reference/">Java的强引用，软引用，弱引用，虚引用及其使用场景</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-external-link"> 友情链接</i></div><ul></ul><a href="http://blog.csdn.net/xx_ytm" title="我的CSDN博客" target="_blank">我的CSDN博客</a></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">Copyright © 2020 <a href="/." rel="nofollow">佑祺's Blog.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/tufu9441/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/pagecho"> Cho.</a></div></div></div><a class="show" id="rocket" href="#top"></a><script type="text/javascript" src="/js/totop.js?v=0.0.0" async></script><script type="text/javascript" src="//cdn.bootcss.com/fancybox/3.3.5/jquery.fancybox.min.js" async></script><script type="text/javascript" src="/js/fancybox.js?v=0.0.0" async></script><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/fancybox/3.3.5/jquery.fancybox.min.css"><script type="text/javascript" src="/js/codeblock-resizer.js?v=0.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=0.0.0"></script></div></body></html>